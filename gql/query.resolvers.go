package gql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"time"

	"beavermoney.app/ent"
	"beavermoney.app/ent/transaction"
	"beavermoney.app/ent/transactioncategory"
	"beavermoney.app/gql/model"
	"beavermoney.app/internal/contextkeys"
	"entgo.io/ent/dialect/sql"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

// IncomeBreakdown is the resolver for the incomeBreakdown field.
func (r *financialReportResolver) IncomeBreakdown(ctx context.Context, obj *model.FinancialReport) (*model.CategoryTypeAggregate, error) {
	userID := contextkeys.GetUserID(ctx)
	householdID := contextkeys.GetHouseholdID(ctx)

	ctx, span := r.tracer.Start(ctx, "financialReportResolver.IncomeBreakdown",
		trace.WithAttributes(
			attribute.Int("householdID", householdID),
			attribute.Int("userID", userID),
		),
	)
	defer span.End()

	return r.aggregateByCategoryType(ctx, obj, transactioncategory.TypeIncome)
}

// ExpensesBreakdown is the resolver for the expensesBreakdown field.
func (r *financialReportResolver) ExpensesBreakdown(ctx context.Context, obj *model.FinancialReport) (*model.CategoryTypeAggregate, error) {
	userID := contextkeys.GetUserID(ctx)
	householdID := contextkeys.GetHouseholdID(ctx)

	ctx, span := r.tracer.Start(ctx, "financialReportResolver.ExpensesBreakdown",
		trace.WithAttributes(
			attribute.Int("householdID", householdID),
			attribute.Int("userID", userID),
		),
	)
	defer span.End()

	return r.aggregateByCategoryType(ctx, obj, transactioncategory.TypeExpense)
}

// TransactionCount is the resolver for the transactionCount field.
func (r *financialReportResolver) TransactionCount(ctx context.Context, obj *model.FinancialReport) (int, error) {
	userID := contextkeys.GetUserID(ctx)
	householdID := contextkeys.GetHouseholdID(ctx)

	ctx, span := r.tracer.Start(ctx, "financialReportResolver.TransactionCount",
		trace.WithAttributes(
			attribute.Int("householdID", householdID),
			attribute.Int("userID", userID),
		),
	)
	defer span.End()

	client := r.entClient

	query := client.Transaction.Query().
		Modify(func(s *sql.Selector) {
			// Filter by household
			s.Where(sql.EQ(s.C(transaction.FieldHouseholdID), householdID))

			// Apply time filters
			if !obj.StartDate.IsZero() {
				s.Where(sql.GTE(s.C(transaction.FieldDatetime), obj.StartDate))
			}
			if !obj.EndDate.IsZero() {
				s.Where(sql.LT(s.C(transaction.FieldDatetime), obj.EndDate))
			}
		})

	count, err := query.Count(ctx)
	if err != nil {
		r.logger.Error("Failed to count transactions", "error", err)
		return 0, err
	}

	return count, nil
}

// Self is the resolver for the self field.
func (r *queryResolver) Self(ctx context.Context) (*ent.User, error) {
	userID := contextkeys.GetUserID(ctx)

	ctx, span := r.tracer.Start(ctx, "queryResolver.Self",
		trace.WithAttributes(
			attribute.Int("userID", userID),
		),
	)
	defer span.End()

	return r.entClient.User.Get(ctx, userID)
}

// FxRate is the resolver for the fxRate field.
func (r *queryResolver) FxRate(ctx context.Context, from string, to string, datetime time.Time) (string, error) {
	userID := contextkeys.GetUserID(ctx)
	householdID := contextkeys.GetHouseholdID(ctx)

	ctx, span := r.tracer.Start(ctx, "queryResolver.FxRate",
		trace.WithAttributes(
			attribute.Int("householdID", householdID),
			attribute.Int("userID", userID),
		),
	)
	defer span.End()

	rate, err := r.fxrateClient.GetRate(ctx, from, to, datetime)
	if err != nil {
		return "", err
	}

	return rate.String(), nil
}

// StockQuote is the resolver for the stockQuote field.
func (r *queryResolver) StockQuote(ctx context.Context, symbol string) (*model.StockQuoteResult, error) {
	userID := contextkeys.GetUserID(ctx)
	householdID := contextkeys.GetHouseholdID(ctx)

	ctx, span := r.tracer.Start(ctx, "queryResolver.StockQuote",
		trace.WithAttributes(
			attribute.Int("householdID", householdID),
			attribute.Int("userID", userID),
		),
	)
	defer span.End()

	stockQuote, err := r.marketClient.StockQuote(ctx, symbol)
	if err != nil {
		return nil, err
	}

	return &model.StockQuoteResult{
		Symbol:       symbol,
		Name:         stockQuote.Name,
		Exchange:     stockQuote.Exchange,
		Currency:     stockQuote.Currency,
		CurrentPrice: stockQuote.CurrentPrice.String(),
	}, nil
}

// CryptoQuote is the resolver for the cryptoQuote field.
func (r *queryResolver) CryptoQuote(ctx context.Context, symbol string) (*model.CryptoQuoteResult, error) {
	userID := contextkeys.GetUserID(ctx)
	householdID := contextkeys.GetHouseholdID(ctx)

	ctx, span := r.tracer.Start(ctx, "queryResolver.CryptoQuote",
		trace.WithAttributes(
			attribute.Int("householdID", householdID),
			attribute.Int("userID", userID),
		),
	)
	defer span.End()

	cryptoQuote, err := r.marketClient.CryptoQuote(ctx, symbol)
	if err != nil {
		return nil, err
	}

	return &model.CryptoQuoteResult{
		Symbol:       symbol,
		Name:         cryptoQuote.Name,
		Exchange:     cryptoQuote.Exchange,
		Currency:     cryptoQuote.Currency,
		CurrentPrice: cryptoQuote.CurrentPrice.String(),
	}, nil
}

// FinancialReport is the resolver for the financialReport field.
func (r *queryResolver) FinancialReport(ctx context.Context, period model.TimePeriodInput) (*model.FinancialReport, error) {
	userID := contextkeys.GetUserID(ctx)
	householdID := contextkeys.GetHouseholdID(ctx)

	_, span := r.tracer.Start(ctx, "queryResolver.FinancialReport",
		trace.WithAttributes(
			attribute.Int("householdID", householdID),
			attribute.Int("userID", userID),
		),
	)
	defer span.End()

	// Parse time period
	start, end := parseTimePeriod(period)

	return &model.FinancialReport{
		StartDate: start,
		EndDate:   end,
	}, nil
}

// NetWorthOverTime is the resolver for the netWorthOverTime field.
func (r *queryResolver) NetWorthOverTime(ctx context.Context, period model.TimePeriodInput) ([]*model.NetWorthDataPoint, error) {
	panic(fmt.Errorf("not implemented: NetWorthOverTime - netWorthOverTime"))
}

// FinancialReport returns FinancialReportResolver implementation.
func (r *Resolver) FinancialReport() FinancialReportResolver { return &financialReportResolver{r} }

type financialReportResolver struct{ *Resolver }
