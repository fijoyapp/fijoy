// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"beavermoney.app/ent/account"
	"beavermoney.app/ent/cryptoquotecache"
	"beavermoney.app/ent/currency"
	"beavermoney.app/ent/fxratecache"
	"beavermoney.app/ent/household"
	"beavermoney.app/ent/investment"
	"beavermoney.app/ent/investmentlot"
	"beavermoney.app/ent/predicate"
	"beavermoney.app/ent/stockquotecache"
	"beavermoney.app/ent/transaction"
	"beavermoney.app/ent/transactioncategory"
	"beavermoney.app/ent/transactionentry"
	"beavermoney.app/ent/user"
	"beavermoney.app/ent/userhousehold"
	"beavermoney.app/ent/userkey"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount             = "Account"
	TypeCryptoQuoteCache    = "CryptoQuoteCache"
	TypeCurrency            = "Currency"
	TypeFXRateCache         = "FXRateCache"
	TypeHousehold           = "Household"
	TypeInvestment          = "Investment"
	TypeInvestmentLot       = "InvestmentLot"
	TypeStockQuoteCache     = "StockQuoteCache"
	TypeTransaction         = "Transaction"
	TypeTransactionCategory = "TransactionCategory"
	TypeTransactionEntry    = "TransactionEntry"
	TypeUser                = "User"
	TypeUserHousehold       = "UserHousehold"
	TypeUserKey             = "UserKey"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	update_time                *time.Time
	name                       *string
	_type                      *account.Type
	balance                    *decimal.Decimal
	addbalance                 *decimal.Decimal
	icon                       *string
	value                      *decimal.Decimal
	addvalue                   *decimal.Decimal
	fx_rate                    *decimal.Decimal
	addfx_rate                 *decimal.Decimal
	clearedFields              map[string]struct{}
	household                  *int
	clearedhousehold           bool
	currency                   *int
	clearedcurrency            bool
	user                       *int
	cleareduser                bool
	transaction_entries        map[int]struct{}
	removedtransaction_entries map[int]struct{}
	clearedtransaction_entries bool
	investments                map[int]struct{}
	removedinvestments         map[int]struct{}
	clearedinvestments         bool
	done                       bool
	oldValue                   func(context.Context) (*Account, error)
	predicates                 []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AccountMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AccountMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AccountMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AccountMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AccountMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AccountMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetHouseholdID sets the "household_id" field.
func (m *AccountMutation) SetHouseholdID(i int) {
	m.household = &i
}

// HouseholdID returns the value of the "household_id" field in the mutation.
func (m *AccountMutation) HouseholdID() (r int, exists bool) {
	v := m.household
	if v == nil {
		return
	}
	return *v, true
}

// OldHouseholdID returns the old "household_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldHouseholdID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHouseholdID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHouseholdID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHouseholdID: %w", err)
	}
	return oldValue.HouseholdID, nil
}

// ResetHouseholdID resets all changes to the "household_id" field.
func (m *AccountMutation) ResetHouseholdID() {
	m.household = nil
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *AccountMutation) SetType(a account.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountMutation) GetType() (r account.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldType(ctx context.Context) (v account.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AccountMutation) ResetType() {
	m._type = nil
}

// SetBalance sets the "balance" field.
func (m *AccountMutation) SetBalance(d decimal.Decimal) {
	m.balance = &d
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *AccountMutation) Balance() (r decimal.Decimal, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBalance(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds d to the "balance" field.
func (m *AccountMutation) AddBalance(d decimal.Decimal) {
	if m.addbalance != nil {
		*m.addbalance = m.addbalance.Add(d)
	} else {
		m.addbalance = &d
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *AccountMutation) AddedBalance() (r decimal.Decimal, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *AccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetIcon sets the "icon" field.
func (m *AccountMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AccountMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *AccountMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[account.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *AccountMutation) IconCleared() bool {
	_, ok := m.clearedFields[account.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *AccountMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, account.FieldIcon)
}

// SetValue sets the "value" field.
func (m *AccountMutation) SetValue(d decimal.Decimal) {
	m.value = &d
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *AccountMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds d to the "value" field.
func (m *AccountMutation) AddValue(d decimal.Decimal) {
	if m.addvalue != nil {
		*m.addvalue = m.addvalue.Add(d)
	} else {
		m.addvalue = &d
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *AccountMutation) AddedValue() (r decimal.Decimal, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *AccountMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetFxRate sets the "fx_rate" field.
func (m *AccountMutation) SetFxRate(d decimal.Decimal) {
	m.fx_rate = &d
	m.addfx_rate = nil
}

// FxRate returns the value of the "fx_rate" field in the mutation.
func (m *AccountMutation) FxRate() (r decimal.Decimal, exists bool) {
	v := m.fx_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFxRate returns the old "fx_rate" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldFxRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFxRate: %w", err)
	}
	return oldValue.FxRate, nil
}

// AddFxRate adds d to the "fx_rate" field.
func (m *AccountMutation) AddFxRate(d decimal.Decimal) {
	if m.addfx_rate != nil {
		*m.addfx_rate = m.addfx_rate.Add(d)
	} else {
		m.addfx_rate = &d
	}
}

// AddedFxRate returns the value that was added to the "fx_rate" field in this mutation.
func (m *AccountMutation) AddedFxRate() (r decimal.Decimal, exists bool) {
	v := m.addfx_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetFxRate resets all changes to the "fx_rate" field.
func (m *AccountMutation) ResetFxRate() {
	m.fx_rate = nil
	m.addfx_rate = nil
}

// SetCurrencyID sets the "currency_id" field.
func (m *AccountMutation) SetCurrencyID(i int) {
	m.currency = &i
}

// CurrencyID returns the value of the "currency_id" field in the mutation.
func (m *AccountMutation) CurrencyID() (r int, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyID returns the old "currency_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCurrencyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyID: %w", err)
	}
	return oldValue.CurrencyID, nil
}

// ResetCurrencyID resets all changes to the "currency_id" field.
func (m *AccountMutation) ResetCurrencyID() {
	m.currency = nil
}

// SetUserID sets the "user_id" field.
func (m *AccountMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountMutation) ResetUserID() {
	m.user = nil
}

// ClearHousehold clears the "household" edge to the Household entity.
func (m *AccountMutation) ClearHousehold() {
	m.clearedhousehold = true
	m.clearedFields[account.FieldHouseholdID] = struct{}{}
}

// HouseholdCleared reports if the "household" edge to the Household entity was cleared.
func (m *AccountMutation) HouseholdCleared() bool {
	return m.clearedhousehold
}

// HouseholdIDs returns the "household" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HouseholdID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) HouseholdIDs() (ids []int) {
	if id := m.household; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHousehold resets all changes to the "household" edge.
func (m *AccountMutation) ResetHousehold() {
	m.household = nil
	m.clearedhousehold = false
}

// ClearCurrency clears the "currency" edge to the Currency entity.
func (m *AccountMutation) ClearCurrency() {
	m.clearedcurrency = true
	m.clearedFields[account.FieldCurrencyID] = struct{}{}
}

// CurrencyCleared reports if the "currency" edge to the Currency entity was cleared.
func (m *AccountMutation) CurrencyCleared() bool {
	return m.clearedcurrency
}

// CurrencyIDs returns the "currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) CurrencyIDs() (ids []int) {
	if id := m.currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrency resets all changes to the "currency" edge.
func (m *AccountMutation) ResetCurrency() {
	m.currency = nil
	m.clearedcurrency = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *AccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[account.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTransactionEntryIDs adds the "transaction_entries" edge to the TransactionEntry entity by ids.
func (m *AccountMutation) AddTransactionEntryIDs(ids ...int) {
	if m.transaction_entries == nil {
		m.transaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_entries[ids[i]] = struct{}{}
	}
}

// ClearTransactionEntries clears the "transaction_entries" edge to the TransactionEntry entity.
func (m *AccountMutation) ClearTransactionEntries() {
	m.clearedtransaction_entries = true
}

// TransactionEntriesCleared reports if the "transaction_entries" edge to the TransactionEntry entity was cleared.
func (m *AccountMutation) TransactionEntriesCleared() bool {
	return m.clearedtransaction_entries
}

// RemoveTransactionEntryIDs removes the "transaction_entries" edge to the TransactionEntry entity by IDs.
func (m *AccountMutation) RemoveTransactionEntryIDs(ids ...int) {
	if m.removedtransaction_entries == nil {
		m.removedtransaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_entries, ids[i])
		m.removedtransaction_entries[ids[i]] = struct{}{}
	}
}

// RemovedTransactionEntries returns the removed IDs of the "transaction_entries" edge to the TransactionEntry entity.
func (m *AccountMutation) RemovedTransactionEntriesIDs() (ids []int) {
	for id := range m.removedtransaction_entries {
		ids = append(ids, id)
	}
	return
}

// TransactionEntriesIDs returns the "transaction_entries" edge IDs in the mutation.
func (m *AccountMutation) TransactionEntriesIDs() (ids []int) {
	for id := range m.transaction_entries {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionEntries resets all changes to the "transaction_entries" edge.
func (m *AccountMutation) ResetTransactionEntries() {
	m.transaction_entries = nil
	m.clearedtransaction_entries = false
	m.removedtransaction_entries = nil
}

// AddInvestmentIDs adds the "investments" edge to the Investment entity by ids.
func (m *AccountMutation) AddInvestmentIDs(ids ...int) {
	if m.investments == nil {
		m.investments = make(map[int]struct{})
	}
	for i := range ids {
		m.investments[ids[i]] = struct{}{}
	}
}

// ClearInvestments clears the "investments" edge to the Investment entity.
func (m *AccountMutation) ClearInvestments() {
	m.clearedinvestments = true
}

// InvestmentsCleared reports if the "investments" edge to the Investment entity was cleared.
func (m *AccountMutation) InvestmentsCleared() bool {
	return m.clearedinvestments
}

// RemoveInvestmentIDs removes the "investments" edge to the Investment entity by IDs.
func (m *AccountMutation) RemoveInvestmentIDs(ids ...int) {
	if m.removedinvestments == nil {
		m.removedinvestments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.investments, ids[i])
		m.removedinvestments[ids[i]] = struct{}{}
	}
}

// RemovedInvestments returns the removed IDs of the "investments" edge to the Investment entity.
func (m *AccountMutation) RemovedInvestmentsIDs() (ids []int) {
	for id := range m.removedinvestments {
		ids = append(ids, id)
	}
	return
}

// InvestmentsIDs returns the "investments" edge IDs in the mutation.
func (m *AccountMutation) InvestmentsIDs() (ids []int) {
	for id := range m.investments {
		ids = append(ids, id)
	}
	return
}

// ResetInvestments resets all changes to the "investments" edge.
func (m *AccountMutation) ResetInvestments() {
	m.investments = nil
	m.clearedinvestments = false
	m.removedinvestments = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, account.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, account.FieldUpdateTime)
	}
	if m.household != nil {
		fields = append(fields, account.FieldHouseholdID)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m._type != nil {
		fields = append(fields, account.FieldType)
	}
	if m.balance != nil {
		fields = append(fields, account.FieldBalance)
	}
	if m.icon != nil {
		fields = append(fields, account.FieldIcon)
	}
	if m.value != nil {
		fields = append(fields, account.FieldValue)
	}
	if m.fx_rate != nil {
		fields = append(fields, account.FieldFxRate)
	}
	if m.currency != nil {
		fields = append(fields, account.FieldCurrencyID)
	}
	if m.user != nil {
		fields = append(fields, account.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreateTime:
		return m.CreateTime()
	case account.FieldUpdateTime:
		return m.UpdateTime()
	case account.FieldHouseholdID:
		return m.HouseholdID()
	case account.FieldName:
		return m.Name()
	case account.FieldType:
		return m.GetType()
	case account.FieldBalance:
		return m.Balance()
	case account.FieldIcon:
		return m.Icon()
	case account.FieldValue:
		return m.Value()
	case account.FieldFxRate:
		return m.FxRate()
	case account.FieldCurrencyID:
		return m.CurrencyID()
	case account.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case account.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case account.FieldHouseholdID:
		return m.OldHouseholdID(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldType:
		return m.OldType(ctx)
	case account.FieldBalance:
		return m.OldBalance(ctx)
	case account.FieldIcon:
		return m.OldIcon(ctx)
	case account.FieldValue:
		return m.OldValue(ctx)
	case account.FieldFxRate:
		return m.OldFxRate(ctx)
	case account.FieldCurrencyID:
		return m.OldCurrencyID(ctx)
	case account.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case account.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case account.FieldHouseholdID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHouseholdID(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldType:
		v, ok := value.(account.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case account.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case account.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case account.FieldFxRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFxRate(v)
		return nil
	case account.FieldCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyID(v)
		return nil
	case account.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, account.FieldBalance)
	}
	if m.addvalue != nil {
		fields = append(fields, account.FieldValue)
	}
	if m.addfx_rate != nil {
		fields = append(fields, account.FieldFxRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldBalance:
		return m.AddedBalance()
	case account.FieldValue:
		return m.AddedValue()
	case account.FieldFxRate:
		return m.AddedFxRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case account.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case account.FieldFxRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFxRate(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldIcon) {
		fields = append(fields, account.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case account.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case account.FieldHouseholdID:
		m.ResetHouseholdID()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldType:
		m.ResetType()
		return nil
	case account.FieldBalance:
		m.ResetBalance()
		return nil
	case account.FieldIcon:
		m.ResetIcon()
		return nil
	case account.FieldValue:
		m.ResetValue()
		return nil
	case account.FieldFxRate:
		m.ResetFxRate()
		return nil
	case account.FieldCurrencyID:
		m.ResetCurrencyID()
		return nil
	case account.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.household != nil {
		edges = append(edges, account.EdgeHousehold)
	}
	if m.currency != nil {
		edges = append(edges, account.EdgeCurrency)
	}
	if m.user != nil {
		edges = append(edges, account.EdgeUser)
	}
	if m.transaction_entries != nil {
		edges = append(edges, account.EdgeTransactionEntries)
	}
	if m.investments != nil {
		edges = append(edges, account.EdgeInvestments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeHousehold:
		if id := m.household; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeCurrency:
		if id := m.currency; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.transaction_entries))
		for id := range m.transaction_entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInvestments:
		ids := make([]ent.Value, 0, len(m.investments))
		for id := range m.investments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtransaction_entries != nil {
		edges = append(edges, account.EdgeTransactionEntries)
	}
	if m.removedinvestments != nil {
		edges = append(edges, account.EdgeInvestments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.removedtransaction_entries))
		for id := range m.removedtransaction_entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInvestments:
		ids := make([]ent.Value, 0, len(m.removedinvestments))
		for id := range m.removedinvestments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedhousehold {
		edges = append(edges, account.EdgeHousehold)
	}
	if m.clearedcurrency {
		edges = append(edges, account.EdgeCurrency)
	}
	if m.cleareduser {
		edges = append(edges, account.EdgeUser)
	}
	if m.clearedtransaction_entries {
		edges = append(edges, account.EdgeTransactionEntries)
	}
	if m.clearedinvestments {
		edges = append(edges, account.EdgeInvestments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeHousehold:
		return m.clearedhousehold
	case account.EdgeCurrency:
		return m.clearedcurrency
	case account.EdgeUser:
		return m.cleareduser
	case account.EdgeTransactionEntries:
		return m.clearedtransaction_entries
	case account.EdgeInvestments:
		return m.clearedinvestments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeHousehold:
		m.ClearHousehold()
		return nil
	case account.EdgeCurrency:
		m.ClearCurrency()
		return nil
	case account.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeHousehold:
		m.ResetHousehold()
		return nil
	case account.EdgeCurrency:
		m.ResetCurrency()
		return nil
	case account.EdgeUser:
		m.ResetUser()
		return nil
	case account.EdgeTransactionEntries:
		m.ResetTransactionEntries()
		return nil
	case account.EdgeInvestments:
		m.ResetInvestments()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// CryptoQuoteCacheMutation represents an operation that mutates the CryptoQuoteCache nodes in the graph.
type CryptoQuoteCacheMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	symbol        *string
	value         *decimal.Decimal
	addvalue      *decimal.Decimal
	date          *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CryptoQuoteCache, error)
	predicates    []predicate.CryptoQuoteCache
}

var _ ent.Mutation = (*CryptoQuoteCacheMutation)(nil)

// cryptoquotecacheOption allows management of the mutation configuration using functional options.
type cryptoquotecacheOption func(*CryptoQuoteCacheMutation)

// newCryptoQuoteCacheMutation creates new mutation for the CryptoQuoteCache entity.
func newCryptoQuoteCacheMutation(c config, op Op, opts ...cryptoquotecacheOption) *CryptoQuoteCacheMutation {
	m := &CryptoQuoteCacheMutation{
		config:        c,
		op:            op,
		typ:           TypeCryptoQuoteCache,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCryptoQuoteCacheID sets the ID field of the mutation.
func withCryptoQuoteCacheID(id int) cryptoquotecacheOption {
	return func(m *CryptoQuoteCacheMutation) {
		var (
			err   error
			once  sync.Once
			value *CryptoQuoteCache
		)
		m.oldValue = func(ctx context.Context) (*CryptoQuoteCache, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CryptoQuoteCache.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCryptoQuoteCache sets the old CryptoQuoteCache of the mutation.
func withCryptoQuoteCache(node *CryptoQuoteCache) cryptoquotecacheOption {
	return func(m *CryptoQuoteCacheMutation) {
		m.oldValue = func(context.Context) (*CryptoQuoteCache, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CryptoQuoteCacheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CryptoQuoteCacheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CryptoQuoteCacheMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CryptoQuoteCacheMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CryptoQuoteCache.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CryptoQuoteCacheMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CryptoQuoteCacheMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CryptoQuoteCache entity.
// If the CryptoQuoteCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoQuoteCacheMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CryptoQuoteCacheMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CryptoQuoteCacheMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CryptoQuoteCacheMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CryptoQuoteCache entity.
// If the CryptoQuoteCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoQuoteCacheMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CryptoQuoteCacheMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSymbol sets the "symbol" field.
func (m *CryptoQuoteCacheMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *CryptoQuoteCacheMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the CryptoQuoteCache entity.
// If the CryptoQuoteCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoQuoteCacheMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *CryptoQuoteCacheMutation) ResetSymbol() {
	m.symbol = nil
}

// SetValue sets the "value" field.
func (m *CryptoQuoteCacheMutation) SetValue(d decimal.Decimal) {
	m.value = &d
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *CryptoQuoteCacheMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the CryptoQuoteCache entity.
// If the CryptoQuoteCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoQuoteCacheMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds d to the "value" field.
func (m *CryptoQuoteCacheMutation) AddValue(d decimal.Decimal) {
	if m.addvalue != nil {
		*m.addvalue = m.addvalue.Add(d)
	} else {
		m.addvalue = &d
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *CryptoQuoteCacheMutation) AddedValue() (r decimal.Decimal, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *CryptoQuoteCacheMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetDate sets the "date" field.
func (m *CryptoQuoteCacheMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *CryptoQuoteCacheMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the CryptoQuoteCache entity.
// If the CryptoQuoteCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoQuoteCacheMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *CryptoQuoteCacheMutation) ResetDate() {
	m.date = nil
}

// Where appends a list predicates to the CryptoQuoteCacheMutation builder.
func (m *CryptoQuoteCacheMutation) Where(ps ...predicate.CryptoQuoteCache) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CryptoQuoteCacheMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CryptoQuoteCacheMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CryptoQuoteCache, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CryptoQuoteCacheMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CryptoQuoteCacheMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CryptoQuoteCache).
func (m *CryptoQuoteCacheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CryptoQuoteCacheMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, cryptoquotecache.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, cryptoquotecache.FieldUpdateTime)
	}
	if m.symbol != nil {
		fields = append(fields, cryptoquotecache.FieldSymbol)
	}
	if m.value != nil {
		fields = append(fields, cryptoquotecache.FieldValue)
	}
	if m.date != nil {
		fields = append(fields, cryptoquotecache.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CryptoQuoteCacheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cryptoquotecache.FieldCreateTime:
		return m.CreateTime()
	case cryptoquotecache.FieldUpdateTime:
		return m.UpdateTime()
	case cryptoquotecache.FieldSymbol:
		return m.Symbol()
	case cryptoquotecache.FieldValue:
		return m.Value()
	case cryptoquotecache.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CryptoQuoteCacheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cryptoquotecache.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case cryptoquotecache.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case cryptoquotecache.FieldSymbol:
		return m.OldSymbol(ctx)
	case cryptoquotecache.FieldValue:
		return m.OldValue(ctx)
	case cryptoquotecache.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown CryptoQuoteCache field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CryptoQuoteCacheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cryptoquotecache.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case cryptoquotecache.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case cryptoquotecache.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case cryptoquotecache.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case cryptoquotecache.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown CryptoQuoteCache field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CryptoQuoteCacheMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, cryptoquotecache.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CryptoQuoteCacheMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cryptoquotecache.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CryptoQuoteCacheMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cryptoquotecache.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown CryptoQuoteCache numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CryptoQuoteCacheMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CryptoQuoteCacheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CryptoQuoteCacheMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CryptoQuoteCache nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CryptoQuoteCacheMutation) ResetField(name string) error {
	switch name {
	case cryptoquotecache.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case cryptoquotecache.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case cryptoquotecache.FieldSymbol:
		m.ResetSymbol()
		return nil
	case cryptoquotecache.FieldValue:
		m.ResetValue()
		return nil
	case cryptoquotecache.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown CryptoQuoteCache field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CryptoQuoteCacheMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CryptoQuoteCacheMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CryptoQuoteCacheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CryptoQuoteCacheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CryptoQuoteCacheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CryptoQuoteCacheMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CryptoQuoteCacheMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CryptoQuoteCache unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CryptoQuoteCacheMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CryptoQuoteCache edge %s", name)
}

// CurrencyMutation represents an operation that mutates the Currency nodes in the graph.
type CurrencyMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	code                       *string
	clearedFields              map[string]struct{}
	accounts                   map[int]struct{}
	removedaccounts            map[int]struct{}
	clearedaccounts            bool
	investments                map[int]struct{}
	removedinvestments         map[int]struct{}
	clearedinvestments         bool
	transaction_entries        map[int]struct{}
	removedtransaction_entries map[int]struct{}
	clearedtransaction_entries bool
	households                 map[int]struct{}
	removedhouseholds          map[int]struct{}
	clearedhouseholds          bool
	fx_rate_caches_from        map[int]struct{}
	removedfx_rate_caches_from map[int]struct{}
	clearedfx_rate_caches_from bool
	fx_rate_caches_to          map[int]struct{}
	removedfx_rate_caches_to   map[int]struct{}
	clearedfx_rate_caches_to   bool
	done                       bool
	oldValue                   func(context.Context) (*Currency, error)
	predicates                 []predicate.Currency
}

var _ ent.Mutation = (*CurrencyMutation)(nil)

// currencyOption allows management of the mutation configuration using functional options.
type currencyOption func(*CurrencyMutation)

// newCurrencyMutation creates new mutation for the Currency entity.
func newCurrencyMutation(c config, op Op, opts ...currencyOption) *CurrencyMutation {
	m := &CurrencyMutation{
		config:        c,
		op:            op,
		typ:           TypeCurrency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCurrencyID sets the ID field of the mutation.
func withCurrencyID(id int) currencyOption {
	return func(m *CurrencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Currency
		)
		m.oldValue = func(ctx context.Context) (*Currency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Currency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCurrency sets the old Currency of the mutation.
func withCurrency(node *Currency) currencyOption {
	return func(m *CurrencyMutation) {
		m.oldValue = func(context.Context) (*Currency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CurrencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CurrencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CurrencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CurrencyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Currency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *CurrencyMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CurrencyMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Currency entity.
// If the Currency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CurrencyMutation) ResetCode() {
	m.code = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *CurrencyMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *CurrencyMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *CurrencyMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *CurrencyMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *CurrencyMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *CurrencyMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *CurrencyMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddInvestmentIDs adds the "investments" edge to the Investment entity by ids.
func (m *CurrencyMutation) AddInvestmentIDs(ids ...int) {
	if m.investments == nil {
		m.investments = make(map[int]struct{})
	}
	for i := range ids {
		m.investments[ids[i]] = struct{}{}
	}
}

// ClearInvestments clears the "investments" edge to the Investment entity.
func (m *CurrencyMutation) ClearInvestments() {
	m.clearedinvestments = true
}

// InvestmentsCleared reports if the "investments" edge to the Investment entity was cleared.
func (m *CurrencyMutation) InvestmentsCleared() bool {
	return m.clearedinvestments
}

// RemoveInvestmentIDs removes the "investments" edge to the Investment entity by IDs.
func (m *CurrencyMutation) RemoveInvestmentIDs(ids ...int) {
	if m.removedinvestments == nil {
		m.removedinvestments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.investments, ids[i])
		m.removedinvestments[ids[i]] = struct{}{}
	}
}

// RemovedInvestments returns the removed IDs of the "investments" edge to the Investment entity.
func (m *CurrencyMutation) RemovedInvestmentsIDs() (ids []int) {
	for id := range m.removedinvestments {
		ids = append(ids, id)
	}
	return
}

// InvestmentsIDs returns the "investments" edge IDs in the mutation.
func (m *CurrencyMutation) InvestmentsIDs() (ids []int) {
	for id := range m.investments {
		ids = append(ids, id)
	}
	return
}

// ResetInvestments resets all changes to the "investments" edge.
func (m *CurrencyMutation) ResetInvestments() {
	m.investments = nil
	m.clearedinvestments = false
	m.removedinvestments = nil
}

// AddTransactionEntryIDs adds the "transaction_entries" edge to the TransactionEntry entity by ids.
func (m *CurrencyMutation) AddTransactionEntryIDs(ids ...int) {
	if m.transaction_entries == nil {
		m.transaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_entries[ids[i]] = struct{}{}
	}
}

// ClearTransactionEntries clears the "transaction_entries" edge to the TransactionEntry entity.
func (m *CurrencyMutation) ClearTransactionEntries() {
	m.clearedtransaction_entries = true
}

// TransactionEntriesCleared reports if the "transaction_entries" edge to the TransactionEntry entity was cleared.
func (m *CurrencyMutation) TransactionEntriesCleared() bool {
	return m.clearedtransaction_entries
}

// RemoveTransactionEntryIDs removes the "transaction_entries" edge to the TransactionEntry entity by IDs.
func (m *CurrencyMutation) RemoveTransactionEntryIDs(ids ...int) {
	if m.removedtransaction_entries == nil {
		m.removedtransaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_entries, ids[i])
		m.removedtransaction_entries[ids[i]] = struct{}{}
	}
}

// RemovedTransactionEntries returns the removed IDs of the "transaction_entries" edge to the TransactionEntry entity.
func (m *CurrencyMutation) RemovedTransactionEntriesIDs() (ids []int) {
	for id := range m.removedtransaction_entries {
		ids = append(ids, id)
	}
	return
}

// TransactionEntriesIDs returns the "transaction_entries" edge IDs in the mutation.
func (m *CurrencyMutation) TransactionEntriesIDs() (ids []int) {
	for id := range m.transaction_entries {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionEntries resets all changes to the "transaction_entries" edge.
func (m *CurrencyMutation) ResetTransactionEntries() {
	m.transaction_entries = nil
	m.clearedtransaction_entries = false
	m.removedtransaction_entries = nil
}

// AddHouseholdIDs adds the "households" edge to the Household entity by ids.
func (m *CurrencyMutation) AddHouseholdIDs(ids ...int) {
	if m.households == nil {
		m.households = make(map[int]struct{})
	}
	for i := range ids {
		m.households[ids[i]] = struct{}{}
	}
}

// ClearHouseholds clears the "households" edge to the Household entity.
func (m *CurrencyMutation) ClearHouseholds() {
	m.clearedhouseholds = true
}

// HouseholdsCleared reports if the "households" edge to the Household entity was cleared.
func (m *CurrencyMutation) HouseholdsCleared() bool {
	return m.clearedhouseholds
}

// RemoveHouseholdIDs removes the "households" edge to the Household entity by IDs.
func (m *CurrencyMutation) RemoveHouseholdIDs(ids ...int) {
	if m.removedhouseholds == nil {
		m.removedhouseholds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.households, ids[i])
		m.removedhouseholds[ids[i]] = struct{}{}
	}
}

// RemovedHouseholds returns the removed IDs of the "households" edge to the Household entity.
func (m *CurrencyMutation) RemovedHouseholdsIDs() (ids []int) {
	for id := range m.removedhouseholds {
		ids = append(ids, id)
	}
	return
}

// HouseholdsIDs returns the "households" edge IDs in the mutation.
func (m *CurrencyMutation) HouseholdsIDs() (ids []int) {
	for id := range m.households {
		ids = append(ids, id)
	}
	return
}

// ResetHouseholds resets all changes to the "households" edge.
func (m *CurrencyMutation) ResetHouseholds() {
	m.households = nil
	m.clearedhouseholds = false
	m.removedhouseholds = nil
}

// AddFxRateCachesFromIDs adds the "fx_rate_caches_from" edge to the FXRateCache entity by ids.
func (m *CurrencyMutation) AddFxRateCachesFromIDs(ids ...int) {
	if m.fx_rate_caches_from == nil {
		m.fx_rate_caches_from = make(map[int]struct{})
	}
	for i := range ids {
		m.fx_rate_caches_from[ids[i]] = struct{}{}
	}
}

// ClearFxRateCachesFrom clears the "fx_rate_caches_from" edge to the FXRateCache entity.
func (m *CurrencyMutation) ClearFxRateCachesFrom() {
	m.clearedfx_rate_caches_from = true
}

// FxRateCachesFromCleared reports if the "fx_rate_caches_from" edge to the FXRateCache entity was cleared.
func (m *CurrencyMutation) FxRateCachesFromCleared() bool {
	return m.clearedfx_rate_caches_from
}

// RemoveFxRateCachesFromIDs removes the "fx_rate_caches_from" edge to the FXRateCache entity by IDs.
func (m *CurrencyMutation) RemoveFxRateCachesFromIDs(ids ...int) {
	if m.removedfx_rate_caches_from == nil {
		m.removedfx_rate_caches_from = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fx_rate_caches_from, ids[i])
		m.removedfx_rate_caches_from[ids[i]] = struct{}{}
	}
}

// RemovedFxRateCachesFrom returns the removed IDs of the "fx_rate_caches_from" edge to the FXRateCache entity.
func (m *CurrencyMutation) RemovedFxRateCachesFromIDs() (ids []int) {
	for id := range m.removedfx_rate_caches_from {
		ids = append(ids, id)
	}
	return
}

// FxRateCachesFromIDs returns the "fx_rate_caches_from" edge IDs in the mutation.
func (m *CurrencyMutation) FxRateCachesFromIDs() (ids []int) {
	for id := range m.fx_rate_caches_from {
		ids = append(ids, id)
	}
	return
}

// ResetFxRateCachesFrom resets all changes to the "fx_rate_caches_from" edge.
func (m *CurrencyMutation) ResetFxRateCachesFrom() {
	m.fx_rate_caches_from = nil
	m.clearedfx_rate_caches_from = false
	m.removedfx_rate_caches_from = nil
}

// AddFxRateCachesToIDs adds the "fx_rate_caches_to" edge to the FXRateCache entity by ids.
func (m *CurrencyMutation) AddFxRateCachesToIDs(ids ...int) {
	if m.fx_rate_caches_to == nil {
		m.fx_rate_caches_to = make(map[int]struct{})
	}
	for i := range ids {
		m.fx_rate_caches_to[ids[i]] = struct{}{}
	}
}

// ClearFxRateCachesTo clears the "fx_rate_caches_to" edge to the FXRateCache entity.
func (m *CurrencyMutation) ClearFxRateCachesTo() {
	m.clearedfx_rate_caches_to = true
}

// FxRateCachesToCleared reports if the "fx_rate_caches_to" edge to the FXRateCache entity was cleared.
func (m *CurrencyMutation) FxRateCachesToCleared() bool {
	return m.clearedfx_rate_caches_to
}

// RemoveFxRateCachesToIDs removes the "fx_rate_caches_to" edge to the FXRateCache entity by IDs.
func (m *CurrencyMutation) RemoveFxRateCachesToIDs(ids ...int) {
	if m.removedfx_rate_caches_to == nil {
		m.removedfx_rate_caches_to = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fx_rate_caches_to, ids[i])
		m.removedfx_rate_caches_to[ids[i]] = struct{}{}
	}
}

// RemovedFxRateCachesTo returns the removed IDs of the "fx_rate_caches_to" edge to the FXRateCache entity.
func (m *CurrencyMutation) RemovedFxRateCachesToIDs() (ids []int) {
	for id := range m.removedfx_rate_caches_to {
		ids = append(ids, id)
	}
	return
}

// FxRateCachesToIDs returns the "fx_rate_caches_to" edge IDs in the mutation.
func (m *CurrencyMutation) FxRateCachesToIDs() (ids []int) {
	for id := range m.fx_rate_caches_to {
		ids = append(ids, id)
	}
	return
}

// ResetFxRateCachesTo resets all changes to the "fx_rate_caches_to" edge.
func (m *CurrencyMutation) ResetFxRateCachesTo() {
	m.fx_rate_caches_to = nil
	m.clearedfx_rate_caches_to = false
	m.removedfx_rate_caches_to = nil
}

// Where appends a list predicates to the CurrencyMutation builder.
func (m *CurrencyMutation) Where(ps ...predicate.Currency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CurrencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CurrencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Currency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CurrencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CurrencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Currency).
func (m *CurrencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CurrencyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.code != nil {
		fields = append(fields, currency.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CurrencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case currency.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CurrencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case currency.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Currency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case currency.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Currency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CurrencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CurrencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Currency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CurrencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CurrencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CurrencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Currency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CurrencyMutation) ResetField(name string) error {
	switch name {
	case currency.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Currency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CurrencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.accounts != nil {
		edges = append(edges, currency.EdgeAccounts)
	}
	if m.investments != nil {
		edges = append(edges, currency.EdgeInvestments)
	}
	if m.transaction_entries != nil {
		edges = append(edges, currency.EdgeTransactionEntries)
	}
	if m.households != nil {
		edges = append(edges, currency.EdgeHouseholds)
	}
	if m.fx_rate_caches_from != nil {
		edges = append(edges, currency.EdgeFxRateCachesFrom)
	}
	if m.fx_rate_caches_to != nil {
		edges = append(edges, currency.EdgeFxRateCachesTo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CurrencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case currency.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeInvestments:
		ids := make([]ent.Value, 0, len(m.investments))
		for id := range m.investments {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.transaction_entries))
		for id := range m.transaction_entries {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeHouseholds:
		ids := make([]ent.Value, 0, len(m.households))
		for id := range m.households {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeFxRateCachesFrom:
		ids := make([]ent.Value, 0, len(m.fx_rate_caches_from))
		for id := range m.fx_rate_caches_from {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeFxRateCachesTo:
		ids := make([]ent.Value, 0, len(m.fx_rate_caches_to))
		for id := range m.fx_rate_caches_to {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CurrencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedaccounts != nil {
		edges = append(edges, currency.EdgeAccounts)
	}
	if m.removedinvestments != nil {
		edges = append(edges, currency.EdgeInvestments)
	}
	if m.removedtransaction_entries != nil {
		edges = append(edges, currency.EdgeTransactionEntries)
	}
	if m.removedhouseholds != nil {
		edges = append(edges, currency.EdgeHouseholds)
	}
	if m.removedfx_rate_caches_from != nil {
		edges = append(edges, currency.EdgeFxRateCachesFrom)
	}
	if m.removedfx_rate_caches_to != nil {
		edges = append(edges, currency.EdgeFxRateCachesTo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CurrencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case currency.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeInvestments:
		ids := make([]ent.Value, 0, len(m.removedinvestments))
		for id := range m.removedinvestments {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.removedtransaction_entries))
		for id := range m.removedtransaction_entries {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeHouseholds:
		ids := make([]ent.Value, 0, len(m.removedhouseholds))
		for id := range m.removedhouseholds {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeFxRateCachesFrom:
		ids := make([]ent.Value, 0, len(m.removedfx_rate_caches_from))
		for id := range m.removedfx_rate_caches_from {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeFxRateCachesTo:
		ids := make([]ent.Value, 0, len(m.removedfx_rate_caches_to))
		for id := range m.removedfx_rate_caches_to {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CurrencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedaccounts {
		edges = append(edges, currency.EdgeAccounts)
	}
	if m.clearedinvestments {
		edges = append(edges, currency.EdgeInvestments)
	}
	if m.clearedtransaction_entries {
		edges = append(edges, currency.EdgeTransactionEntries)
	}
	if m.clearedhouseholds {
		edges = append(edges, currency.EdgeHouseholds)
	}
	if m.clearedfx_rate_caches_from {
		edges = append(edges, currency.EdgeFxRateCachesFrom)
	}
	if m.clearedfx_rate_caches_to {
		edges = append(edges, currency.EdgeFxRateCachesTo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CurrencyMutation) EdgeCleared(name string) bool {
	switch name {
	case currency.EdgeAccounts:
		return m.clearedaccounts
	case currency.EdgeInvestments:
		return m.clearedinvestments
	case currency.EdgeTransactionEntries:
		return m.clearedtransaction_entries
	case currency.EdgeHouseholds:
		return m.clearedhouseholds
	case currency.EdgeFxRateCachesFrom:
		return m.clearedfx_rate_caches_from
	case currency.EdgeFxRateCachesTo:
		return m.clearedfx_rate_caches_to
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CurrencyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Currency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CurrencyMutation) ResetEdge(name string) error {
	switch name {
	case currency.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case currency.EdgeInvestments:
		m.ResetInvestments()
		return nil
	case currency.EdgeTransactionEntries:
		m.ResetTransactionEntries()
		return nil
	case currency.EdgeHouseholds:
		m.ResetHouseholds()
		return nil
	case currency.EdgeFxRateCachesFrom:
		m.ResetFxRateCachesFrom()
		return nil
	case currency.EdgeFxRateCachesTo:
		m.ResetFxRateCachesTo()
		return nil
	}
	return fmt.Errorf("unknown Currency edge %s", name)
}

// FXRateCacheMutation represents an operation that mutates the FXRateCache nodes in the graph.
type FXRateCacheMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	value                *decimal.Decimal
	addvalue             *decimal.Decimal
	date                 *time.Time
	clearedFields        map[string]struct{}
	from_currency        *int
	clearedfrom_currency bool
	to_currency          *int
	clearedto_currency   bool
	done                 bool
	oldValue             func(context.Context) (*FXRateCache, error)
	predicates           []predicate.FXRateCache
}

var _ ent.Mutation = (*FXRateCacheMutation)(nil)

// fxratecacheOption allows management of the mutation configuration using functional options.
type fxratecacheOption func(*FXRateCacheMutation)

// newFXRateCacheMutation creates new mutation for the FXRateCache entity.
func newFXRateCacheMutation(c config, op Op, opts ...fxratecacheOption) *FXRateCacheMutation {
	m := &FXRateCacheMutation{
		config:        c,
		op:            op,
		typ:           TypeFXRateCache,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFXRateCacheID sets the ID field of the mutation.
func withFXRateCacheID(id int) fxratecacheOption {
	return func(m *FXRateCacheMutation) {
		var (
			err   error
			once  sync.Once
			value *FXRateCache
		)
		m.oldValue = func(ctx context.Context) (*FXRateCache, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FXRateCache.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFXRateCache sets the old FXRateCache of the mutation.
func withFXRateCache(node *FXRateCache) fxratecacheOption {
	return func(m *FXRateCacheMutation) {
		m.oldValue = func(context.Context) (*FXRateCache, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FXRateCacheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FXRateCacheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FXRateCacheMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FXRateCacheMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FXRateCache.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *FXRateCacheMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FXRateCacheMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the FXRateCache entity.
// If the FXRateCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FXRateCacheMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FXRateCacheMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FXRateCacheMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FXRateCacheMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the FXRateCache entity.
// If the FXRateCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FXRateCacheMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FXRateCacheMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetFromCurrencyID sets the "from_currency_id" field.
func (m *FXRateCacheMutation) SetFromCurrencyID(i int) {
	m.from_currency = &i
}

// FromCurrencyID returns the value of the "from_currency_id" field in the mutation.
func (m *FXRateCacheMutation) FromCurrencyID() (r int, exists bool) {
	v := m.from_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldFromCurrencyID returns the old "from_currency_id" field's value of the FXRateCache entity.
// If the FXRateCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FXRateCacheMutation) OldFromCurrencyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromCurrencyID: %w", err)
	}
	return oldValue.FromCurrencyID, nil
}

// ResetFromCurrencyID resets all changes to the "from_currency_id" field.
func (m *FXRateCacheMutation) ResetFromCurrencyID() {
	m.from_currency = nil
}

// SetToCurrencyID sets the "to_currency_id" field.
func (m *FXRateCacheMutation) SetToCurrencyID(i int) {
	m.to_currency = &i
}

// ToCurrencyID returns the value of the "to_currency_id" field in the mutation.
func (m *FXRateCacheMutation) ToCurrencyID() (r int, exists bool) {
	v := m.to_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldToCurrencyID returns the old "to_currency_id" field's value of the FXRateCache entity.
// If the FXRateCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FXRateCacheMutation) OldToCurrencyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToCurrencyID: %w", err)
	}
	return oldValue.ToCurrencyID, nil
}

// ResetToCurrencyID resets all changes to the "to_currency_id" field.
func (m *FXRateCacheMutation) ResetToCurrencyID() {
	m.to_currency = nil
}

// SetValue sets the "value" field.
func (m *FXRateCacheMutation) SetValue(d decimal.Decimal) {
	m.value = &d
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *FXRateCacheMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the FXRateCache entity.
// If the FXRateCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FXRateCacheMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds d to the "value" field.
func (m *FXRateCacheMutation) AddValue(d decimal.Decimal) {
	if m.addvalue != nil {
		*m.addvalue = m.addvalue.Add(d)
	} else {
		m.addvalue = &d
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *FXRateCacheMutation) AddedValue() (r decimal.Decimal, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *FXRateCacheMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetDate sets the "date" field.
func (m *FXRateCacheMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *FXRateCacheMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the FXRateCache entity.
// If the FXRateCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FXRateCacheMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *FXRateCacheMutation) ResetDate() {
	m.date = nil
}

// ClearFromCurrency clears the "from_currency" edge to the Currency entity.
func (m *FXRateCacheMutation) ClearFromCurrency() {
	m.clearedfrom_currency = true
	m.clearedFields[fxratecache.FieldFromCurrencyID] = struct{}{}
}

// FromCurrencyCleared reports if the "from_currency" edge to the Currency entity was cleared.
func (m *FXRateCacheMutation) FromCurrencyCleared() bool {
	return m.clearedfrom_currency
}

// FromCurrencyIDs returns the "from_currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromCurrencyID instead. It exists only for internal usage by the builders.
func (m *FXRateCacheMutation) FromCurrencyIDs() (ids []int) {
	if id := m.from_currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromCurrency resets all changes to the "from_currency" edge.
func (m *FXRateCacheMutation) ResetFromCurrency() {
	m.from_currency = nil
	m.clearedfrom_currency = false
}

// ClearToCurrency clears the "to_currency" edge to the Currency entity.
func (m *FXRateCacheMutation) ClearToCurrency() {
	m.clearedto_currency = true
	m.clearedFields[fxratecache.FieldToCurrencyID] = struct{}{}
}

// ToCurrencyCleared reports if the "to_currency" edge to the Currency entity was cleared.
func (m *FXRateCacheMutation) ToCurrencyCleared() bool {
	return m.clearedto_currency
}

// ToCurrencyIDs returns the "to_currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToCurrencyID instead. It exists only for internal usage by the builders.
func (m *FXRateCacheMutation) ToCurrencyIDs() (ids []int) {
	if id := m.to_currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToCurrency resets all changes to the "to_currency" edge.
func (m *FXRateCacheMutation) ResetToCurrency() {
	m.to_currency = nil
	m.clearedto_currency = false
}

// Where appends a list predicates to the FXRateCacheMutation builder.
func (m *FXRateCacheMutation) Where(ps ...predicate.FXRateCache) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FXRateCacheMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FXRateCacheMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FXRateCache, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FXRateCacheMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FXRateCacheMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FXRateCache).
func (m *FXRateCacheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FXRateCacheMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, fxratecache.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, fxratecache.FieldUpdateTime)
	}
	if m.from_currency != nil {
		fields = append(fields, fxratecache.FieldFromCurrencyID)
	}
	if m.to_currency != nil {
		fields = append(fields, fxratecache.FieldToCurrencyID)
	}
	if m.value != nil {
		fields = append(fields, fxratecache.FieldValue)
	}
	if m.date != nil {
		fields = append(fields, fxratecache.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FXRateCacheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fxratecache.FieldCreateTime:
		return m.CreateTime()
	case fxratecache.FieldUpdateTime:
		return m.UpdateTime()
	case fxratecache.FieldFromCurrencyID:
		return m.FromCurrencyID()
	case fxratecache.FieldToCurrencyID:
		return m.ToCurrencyID()
	case fxratecache.FieldValue:
		return m.Value()
	case fxratecache.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FXRateCacheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fxratecache.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case fxratecache.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case fxratecache.FieldFromCurrencyID:
		return m.OldFromCurrencyID(ctx)
	case fxratecache.FieldToCurrencyID:
		return m.OldToCurrencyID(ctx)
	case fxratecache.FieldValue:
		return m.OldValue(ctx)
	case fxratecache.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown FXRateCache field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FXRateCacheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fxratecache.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case fxratecache.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case fxratecache.FieldFromCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromCurrencyID(v)
		return nil
	case fxratecache.FieldToCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToCurrencyID(v)
		return nil
	case fxratecache.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case fxratecache.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown FXRateCache field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FXRateCacheMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, fxratecache.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FXRateCacheMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fxratecache.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FXRateCacheMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fxratecache.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown FXRateCache numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FXRateCacheMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FXRateCacheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FXRateCacheMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FXRateCache nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FXRateCacheMutation) ResetField(name string) error {
	switch name {
	case fxratecache.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case fxratecache.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case fxratecache.FieldFromCurrencyID:
		m.ResetFromCurrencyID()
		return nil
	case fxratecache.FieldToCurrencyID:
		m.ResetToCurrencyID()
		return nil
	case fxratecache.FieldValue:
		m.ResetValue()
		return nil
	case fxratecache.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown FXRateCache field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FXRateCacheMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from_currency != nil {
		edges = append(edges, fxratecache.EdgeFromCurrency)
	}
	if m.to_currency != nil {
		edges = append(edges, fxratecache.EdgeToCurrency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FXRateCacheMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fxratecache.EdgeFromCurrency:
		if id := m.from_currency; id != nil {
			return []ent.Value{*id}
		}
	case fxratecache.EdgeToCurrency:
		if id := m.to_currency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FXRateCacheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FXRateCacheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FXRateCacheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom_currency {
		edges = append(edges, fxratecache.EdgeFromCurrency)
	}
	if m.clearedto_currency {
		edges = append(edges, fxratecache.EdgeToCurrency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FXRateCacheMutation) EdgeCleared(name string) bool {
	switch name {
	case fxratecache.EdgeFromCurrency:
		return m.clearedfrom_currency
	case fxratecache.EdgeToCurrency:
		return m.clearedto_currency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FXRateCacheMutation) ClearEdge(name string) error {
	switch name {
	case fxratecache.EdgeFromCurrency:
		m.ClearFromCurrency()
		return nil
	case fxratecache.EdgeToCurrency:
		m.ClearToCurrency()
		return nil
	}
	return fmt.Errorf("unknown FXRateCache unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FXRateCacheMutation) ResetEdge(name string) error {
	switch name {
	case fxratecache.EdgeFromCurrency:
		m.ResetFromCurrency()
		return nil
	case fxratecache.EdgeToCurrency:
		m.ResetToCurrency()
		return nil
	}
	return fmt.Errorf("unknown FXRateCache edge %s", name)
}

// HouseholdMutation represents an operation that mutates the Household nodes in the graph.
type HouseholdMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	name                          *string
	locale                        *string
	clearedFields                 map[string]struct{}
	currency                      *int
	clearedcurrency               bool
	users                         map[int]struct{}
	removedusers                  map[int]struct{}
	clearedusers                  bool
	accounts                      map[int]struct{}
	removedaccounts               map[int]struct{}
	clearedaccounts               bool
	transactions                  map[int]struct{}
	removedtransactions           map[int]struct{}
	clearedtransactions           bool
	investments                   map[int]struct{}
	removedinvestments            map[int]struct{}
	clearedinvestments            bool
	investment_lots               map[int]struct{}
	removedinvestment_lots        map[int]struct{}
	clearedinvestment_lots        bool
	transaction_categories        map[int]struct{}
	removedtransaction_categories map[int]struct{}
	clearedtransaction_categories bool
	transaction_entries           map[int]struct{}
	removedtransaction_entries    map[int]struct{}
	clearedtransaction_entries    bool
	user_households               map[int]struct{}
	removeduser_households        map[int]struct{}
	cleareduser_households        bool
	done                          bool
	oldValue                      func(context.Context) (*Household, error)
	predicates                    []predicate.Household
}

var _ ent.Mutation = (*HouseholdMutation)(nil)

// householdOption allows management of the mutation configuration using functional options.
type householdOption func(*HouseholdMutation)

// newHouseholdMutation creates new mutation for the Household entity.
func newHouseholdMutation(c config, op Op, opts ...householdOption) *HouseholdMutation {
	m := &HouseholdMutation{
		config:        c,
		op:            op,
		typ:           TypeHousehold,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHouseholdID sets the ID field of the mutation.
func withHouseholdID(id int) householdOption {
	return func(m *HouseholdMutation) {
		var (
			err   error
			once  sync.Once
			value *Household
		)
		m.oldValue = func(ctx context.Context) (*Household, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Household.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHousehold sets the old Household of the mutation.
func withHousehold(node *Household) householdOption {
	return func(m *HouseholdMutation) {
		m.oldValue = func(context.Context) (*Household, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HouseholdMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HouseholdMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HouseholdMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HouseholdMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Household.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *HouseholdMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *HouseholdMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Household entity.
// If the Household object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HouseholdMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *HouseholdMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *HouseholdMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *HouseholdMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Household entity.
// If the Household object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HouseholdMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *HouseholdMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *HouseholdMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HouseholdMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Household entity.
// If the Household object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HouseholdMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HouseholdMutation) ResetName() {
	m.name = nil
}

// SetLocale sets the "locale" field.
func (m *HouseholdMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *HouseholdMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the Household entity.
// If the Household object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HouseholdMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *HouseholdMutation) ResetLocale() {
	m.locale = nil
}

// SetCurrencyID sets the "currency_id" field.
func (m *HouseholdMutation) SetCurrencyID(i int) {
	m.currency = &i
}

// CurrencyID returns the value of the "currency_id" field in the mutation.
func (m *HouseholdMutation) CurrencyID() (r int, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyID returns the old "currency_id" field's value of the Household entity.
// If the Household object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HouseholdMutation) OldCurrencyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyID: %w", err)
	}
	return oldValue.CurrencyID, nil
}

// ResetCurrencyID resets all changes to the "currency_id" field.
func (m *HouseholdMutation) ResetCurrencyID() {
	m.currency = nil
}

// ClearCurrency clears the "currency" edge to the Currency entity.
func (m *HouseholdMutation) ClearCurrency() {
	m.clearedcurrency = true
	m.clearedFields[household.FieldCurrencyID] = struct{}{}
}

// CurrencyCleared reports if the "currency" edge to the Currency entity was cleared.
func (m *HouseholdMutation) CurrencyCleared() bool {
	return m.clearedcurrency
}

// CurrencyIDs returns the "currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyID instead. It exists only for internal usage by the builders.
func (m *HouseholdMutation) CurrencyIDs() (ids []int) {
	if id := m.currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrency resets all changes to the "currency" edge.
func (m *HouseholdMutation) ResetCurrency() {
	m.currency = nil
	m.clearedcurrency = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *HouseholdMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *HouseholdMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *HouseholdMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *HouseholdMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *HouseholdMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *HouseholdMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *HouseholdMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *HouseholdMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *HouseholdMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *HouseholdMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *HouseholdMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *HouseholdMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *HouseholdMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *HouseholdMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *HouseholdMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *HouseholdMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *HouseholdMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *HouseholdMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *HouseholdMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *HouseholdMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *HouseholdMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddInvestmentIDs adds the "investments" edge to the Investment entity by ids.
func (m *HouseholdMutation) AddInvestmentIDs(ids ...int) {
	if m.investments == nil {
		m.investments = make(map[int]struct{})
	}
	for i := range ids {
		m.investments[ids[i]] = struct{}{}
	}
}

// ClearInvestments clears the "investments" edge to the Investment entity.
func (m *HouseholdMutation) ClearInvestments() {
	m.clearedinvestments = true
}

// InvestmentsCleared reports if the "investments" edge to the Investment entity was cleared.
func (m *HouseholdMutation) InvestmentsCleared() bool {
	return m.clearedinvestments
}

// RemoveInvestmentIDs removes the "investments" edge to the Investment entity by IDs.
func (m *HouseholdMutation) RemoveInvestmentIDs(ids ...int) {
	if m.removedinvestments == nil {
		m.removedinvestments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.investments, ids[i])
		m.removedinvestments[ids[i]] = struct{}{}
	}
}

// RemovedInvestments returns the removed IDs of the "investments" edge to the Investment entity.
func (m *HouseholdMutation) RemovedInvestmentsIDs() (ids []int) {
	for id := range m.removedinvestments {
		ids = append(ids, id)
	}
	return
}

// InvestmentsIDs returns the "investments" edge IDs in the mutation.
func (m *HouseholdMutation) InvestmentsIDs() (ids []int) {
	for id := range m.investments {
		ids = append(ids, id)
	}
	return
}

// ResetInvestments resets all changes to the "investments" edge.
func (m *HouseholdMutation) ResetInvestments() {
	m.investments = nil
	m.clearedinvestments = false
	m.removedinvestments = nil
}

// AddInvestmentLotIDs adds the "investment_lots" edge to the InvestmentLot entity by ids.
func (m *HouseholdMutation) AddInvestmentLotIDs(ids ...int) {
	if m.investment_lots == nil {
		m.investment_lots = make(map[int]struct{})
	}
	for i := range ids {
		m.investment_lots[ids[i]] = struct{}{}
	}
}

// ClearInvestmentLots clears the "investment_lots" edge to the InvestmentLot entity.
func (m *HouseholdMutation) ClearInvestmentLots() {
	m.clearedinvestment_lots = true
}

// InvestmentLotsCleared reports if the "investment_lots" edge to the InvestmentLot entity was cleared.
func (m *HouseholdMutation) InvestmentLotsCleared() bool {
	return m.clearedinvestment_lots
}

// RemoveInvestmentLotIDs removes the "investment_lots" edge to the InvestmentLot entity by IDs.
func (m *HouseholdMutation) RemoveInvestmentLotIDs(ids ...int) {
	if m.removedinvestment_lots == nil {
		m.removedinvestment_lots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.investment_lots, ids[i])
		m.removedinvestment_lots[ids[i]] = struct{}{}
	}
}

// RemovedInvestmentLots returns the removed IDs of the "investment_lots" edge to the InvestmentLot entity.
func (m *HouseholdMutation) RemovedInvestmentLotsIDs() (ids []int) {
	for id := range m.removedinvestment_lots {
		ids = append(ids, id)
	}
	return
}

// InvestmentLotsIDs returns the "investment_lots" edge IDs in the mutation.
func (m *HouseholdMutation) InvestmentLotsIDs() (ids []int) {
	for id := range m.investment_lots {
		ids = append(ids, id)
	}
	return
}

// ResetInvestmentLots resets all changes to the "investment_lots" edge.
func (m *HouseholdMutation) ResetInvestmentLots() {
	m.investment_lots = nil
	m.clearedinvestment_lots = false
	m.removedinvestment_lots = nil
}

// AddTransactionCategoryIDs adds the "transaction_categories" edge to the TransactionCategory entity by ids.
func (m *HouseholdMutation) AddTransactionCategoryIDs(ids ...int) {
	if m.transaction_categories == nil {
		m.transaction_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_categories[ids[i]] = struct{}{}
	}
}

// ClearTransactionCategories clears the "transaction_categories" edge to the TransactionCategory entity.
func (m *HouseholdMutation) ClearTransactionCategories() {
	m.clearedtransaction_categories = true
}

// TransactionCategoriesCleared reports if the "transaction_categories" edge to the TransactionCategory entity was cleared.
func (m *HouseholdMutation) TransactionCategoriesCleared() bool {
	return m.clearedtransaction_categories
}

// RemoveTransactionCategoryIDs removes the "transaction_categories" edge to the TransactionCategory entity by IDs.
func (m *HouseholdMutation) RemoveTransactionCategoryIDs(ids ...int) {
	if m.removedtransaction_categories == nil {
		m.removedtransaction_categories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_categories, ids[i])
		m.removedtransaction_categories[ids[i]] = struct{}{}
	}
}

// RemovedTransactionCategories returns the removed IDs of the "transaction_categories" edge to the TransactionCategory entity.
func (m *HouseholdMutation) RemovedTransactionCategoriesIDs() (ids []int) {
	for id := range m.removedtransaction_categories {
		ids = append(ids, id)
	}
	return
}

// TransactionCategoriesIDs returns the "transaction_categories" edge IDs in the mutation.
func (m *HouseholdMutation) TransactionCategoriesIDs() (ids []int) {
	for id := range m.transaction_categories {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionCategories resets all changes to the "transaction_categories" edge.
func (m *HouseholdMutation) ResetTransactionCategories() {
	m.transaction_categories = nil
	m.clearedtransaction_categories = false
	m.removedtransaction_categories = nil
}

// AddTransactionEntryIDs adds the "transaction_entries" edge to the TransactionEntry entity by ids.
func (m *HouseholdMutation) AddTransactionEntryIDs(ids ...int) {
	if m.transaction_entries == nil {
		m.transaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_entries[ids[i]] = struct{}{}
	}
}

// ClearTransactionEntries clears the "transaction_entries" edge to the TransactionEntry entity.
func (m *HouseholdMutation) ClearTransactionEntries() {
	m.clearedtransaction_entries = true
}

// TransactionEntriesCleared reports if the "transaction_entries" edge to the TransactionEntry entity was cleared.
func (m *HouseholdMutation) TransactionEntriesCleared() bool {
	return m.clearedtransaction_entries
}

// RemoveTransactionEntryIDs removes the "transaction_entries" edge to the TransactionEntry entity by IDs.
func (m *HouseholdMutation) RemoveTransactionEntryIDs(ids ...int) {
	if m.removedtransaction_entries == nil {
		m.removedtransaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_entries, ids[i])
		m.removedtransaction_entries[ids[i]] = struct{}{}
	}
}

// RemovedTransactionEntries returns the removed IDs of the "transaction_entries" edge to the TransactionEntry entity.
func (m *HouseholdMutation) RemovedTransactionEntriesIDs() (ids []int) {
	for id := range m.removedtransaction_entries {
		ids = append(ids, id)
	}
	return
}

// TransactionEntriesIDs returns the "transaction_entries" edge IDs in the mutation.
func (m *HouseholdMutation) TransactionEntriesIDs() (ids []int) {
	for id := range m.transaction_entries {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionEntries resets all changes to the "transaction_entries" edge.
func (m *HouseholdMutation) ResetTransactionEntries() {
	m.transaction_entries = nil
	m.clearedtransaction_entries = false
	m.removedtransaction_entries = nil
}

// AddUserHouseholdIDs adds the "user_households" edge to the UserHousehold entity by ids.
func (m *HouseholdMutation) AddUserHouseholdIDs(ids ...int) {
	if m.user_households == nil {
		m.user_households = make(map[int]struct{})
	}
	for i := range ids {
		m.user_households[ids[i]] = struct{}{}
	}
}

// ClearUserHouseholds clears the "user_households" edge to the UserHousehold entity.
func (m *HouseholdMutation) ClearUserHouseholds() {
	m.cleareduser_households = true
}

// UserHouseholdsCleared reports if the "user_households" edge to the UserHousehold entity was cleared.
func (m *HouseholdMutation) UserHouseholdsCleared() bool {
	return m.cleareduser_households
}

// RemoveUserHouseholdIDs removes the "user_households" edge to the UserHousehold entity by IDs.
func (m *HouseholdMutation) RemoveUserHouseholdIDs(ids ...int) {
	if m.removeduser_households == nil {
		m.removeduser_households = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_households, ids[i])
		m.removeduser_households[ids[i]] = struct{}{}
	}
}

// RemovedUserHouseholds returns the removed IDs of the "user_households" edge to the UserHousehold entity.
func (m *HouseholdMutation) RemovedUserHouseholdsIDs() (ids []int) {
	for id := range m.removeduser_households {
		ids = append(ids, id)
	}
	return
}

// UserHouseholdsIDs returns the "user_households" edge IDs in the mutation.
func (m *HouseholdMutation) UserHouseholdsIDs() (ids []int) {
	for id := range m.user_households {
		ids = append(ids, id)
	}
	return
}

// ResetUserHouseholds resets all changes to the "user_households" edge.
func (m *HouseholdMutation) ResetUserHouseholds() {
	m.user_households = nil
	m.cleareduser_households = false
	m.removeduser_households = nil
}

// Where appends a list predicates to the HouseholdMutation builder.
func (m *HouseholdMutation) Where(ps ...predicate.Household) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HouseholdMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HouseholdMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Household, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HouseholdMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HouseholdMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Household).
func (m *HouseholdMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HouseholdMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, household.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, household.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, household.FieldName)
	}
	if m.locale != nil {
		fields = append(fields, household.FieldLocale)
	}
	if m.currency != nil {
		fields = append(fields, household.FieldCurrencyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HouseholdMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case household.FieldCreateTime:
		return m.CreateTime()
	case household.FieldUpdateTime:
		return m.UpdateTime()
	case household.FieldName:
		return m.Name()
	case household.FieldLocale:
		return m.Locale()
	case household.FieldCurrencyID:
		return m.CurrencyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HouseholdMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case household.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case household.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case household.FieldName:
		return m.OldName(ctx)
	case household.FieldLocale:
		return m.OldLocale(ctx)
	case household.FieldCurrencyID:
		return m.OldCurrencyID(ctx)
	}
	return nil, fmt.Errorf("unknown Household field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HouseholdMutation) SetField(name string, value ent.Value) error {
	switch name {
	case household.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case household.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case household.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case household.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case household.FieldCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyID(v)
		return nil
	}
	return fmt.Errorf("unknown Household field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HouseholdMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HouseholdMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HouseholdMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Household numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HouseholdMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HouseholdMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HouseholdMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Household nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HouseholdMutation) ResetField(name string) error {
	switch name {
	case household.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case household.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case household.FieldName:
		m.ResetName()
		return nil
	case household.FieldLocale:
		m.ResetLocale()
		return nil
	case household.FieldCurrencyID:
		m.ResetCurrencyID()
		return nil
	}
	return fmt.Errorf("unknown Household field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HouseholdMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.currency != nil {
		edges = append(edges, household.EdgeCurrency)
	}
	if m.users != nil {
		edges = append(edges, household.EdgeUsers)
	}
	if m.accounts != nil {
		edges = append(edges, household.EdgeAccounts)
	}
	if m.transactions != nil {
		edges = append(edges, household.EdgeTransactions)
	}
	if m.investments != nil {
		edges = append(edges, household.EdgeInvestments)
	}
	if m.investment_lots != nil {
		edges = append(edges, household.EdgeInvestmentLots)
	}
	if m.transaction_categories != nil {
		edges = append(edges, household.EdgeTransactionCategories)
	}
	if m.transaction_entries != nil {
		edges = append(edges, household.EdgeTransactionEntries)
	}
	if m.user_households != nil {
		edges = append(edges, household.EdgeUserHouseholds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HouseholdMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case household.EdgeCurrency:
		if id := m.currency; id != nil {
			return []ent.Value{*id}
		}
	case household.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeInvestments:
		ids := make([]ent.Value, 0, len(m.investments))
		for id := range m.investments {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeInvestmentLots:
		ids := make([]ent.Value, 0, len(m.investment_lots))
		for id := range m.investment_lots {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeTransactionCategories:
		ids := make([]ent.Value, 0, len(m.transaction_categories))
		for id := range m.transaction_categories {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.transaction_entries))
		for id := range m.transaction_entries {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeUserHouseholds:
		ids := make([]ent.Value, 0, len(m.user_households))
		for id := range m.user_households {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HouseholdMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedusers != nil {
		edges = append(edges, household.EdgeUsers)
	}
	if m.removedaccounts != nil {
		edges = append(edges, household.EdgeAccounts)
	}
	if m.removedtransactions != nil {
		edges = append(edges, household.EdgeTransactions)
	}
	if m.removedinvestments != nil {
		edges = append(edges, household.EdgeInvestments)
	}
	if m.removedinvestment_lots != nil {
		edges = append(edges, household.EdgeInvestmentLots)
	}
	if m.removedtransaction_categories != nil {
		edges = append(edges, household.EdgeTransactionCategories)
	}
	if m.removedtransaction_entries != nil {
		edges = append(edges, household.EdgeTransactionEntries)
	}
	if m.removeduser_households != nil {
		edges = append(edges, household.EdgeUserHouseholds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HouseholdMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case household.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeInvestments:
		ids := make([]ent.Value, 0, len(m.removedinvestments))
		for id := range m.removedinvestments {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeInvestmentLots:
		ids := make([]ent.Value, 0, len(m.removedinvestment_lots))
		for id := range m.removedinvestment_lots {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeTransactionCategories:
		ids := make([]ent.Value, 0, len(m.removedtransaction_categories))
		for id := range m.removedtransaction_categories {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.removedtransaction_entries))
		for id := range m.removedtransaction_entries {
			ids = append(ids, id)
		}
		return ids
	case household.EdgeUserHouseholds:
		ids := make([]ent.Value, 0, len(m.removeduser_households))
		for id := range m.removeduser_households {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HouseholdMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedcurrency {
		edges = append(edges, household.EdgeCurrency)
	}
	if m.clearedusers {
		edges = append(edges, household.EdgeUsers)
	}
	if m.clearedaccounts {
		edges = append(edges, household.EdgeAccounts)
	}
	if m.clearedtransactions {
		edges = append(edges, household.EdgeTransactions)
	}
	if m.clearedinvestments {
		edges = append(edges, household.EdgeInvestments)
	}
	if m.clearedinvestment_lots {
		edges = append(edges, household.EdgeInvestmentLots)
	}
	if m.clearedtransaction_categories {
		edges = append(edges, household.EdgeTransactionCategories)
	}
	if m.clearedtransaction_entries {
		edges = append(edges, household.EdgeTransactionEntries)
	}
	if m.cleareduser_households {
		edges = append(edges, household.EdgeUserHouseholds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HouseholdMutation) EdgeCleared(name string) bool {
	switch name {
	case household.EdgeCurrency:
		return m.clearedcurrency
	case household.EdgeUsers:
		return m.clearedusers
	case household.EdgeAccounts:
		return m.clearedaccounts
	case household.EdgeTransactions:
		return m.clearedtransactions
	case household.EdgeInvestments:
		return m.clearedinvestments
	case household.EdgeInvestmentLots:
		return m.clearedinvestment_lots
	case household.EdgeTransactionCategories:
		return m.clearedtransaction_categories
	case household.EdgeTransactionEntries:
		return m.clearedtransaction_entries
	case household.EdgeUserHouseholds:
		return m.cleareduser_households
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HouseholdMutation) ClearEdge(name string) error {
	switch name {
	case household.EdgeCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown Household unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HouseholdMutation) ResetEdge(name string) error {
	switch name {
	case household.EdgeCurrency:
		m.ResetCurrency()
		return nil
	case household.EdgeUsers:
		m.ResetUsers()
		return nil
	case household.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case household.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case household.EdgeInvestments:
		m.ResetInvestments()
		return nil
	case household.EdgeInvestmentLots:
		m.ResetInvestmentLots()
		return nil
	case household.EdgeTransactionCategories:
		m.ResetTransactionCategories()
		return nil
	case household.EdgeTransactionEntries:
		m.ResetTransactionEntries()
		return nil
	case household.EdgeUserHouseholds:
		m.ResetUserHouseholds()
		return nil
	}
	return fmt.Errorf("unknown Household edge %s", name)
}

// InvestmentMutation represents an operation that mutates the Investment nodes in the graph.
type InvestmentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	name                   *string
	_type                  *investment.Type
	symbol                 *string
	amount                 *decimal.Decimal
	addamount              *decimal.Decimal
	quote                  *decimal.Decimal
	addquote               *decimal.Decimal
	value                  *decimal.Decimal
	addvalue               *decimal.Decimal
	clearedFields          map[string]struct{}
	account                *int
	clearedaccount         bool
	household              *int
	clearedhousehold       bool
	currency               *int
	clearedcurrency        bool
	investment_lots        map[int]struct{}
	removedinvestment_lots map[int]struct{}
	clearedinvestment_lots bool
	done                   bool
	oldValue               func(context.Context) (*Investment, error)
	predicates             []predicate.Investment
}

var _ ent.Mutation = (*InvestmentMutation)(nil)

// investmentOption allows management of the mutation configuration using functional options.
type investmentOption func(*InvestmentMutation)

// newInvestmentMutation creates new mutation for the Investment entity.
func newInvestmentMutation(c config, op Op, opts ...investmentOption) *InvestmentMutation {
	m := &InvestmentMutation{
		config:        c,
		op:            op,
		typ:           TypeInvestment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvestmentID sets the ID field of the mutation.
func withInvestmentID(id int) investmentOption {
	return func(m *InvestmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Investment
		)
		m.oldValue = func(ctx context.Context) (*Investment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Investment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvestment sets the old Investment of the mutation.
func withInvestment(node *Investment) investmentOption {
	return func(m *InvestmentMutation) {
		m.oldValue = func(context.Context) (*Investment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvestmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvestmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvestmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvestmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Investment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *InvestmentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *InvestmentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *InvestmentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *InvestmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *InvestmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *InvestmentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetHouseholdID sets the "household_id" field.
func (m *InvestmentMutation) SetHouseholdID(i int) {
	m.household = &i
}

// HouseholdID returns the value of the "household_id" field in the mutation.
func (m *InvestmentMutation) HouseholdID() (r int, exists bool) {
	v := m.household
	if v == nil {
		return
	}
	return *v, true
}

// OldHouseholdID returns the old "household_id" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldHouseholdID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHouseholdID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHouseholdID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHouseholdID: %w", err)
	}
	return oldValue.HouseholdID, nil
}

// ResetHouseholdID resets all changes to the "household_id" field.
func (m *InvestmentMutation) ResetHouseholdID() {
	m.household = nil
}

// SetName sets the "name" field.
func (m *InvestmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InvestmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InvestmentMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *InvestmentMutation) SetType(i investment.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *InvestmentMutation) GetType() (r investment.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldType(ctx context.Context) (v investment.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *InvestmentMutation) ResetType() {
	m._type = nil
}

// SetSymbol sets the "symbol" field.
func (m *InvestmentMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *InvestmentMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *InvestmentMutation) ResetSymbol() {
	m.symbol = nil
}

// SetAmount sets the "amount" field.
func (m *InvestmentMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *InvestmentMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *InvestmentMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *InvestmentMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *InvestmentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetQuote sets the "quote" field.
func (m *InvestmentMutation) SetQuote(d decimal.Decimal) {
	m.quote = &d
	m.addquote = nil
}

// Quote returns the value of the "quote" field in the mutation.
func (m *InvestmentMutation) Quote() (r decimal.Decimal, exists bool) {
	v := m.quote
	if v == nil {
		return
	}
	return *v, true
}

// OldQuote returns the old "quote" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldQuote(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuote: %w", err)
	}
	return oldValue.Quote, nil
}

// AddQuote adds d to the "quote" field.
func (m *InvestmentMutation) AddQuote(d decimal.Decimal) {
	if m.addquote != nil {
		*m.addquote = m.addquote.Add(d)
	} else {
		m.addquote = &d
	}
}

// AddedQuote returns the value that was added to the "quote" field in this mutation.
func (m *InvestmentMutation) AddedQuote() (r decimal.Decimal, exists bool) {
	v := m.addquote
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuote resets all changes to the "quote" field.
func (m *InvestmentMutation) ResetQuote() {
	m.quote = nil
	m.addquote = nil
}

// SetValue sets the "value" field.
func (m *InvestmentMutation) SetValue(d decimal.Decimal) {
	m.value = &d
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *InvestmentMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds d to the "value" field.
func (m *InvestmentMutation) AddValue(d decimal.Decimal) {
	if m.addvalue != nil {
		*m.addvalue = m.addvalue.Add(d)
	} else {
		m.addvalue = &d
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *InvestmentMutation) AddedValue() (r decimal.Decimal, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *InvestmentMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetAccountID sets the "account_id" field.
func (m *InvestmentMutation) SetAccountID(i int) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *InvestmentMutation) AccountID() (r int, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *InvestmentMutation) ResetAccountID() {
	m.account = nil
}

// SetCurrencyID sets the "currency_id" field.
func (m *InvestmentMutation) SetCurrencyID(i int) {
	m.currency = &i
}

// CurrencyID returns the value of the "currency_id" field in the mutation.
func (m *InvestmentMutation) CurrencyID() (r int, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyID returns the old "currency_id" field's value of the Investment entity.
// If the Investment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentMutation) OldCurrencyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyID: %w", err)
	}
	return oldValue.CurrencyID, nil
}

// ResetCurrencyID resets all changes to the "currency_id" field.
func (m *InvestmentMutation) ResetCurrencyID() {
	m.currency = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *InvestmentMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[investment.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *InvestmentMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *InvestmentMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *InvestmentMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearHousehold clears the "household" edge to the Household entity.
func (m *InvestmentMutation) ClearHousehold() {
	m.clearedhousehold = true
	m.clearedFields[investment.FieldHouseholdID] = struct{}{}
}

// HouseholdCleared reports if the "household" edge to the Household entity was cleared.
func (m *InvestmentMutation) HouseholdCleared() bool {
	return m.clearedhousehold
}

// HouseholdIDs returns the "household" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HouseholdID instead. It exists only for internal usage by the builders.
func (m *InvestmentMutation) HouseholdIDs() (ids []int) {
	if id := m.household; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHousehold resets all changes to the "household" edge.
func (m *InvestmentMutation) ResetHousehold() {
	m.household = nil
	m.clearedhousehold = false
}

// ClearCurrency clears the "currency" edge to the Currency entity.
func (m *InvestmentMutation) ClearCurrency() {
	m.clearedcurrency = true
	m.clearedFields[investment.FieldCurrencyID] = struct{}{}
}

// CurrencyCleared reports if the "currency" edge to the Currency entity was cleared.
func (m *InvestmentMutation) CurrencyCleared() bool {
	return m.clearedcurrency
}

// CurrencyIDs returns the "currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyID instead. It exists only for internal usage by the builders.
func (m *InvestmentMutation) CurrencyIDs() (ids []int) {
	if id := m.currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrency resets all changes to the "currency" edge.
func (m *InvestmentMutation) ResetCurrency() {
	m.currency = nil
	m.clearedcurrency = false
}

// AddInvestmentLotIDs adds the "investment_lots" edge to the InvestmentLot entity by ids.
func (m *InvestmentMutation) AddInvestmentLotIDs(ids ...int) {
	if m.investment_lots == nil {
		m.investment_lots = make(map[int]struct{})
	}
	for i := range ids {
		m.investment_lots[ids[i]] = struct{}{}
	}
}

// ClearInvestmentLots clears the "investment_lots" edge to the InvestmentLot entity.
func (m *InvestmentMutation) ClearInvestmentLots() {
	m.clearedinvestment_lots = true
}

// InvestmentLotsCleared reports if the "investment_lots" edge to the InvestmentLot entity was cleared.
func (m *InvestmentMutation) InvestmentLotsCleared() bool {
	return m.clearedinvestment_lots
}

// RemoveInvestmentLotIDs removes the "investment_lots" edge to the InvestmentLot entity by IDs.
func (m *InvestmentMutation) RemoveInvestmentLotIDs(ids ...int) {
	if m.removedinvestment_lots == nil {
		m.removedinvestment_lots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.investment_lots, ids[i])
		m.removedinvestment_lots[ids[i]] = struct{}{}
	}
}

// RemovedInvestmentLots returns the removed IDs of the "investment_lots" edge to the InvestmentLot entity.
func (m *InvestmentMutation) RemovedInvestmentLotsIDs() (ids []int) {
	for id := range m.removedinvestment_lots {
		ids = append(ids, id)
	}
	return
}

// InvestmentLotsIDs returns the "investment_lots" edge IDs in the mutation.
func (m *InvestmentMutation) InvestmentLotsIDs() (ids []int) {
	for id := range m.investment_lots {
		ids = append(ids, id)
	}
	return
}

// ResetInvestmentLots resets all changes to the "investment_lots" edge.
func (m *InvestmentMutation) ResetInvestmentLots() {
	m.investment_lots = nil
	m.clearedinvestment_lots = false
	m.removedinvestment_lots = nil
}

// Where appends a list predicates to the InvestmentMutation builder.
func (m *InvestmentMutation) Where(ps ...predicate.Investment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvestmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvestmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Investment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvestmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvestmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Investment).
func (m *InvestmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvestmentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, investment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, investment.FieldUpdateTime)
	}
	if m.household != nil {
		fields = append(fields, investment.FieldHouseholdID)
	}
	if m.name != nil {
		fields = append(fields, investment.FieldName)
	}
	if m._type != nil {
		fields = append(fields, investment.FieldType)
	}
	if m.symbol != nil {
		fields = append(fields, investment.FieldSymbol)
	}
	if m.amount != nil {
		fields = append(fields, investment.FieldAmount)
	}
	if m.quote != nil {
		fields = append(fields, investment.FieldQuote)
	}
	if m.value != nil {
		fields = append(fields, investment.FieldValue)
	}
	if m.account != nil {
		fields = append(fields, investment.FieldAccountID)
	}
	if m.currency != nil {
		fields = append(fields, investment.FieldCurrencyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvestmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case investment.FieldCreateTime:
		return m.CreateTime()
	case investment.FieldUpdateTime:
		return m.UpdateTime()
	case investment.FieldHouseholdID:
		return m.HouseholdID()
	case investment.FieldName:
		return m.Name()
	case investment.FieldType:
		return m.GetType()
	case investment.FieldSymbol:
		return m.Symbol()
	case investment.FieldAmount:
		return m.Amount()
	case investment.FieldQuote:
		return m.Quote()
	case investment.FieldValue:
		return m.Value()
	case investment.FieldAccountID:
		return m.AccountID()
	case investment.FieldCurrencyID:
		return m.CurrencyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvestmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case investment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case investment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case investment.FieldHouseholdID:
		return m.OldHouseholdID(ctx)
	case investment.FieldName:
		return m.OldName(ctx)
	case investment.FieldType:
		return m.OldType(ctx)
	case investment.FieldSymbol:
		return m.OldSymbol(ctx)
	case investment.FieldAmount:
		return m.OldAmount(ctx)
	case investment.FieldQuote:
		return m.OldQuote(ctx)
	case investment.FieldValue:
		return m.OldValue(ctx)
	case investment.FieldAccountID:
		return m.OldAccountID(ctx)
	case investment.FieldCurrencyID:
		return m.OldCurrencyID(ctx)
	}
	return nil, fmt.Errorf("unknown Investment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case investment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case investment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case investment.FieldHouseholdID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHouseholdID(v)
		return nil
	case investment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case investment.FieldType:
		v, ok := value.(investment.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case investment.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case investment.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case investment.FieldQuote:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuote(v)
		return nil
	case investment.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case investment.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case investment.FieldCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyID(v)
		return nil
	}
	return fmt.Errorf("unknown Investment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvestmentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, investment.FieldAmount)
	}
	if m.addquote != nil {
		fields = append(fields, investment.FieldQuote)
	}
	if m.addvalue != nil {
		fields = append(fields, investment.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvestmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case investment.FieldAmount:
		return m.AddedAmount()
	case investment.FieldQuote:
		return m.AddedQuote()
	case investment.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case investment.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case investment.FieldQuote:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuote(v)
		return nil
	case investment.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown Investment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvestmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvestmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvestmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Investment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvestmentMutation) ResetField(name string) error {
	switch name {
	case investment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case investment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case investment.FieldHouseholdID:
		m.ResetHouseholdID()
		return nil
	case investment.FieldName:
		m.ResetName()
		return nil
	case investment.FieldType:
		m.ResetType()
		return nil
	case investment.FieldSymbol:
		m.ResetSymbol()
		return nil
	case investment.FieldAmount:
		m.ResetAmount()
		return nil
	case investment.FieldQuote:
		m.ResetQuote()
		return nil
	case investment.FieldValue:
		m.ResetValue()
		return nil
	case investment.FieldAccountID:
		m.ResetAccountID()
		return nil
	case investment.FieldCurrencyID:
		m.ResetCurrencyID()
		return nil
	}
	return fmt.Errorf("unknown Investment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvestmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.account != nil {
		edges = append(edges, investment.EdgeAccount)
	}
	if m.household != nil {
		edges = append(edges, investment.EdgeHousehold)
	}
	if m.currency != nil {
		edges = append(edges, investment.EdgeCurrency)
	}
	if m.investment_lots != nil {
		edges = append(edges, investment.EdgeInvestmentLots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvestmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case investment.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case investment.EdgeHousehold:
		if id := m.household; id != nil {
			return []ent.Value{*id}
		}
	case investment.EdgeCurrency:
		if id := m.currency; id != nil {
			return []ent.Value{*id}
		}
	case investment.EdgeInvestmentLots:
		ids := make([]ent.Value, 0, len(m.investment_lots))
		for id := range m.investment_lots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvestmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedinvestment_lots != nil {
		edges = append(edges, investment.EdgeInvestmentLots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvestmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case investment.EdgeInvestmentLots:
		ids := make([]ent.Value, 0, len(m.removedinvestment_lots))
		for id := range m.removedinvestment_lots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvestmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedaccount {
		edges = append(edges, investment.EdgeAccount)
	}
	if m.clearedhousehold {
		edges = append(edges, investment.EdgeHousehold)
	}
	if m.clearedcurrency {
		edges = append(edges, investment.EdgeCurrency)
	}
	if m.clearedinvestment_lots {
		edges = append(edges, investment.EdgeInvestmentLots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvestmentMutation) EdgeCleared(name string) bool {
	switch name {
	case investment.EdgeAccount:
		return m.clearedaccount
	case investment.EdgeHousehold:
		return m.clearedhousehold
	case investment.EdgeCurrency:
		return m.clearedcurrency
	case investment.EdgeInvestmentLots:
		return m.clearedinvestment_lots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvestmentMutation) ClearEdge(name string) error {
	switch name {
	case investment.EdgeAccount:
		m.ClearAccount()
		return nil
	case investment.EdgeHousehold:
		m.ClearHousehold()
		return nil
	case investment.EdgeCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown Investment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvestmentMutation) ResetEdge(name string) error {
	switch name {
	case investment.EdgeAccount:
		m.ResetAccount()
		return nil
	case investment.EdgeHousehold:
		m.ResetHousehold()
		return nil
	case investment.EdgeCurrency:
		m.ResetCurrency()
		return nil
	case investment.EdgeInvestmentLots:
		m.ResetInvestmentLots()
		return nil
	}
	return fmt.Errorf("unknown Investment edge %s", name)
}

// InvestmentLotMutation represents an operation that mutates the InvestmentLot nodes in the graph.
type InvestmentLotMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	amount             *decimal.Decimal
	addamount          *decimal.Decimal
	price              *decimal.Decimal
	addprice           *decimal.Decimal
	clearedFields      map[string]struct{}
	household          *int
	clearedhousehold   bool
	investment         *int
	clearedinvestment  bool
	transaction        *int
	clearedtransaction bool
	done               bool
	oldValue           func(context.Context) (*InvestmentLot, error)
	predicates         []predicate.InvestmentLot
}

var _ ent.Mutation = (*InvestmentLotMutation)(nil)

// investmentlotOption allows management of the mutation configuration using functional options.
type investmentlotOption func(*InvestmentLotMutation)

// newInvestmentLotMutation creates new mutation for the InvestmentLot entity.
func newInvestmentLotMutation(c config, op Op, opts ...investmentlotOption) *InvestmentLotMutation {
	m := &InvestmentLotMutation{
		config:        c,
		op:            op,
		typ:           TypeInvestmentLot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvestmentLotID sets the ID field of the mutation.
func withInvestmentLotID(id int) investmentlotOption {
	return func(m *InvestmentLotMutation) {
		var (
			err   error
			once  sync.Once
			value *InvestmentLot
		)
		m.oldValue = func(ctx context.Context) (*InvestmentLot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvestmentLot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvestmentLot sets the old InvestmentLot of the mutation.
func withInvestmentLot(node *InvestmentLot) investmentlotOption {
	return func(m *InvestmentLotMutation) {
		m.oldValue = func(context.Context) (*InvestmentLot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvestmentLotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvestmentLotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvestmentLotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvestmentLotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvestmentLot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *InvestmentLotMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *InvestmentLotMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the InvestmentLot entity.
// If the InvestmentLot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentLotMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *InvestmentLotMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *InvestmentLotMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *InvestmentLotMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the InvestmentLot entity.
// If the InvestmentLot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentLotMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *InvestmentLotMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetHouseholdID sets the "household_id" field.
func (m *InvestmentLotMutation) SetHouseholdID(i int) {
	m.household = &i
}

// HouseholdID returns the value of the "household_id" field in the mutation.
func (m *InvestmentLotMutation) HouseholdID() (r int, exists bool) {
	v := m.household
	if v == nil {
		return
	}
	return *v, true
}

// OldHouseholdID returns the old "household_id" field's value of the InvestmentLot entity.
// If the InvestmentLot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentLotMutation) OldHouseholdID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHouseholdID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHouseholdID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHouseholdID: %w", err)
	}
	return oldValue.HouseholdID, nil
}

// ResetHouseholdID resets all changes to the "household_id" field.
func (m *InvestmentLotMutation) ResetHouseholdID() {
	m.household = nil
}

// SetAmount sets the "amount" field.
func (m *InvestmentLotMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *InvestmentLotMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the InvestmentLot entity.
// If the InvestmentLot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentLotMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *InvestmentLotMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *InvestmentLotMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *InvestmentLotMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPrice sets the "price" field.
func (m *InvestmentLotMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *InvestmentLotMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the InvestmentLot entity.
// If the InvestmentLot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentLotMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds d to the "price" field.
func (m *InvestmentLotMutation) AddPrice(d decimal.Decimal) {
	if m.addprice != nil {
		*m.addprice = m.addprice.Add(d)
	} else {
		m.addprice = &d
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *InvestmentLotMutation) AddedPrice() (r decimal.Decimal, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *InvestmentLotMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetInvestmentID sets the "investment_id" field.
func (m *InvestmentLotMutation) SetInvestmentID(i int) {
	m.investment = &i
}

// InvestmentID returns the value of the "investment_id" field in the mutation.
func (m *InvestmentLotMutation) InvestmentID() (r int, exists bool) {
	v := m.investment
	if v == nil {
		return
	}
	return *v, true
}

// OldInvestmentID returns the old "investment_id" field's value of the InvestmentLot entity.
// If the InvestmentLot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentLotMutation) OldInvestmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvestmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvestmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvestmentID: %w", err)
	}
	return oldValue.InvestmentID, nil
}

// ResetInvestmentID resets all changes to the "investment_id" field.
func (m *InvestmentLotMutation) ResetInvestmentID() {
	m.investment = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *InvestmentLotMutation) SetTransactionID(i int) {
	m.transaction = &i
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *InvestmentLotMutation) TransactionID() (r int, exists bool) {
	v := m.transaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the InvestmentLot entity.
// If the InvestmentLot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestmentLotMutation) OldTransactionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *InvestmentLotMutation) ResetTransactionID() {
	m.transaction = nil
}

// ClearHousehold clears the "household" edge to the Household entity.
func (m *InvestmentLotMutation) ClearHousehold() {
	m.clearedhousehold = true
	m.clearedFields[investmentlot.FieldHouseholdID] = struct{}{}
}

// HouseholdCleared reports if the "household" edge to the Household entity was cleared.
func (m *InvestmentLotMutation) HouseholdCleared() bool {
	return m.clearedhousehold
}

// HouseholdIDs returns the "household" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HouseholdID instead. It exists only for internal usage by the builders.
func (m *InvestmentLotMutation) HouseholdIDs() (ids []int) {
	if id := m.household; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHousehold resets all changes to the "household" edge.
func (m *InvestmentLotMutation) ResetHousehold() {
	m.household = nil
	m.clearedhousehold = false
}

// ClearInvestment clears the "investment" edge to the Investment entity.
func (m *InvestmentLotMutation) ClearInvestment() {
	m.clearedinvestment = true
	m.clearedFields[investmentlot.FieldInvestmentID] = struct{}{}
}

// InvestmentCleared reports if the "investment" edge to the Investment entity was cleared.
func (m *InvestmentLotMutation) InvestmentCleared() bool {
	return m.clearedinvestment
}

// InvestmentIDs returns the "investment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvestmentID instead. It exists only for internal usage by the builders.
func (m *InvestmentLotMutation) InvestmentIDs() (ids []int) {
	if id := m.investment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvestment resets all changes to the "investment" edge.
func (m *InvestmentLotMutation) ResetInvestment() {
	m.investment = nil
	m.clearedinvestment = false
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *InvestmentLotMutation) ClearTransaction() {
	m.clearedtransaction = true
	m.clearedFields[investmentlot.FieldTransactionID] = struct{}{}
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *InvestmentLotMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *InvestmentLotMutation) TransactionIDs() (ids []int) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *InvestmentLotMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// Where appends a list predicates to the InvestmentLotMutation builder.
func (m *InvestmentLotMutation) Where(ps ...predicate.InvestmentLot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvestmentLotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvestmentLotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvestmentLot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvestmentLotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvestmentLotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvestmentLot).
func (m *InvestmentLotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvestmentLotMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, investmentlot.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, investmentlot.FieldUpdateTime)
	}
	if m.household != nil {
		fields = append(fields, investmentlot.FieldHouseholdID)
	}
	if m.amount != nil {
		fields = append(fields, investmentlot.FieldAmount)
	}
	if m.price != nil {
		fields = append(fields, investmentlot.FieldPrice)
	}
	if m.investment != nil {
		fields = append(fields, investmentlot.FieldInvestmentID)
	}
	if m.transaction != nil {
		fields = append(fields, investmentlot.FieldTransactionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvestmentLotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case investmentlot.FieldCreateTime:
		return m.CreateTime()
	case investmentlot.FieldUpdateTime:
		return m.UpdateTime()
	case investmentlot.FieldHouseholdID:
		return m.HouseholdID()
	case investmentlot.FieldAmount:
		return m.Amount()
	case investmentlot.FieldPrice:
		return m.Price()
	case investmentlot.FieldInvestmentID:
		return m.InvestmentID()
	case investmentlot.FieldTransactionID:
		return m.TransactionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvestmentLotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case investmentlot.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case investmentlot.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case investmentlot.FieldHouseholdID:
		return m.OldHouseholdID(ctx)
	case investmentlot.FieldAmount:
		return m.OldAmount(ctx)
	case investmentlot.FieldPrice:
		return m.OldPrice(ctx)
	case investmentlot.FieldInvestmentID:
		return m.OldInvestmentID(ctx)
	case investmentlot.FieldTransactionID:
		return m.OldTransactionID(ctx)
	}
	return nil, fmt.Errorf("unknown InvestmentLot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestmentLotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case investmentlot.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case investmentlot.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case investmentlot.FieldHouseholdID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHouseholdID(v)
		return nil
	case investmentlot.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case investmentlot.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case investmentlot.FieldInvestmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvestmentID(v)
		return nil
	case investmentlot.FieldTransactionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	}
	return fmt.Errorf("unknown InvestmentLot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvestmentLotMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, investmentlot.FieldAmount)
	}
	if m.addprice != nil {
		fields = append(fields, investmentlot.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvestmentLotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case investmentlot.FieldAmount:
		return m.AddedAmount()
	case investmentlot.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestmentLotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case investmentlot.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case investmentlot.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown InvestmentLot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvestmentLotMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvestmentLotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvestmentLotMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvestmentLot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvestmentLotMutation) ResetField(name string) error {
	switch name {
	case investmentlot.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case investmentlot.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case investmentlot.FieldHouseholdID:
		m.ResetHouseholdID()
		return nil
	case investmentlot.FieldAmount:
		m.ResetAmount()
		return nil
	case investmentlot.FieldPrice:
		m.ResetPrice()
		return nil
	case investmentlot.FieldInvestmentID:
		m.ResetInvestmentID()
		return nil
	case investmentlot.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	}
	return fmt.Errorf("unknown InvestmentLot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvestmentLotMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.household != nil {
		edges = append(edges, investmentlot.EdgeHousehold)
	}
	if m.investment != nil {
		edges = append(edges, investmentlot.EdgeInvestment)
	}
	if m.transaction != nil {
		edges = append(edges, investmentlot.EdgeTransaction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvestmentLotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case investmentlot.EdgeHousehold:
		if id := m.household; id != nil {
			return []ent.Value{*id}
		}
	case investmentlot.EdgeInvestment:
		if id := m.investment; id != nil {
			return []ent.Value{*id}
		}
	case investmentlot.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvestmentLotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvestmentLotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvestmentLotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedhousehold {
		edges = append(edges, investmentlot.EdgeHousehold)
	}
	if m.clearedinvestment {
		edges = append(edges, investmentlot.EdgeInvestment)
	}
	if m.clearedtransaction {
		edges = append(edges, investmentlot.EdgeTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvestmentLotMutation) EdgeCleared(name string) bool {
	switch name {
	case investmentlot.EdgeHousehold:
		return m.clearedhousehold
	case investmentlot.EdgeInvestment:
		return m.clearedinvestment
	case investmentlot.EdgeTransaction:
		return m.clearedtransaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvestmentLotMutation) ClearEdge(name string) error {
	switch name {
	case investmentlot.EdgeHousehold:
		m.ClearHousehold()
		return nil
	case investmentlot.EdgeInvestment:
		m.ClearInvestment()
		return nil
	case investmentlot.EdgeTransaction:
		m.ClearTransaction()
		return nil
	}
	return fmt.Errorf("unknown InvestmentLot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvestmentLotMutation) ResetEdge(name string) error {
	switch name {
	case investmentlot.EdgeHousehold:
		m.ResetHousehold()
		return nil
	case investmentlot.EdgeInvestment:
		m.ResetInvestment()
		return nil
	case investmentlot.EdgeTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown InvestmentLot edge %s", name)
}

// StockQuoteCacheMutation represents an operation that mutates the StockQuoteCache nodes in the graph.
type StockQuoteCacheMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	symbol        *string
	value         *decimal.Decimal
	addvalue      *decimal.Decimal
	date          *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*StockQuoteCache, error)
	predicates    []predicate.StockQuoteCache
}

var _ ent.Mutation = (*StockQuoteCacheMutation)(nil)

// stockquotecacheOption allows management of the mutation configuration using functional options.
type stockquotecacheOption func(*StockQuoteCacheMutation)

// newStockQuoteCacheMutation creates new mutation for the StockQuoteCache entity.
func newStockQuoteCacheMutation(c config, op Op, opts ...stockquotecacheOption) *StockQuoteCacheMutation {
	m := &StockQuoteCacheMutation{
		config:        c,
		op:            op,
		typ:           TypeStockQuoteCache,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockQuoteCacheID sets the ID field of the mutation.
func withStockQuoteCacheID(id int) stockquotecacheOption {
	return func(m *StockQuoteCacheMutation) {
		var (
			err   error
			once  sync.Once
			value *StockQuoteCache
		)
		m.oldValue = func(ctx context.Context) (*StockQuoteCache, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StockQuoteCache.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStockQuoteCache sets the old StockQuoteCache of the mutation.
func withStockQuoteCache(node *StockQuoteCache) stockquotecacheOption {
	return func(m *StockQuoteCacheMutation) {
		m.oldValue = func(context.Context) (*StockQuoteCache, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockQuoteCacheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockQuoteCacheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockQuoteCacheMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockQuoteCacheMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StockQuoteCache.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *StockQuoteCacheMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StockQuoteCacheMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the StockQuoteCache entity.
// If the StockQuoteCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockQuoteCacheMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StockQuoteCacheMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *StockQuoteCacheMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *StockQuoteCacheMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the StockQuoteCache entity.
// If the StockQuoteCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockQuoteCacheMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *StockQuoteCacheMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSymbol sets the "symbol" field.
func (m *StockQuoteCacheMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *StockQuoteCacheMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the StockQuoteCache entity.
// If the StockQuoteCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockQuoteCacheMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *StockQuoteCacheMutation) ResetSymbol() {
	m.symbol = nil
}

// SetValue sets the "value" field.
func (m *StockQuoteCacheMutation) SetValue(d decimal.Decimal) {
	m.value = &d
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *StockQuoteCacheMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the StockQuoteCache entity.
// If the StockQuoteCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockQuoteCacheMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds d to the "value" field.
func (m *StockQuoteCacheMutation) AddValue(d decimal.Decimal) {
	if m.addvalue != nil {
		*m.addvalue = m.addvalue.Add(d)
	} else {
		m.addvalue = &d
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *StockQuoteCacheMutation) AddedValue() (r decimal.Decimal, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *StockQuoteCacheMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetDate sets the "date" field.
func (m *StockQuoteCacheMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *StockQuoteCacheMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the StockQuoteCache entity.
// If the StockQuoteCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockQuoteCacheMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *StockQuoteCacheMutation) ResetDate() {
	m.date = nil
}

// Where appends a list predicates to the StockQuoteCacheMutation builder.
func (m *StockQuoteCacheMutation) Where(ps ...predicate.StockQuoteCache) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockQuoteCacheMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockQuoteCacheMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StockQuoteCache, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockQuoteCacheMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockQuoteCacheMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StockQuoteCache).
func (m *StockQuoteCacheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockQuoteCacheMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, stockquotecache.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, stockquotecache.FieldUpdateTime)
	}
	if m.symbol != nil {
		fields = append(fields, stockquotecache.FieldSymbol)
	}
	if m.value != nil {
		fields = append(fields, stockquotecache.FieldValue)
	}
	if m.date != nil {
		fields = append(fields, stockquotecache.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockQuoteCacheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stockquotecache.FieldCreateTime:
		return m.CreateTime()
	case stockquotecache.FieldUpdateTime:
		return m.UpdateTime()
	case stockquotecache.FieldSymbol:
		return m.Symbol()
	case stockquotecache.FieldValue:
		return m.Value()
	case stockquotecache.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockQuoteCacheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stockquotecache.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case stockquotecache.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case stockquotecache.FieldSymbol:
		return m.OldSymbol(ctx)
	case stockquotecache.FieldValue:
		return m.OldValue(ctx)
	case stockquotecache.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown StockQuoteCache field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockQuoteCacheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stockquotecache.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case stockquotecache.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case stockquotecache.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case stockquotecache.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case stockquotecache.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown StockQuoteCache field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockQuoteCacheMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, stockquotecache.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockQuoteCacheMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stockquotecache.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockQuoteCacheMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stockquotecache.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown StockQuoteCache numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockQuoteCacheMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockQuoteCacheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockQuoteCacheMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StockQuoteCache nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockQuoteCacheMutation) ResetField(name string) error {
	switch name {
	case stockquotecache.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case stockquotecache.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case stockquotecache.FieldSymbol:
		m.ResetSymbol()
		return nil
	case stockquotecache.FieldValue:
		m.ResetValue()
		return nil
	case stockquotecache.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown StockQuoteCache field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockQuoteCacheMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockQuoteCacheMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockQuoteCacheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockQuoteCacheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockQuoteCacheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockQuoteCacheMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockQuoteCacheMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StockQuoteCache unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockQuoteCacheMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StockQuoteCache edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	update_time                *time.Time
	description                *string
	datetime                   *time.Time
	clearedFields              map[string]struct{}
	user                       *int
	cleareduser                bool
	household                  *int
	clearedhousehold           bool
	category                   *int
	clearedcategory            bool
	transaction_entries        map[int]struct{}
	removedtransaction_entries map[int]struct{}
	clearedtransaction_entries bool
	investment_lots            map[int]struct{}
	removedinvestment_lots     map[int]struct{}
	clearedinvestment_lots     bool
	done                       bool
	oldValue                   func(context.Context) (*Transaction, error)
	predicates                 []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransactionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransactionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransactionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransactionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransactionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransactionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetHouseholdID sets the "household_id" field.
func (m *TransactionMutation) SetHouseholdID(i int) {
	m.household = &i
}

// HouseholdID returns the value of the "household_id" field in the mutation.
func (m *TransactionMutation) HouseholdID() (r int, exists bool) {
	v := m.household
	if v == nil {
		return
	}
	return *v, true
}

// OldHouseholdID returns the old "household_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldHouseholdID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHouseholdID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHouseholdID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHouseholdID: %w", err)
	}
	return oldValue.HouseholdID, nil
}

// ResetHouseholdID resets all changes to the "household_id" field.
func (m *TransactionMutation) ResetHouseholdID() {
	m.household = nil
}

// SetDescription sets the "description" field.
func (m *TransactionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransactionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TransactionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[transaction.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TransactionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[transaction.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TransactionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, transaction.FieldDescription)
}

// SetDatetime sets the "datetime" field.
func (m *TransactionMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the value of the "datetime" field in the mutation.
func (m *TransactionMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old "datetime" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime resets all changes to the "datetime" field.
func (m *TransactionMutation) ResetDatetime() {
	m.datetime = nil
}

// SetUserID sets the "user_id" field.
func (m *TransactionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TransactionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TransactionMutation) ResetUserID() {
	m.user = nil
}

// SetCategoryID sets the "category_id" field.
func (m *TransactionMutation) SetCategoryID(i int) {
	m.category = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *TransactionMutation) CategoryID() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *TransactionMutation) ResetCategoryID() {
	m.category = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *TransactionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[transaction.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TransactionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TransactionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearHousehold clears the "household" edge to the Household entity.
func (m *TransactionMutation) ClearHousehold() {
	m.clearedhousehold = true
	m.clearedFields[transaction.FieldHouseholdID] = struct{}{}
}

// HouseholdCleared reports if the "household" edge to the Household entity was cleared.
func (m *TransactionMutation) HouseholdCleared() bool {
	return m.clearedhousehold
}

// HouseholdIDs returns the "household" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HouseholdID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) HouseholdIDs() (ids []int) {
	if id := m.household; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHousehold resets all changes to the "household" edge.
func (m *TransactionMutation) ResetHousehold() {
	m.household = nil
	m.clearedhousehold = false
}

// ClearCategory clears the "category" edge to the TransactionCategory entity.
func (m *TransactionMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[transaction.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the TransactionCategory entity was cleared.
func (m *TransactionMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *TransactionMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddTransactionEntryIDs adds the "transaction_entries" edge to the TransactionEntry entity by ids.
func (m *TransactionMutation) AddTransactionEntryIDs(ids ...int) {
	if m.transaction_entries == nil {
		m.transaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_entries[ids[i]] = struct{}{}
	}
}

// ClearTransactionEntries clears the "transaction_entries" edge to the TransactionEntry entity.
func (m *TransactionMutation) ClearTransactionEntries() {
	m.clearedtransaction_entries = true
}

// TransactionEntriesCleared reports if the "transaction_entries" edge to the TransactionEntry entity was cleared.
func (m *TransactionMutation) TransactionEntriesCleared() bool {
	return m.clearedtransaction_entries
}

// RemoveTransactionEntryIDs removes the "transaction_entries" edge to the TransactionEntry entity by IDs.
func (m *TransactionMutation) RemoveTransactionEntryIDs(ids ...int) {
	if m.removedtransaction_entries == nil {
		m.removedtransaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_entries, ids[i])
		m.removedtransaction_entries[ids[i]] = struct{}{}
	}
}

// RemovedTransactionEntries returns the removed IDs of the "transaction_entries" edge to the TransactionEntry entity.
func (m *TransactionMutation) RemovedTransactionEntriesIDs() (ids []int) {
	for id := range m.removedtransaction_entries {
		ids = append(ids, id)
	}
	return
}

// TransactionEntriesIDs returns the "transaction_entries" edge IDs in the mutation.
func (m *TransactionMutation) TransactionEntriesIDs() (ids []int) {
	for id := range m.transaction_entries {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionEntries resets all changes to the "transaction_entries" edge.
func (m *TransactionMutation) ResetTransactionEntries() {
	m.transaction_entries = nil
	m.clearedtransaction_entries = false
	m.removedtransaction_entries = nil
}

// AddInvestmentLotIDs adds the "investment_lots" edge to the InvestmentLot entity by ids.
func (m *TransactionMutation) AddInvestmentLotIDs(ids ...int) {
	if m.investment_lots == nil {
		m.investment_lots = make(map[int]struct{})
	}
	for i := range ids {
		m.investment_lots[ids[i]] = struct{}{}
	}
}

// ClearInvestmentLots clears the "investment_lots" edge to the InvestmentLot entity.
func (m *TransactionMutation) ClearInvestmentLots() {
	m.clearedinvestment_lots = true
}

// InvestmentLotsCleared reports if the "investment_lots" edge to the InvestmentLot entity was cleared.
func (m *TransactionMutation) InvestmentLotsCleared() bool {
	return m.clearedinvestment_lots
}

// RemoveInvestmentLotIDs removes the "investment_lots" edge to the InvestmentLot entity by IDs.
func (m *TransactionMutation) RemoveInvestmentLotIDs(ids ...int) {
	if m.removedinvestment_lots == nil {
		m.removedinvestment_lots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.investment_lots, ids[i])
		m.removedinvestment_lots[ids[i]] = struct{}{}
	}
}

// RemovedInvestmentLots returns the removed IDs of the "investment_lots" edge to the InvestmentLot entity.
func (m *TransactionMutation) RemovedInvestmentLotsIDs() (ids []int) {
	for id := range m.removedinvestment_lots {
		ids = append(ids, id)
	}
	return
}

// InvestmentLotsIDs returns the "investment_lots" edge IDs in the mutation.
func (m *TransactionMutation) InvestmentLotsIDs() (ids []int) {
	for id := range m.investment_lots {
		ids = append(ids, id)
	}
	return
}

// ResetInvestmentLots resets all changes to the "investment_lots" edge.
func (m *TransactionMutation) ResetInvestmentLots() {
	m.investment_lots = nil
	m.clearedinvestment_lots = false
	m.removedinvestment_lots = nil
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, transaction.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transaction.FieldUpdateTime)
	}
	if m.household != nil {
		fields = append(fields, transaction.FieldHouseholdID)
	}
	if m.description != nil {
		fields = append(fields, transaction.FieldDescription)
	}
	if m.datetime != nil {
		fields = append(fields, transaction.FieldDatetime)
	}
	if m.user != nil {
		fields = append(fields, transaction.FieldUserID)
	}
	if m.category != nil {
		fields = append(fields, transaction.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldCreateTime:
		return m.CreateTime()
	case transaction.FieldUpdateTime:
		return m.UpdateTime()
	case transaction.FieldHouseholdID:
		return m.HouseholdID()
	case transaction.FieldDescription:
		return m.Description()
	case transaction.FieldDatetime:
		return m.Datetime()
	case transaction.FieldUserID:
		return m.UserID()
	case transaction.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transaction.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transaction.FieldHouseholdID:
		return m.OldHouseholdID(ctx)
	case transaction.FieldDescription:
		return m.OldDescription(ctx)
	case transaction.FieldDatetime:
		return m.OldDatetime(ctx)
	case transaction.FieldUserID:
		return m.OldUserID(ctx)
	case transaction.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transaction.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transaction.FieldHouseholdID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHouseholdID(v)
		return nil
	case transaction.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case transaction.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	case transaction.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case transaction.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldDescription) {
		fields = append(fields, transaction.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transaction.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transaction.FieldHouseholdID:
		m.ResetHouseholdID()
		return nil
	case transaction.FieldDescription:
		m.ResetDescription()
		return nil
	case transaction.FieldDatetime:
		m.ResetDatetime()
		return nil
	case transaction.FieldUserID:
		m.ResetUserID()
		return nil
	case transaction.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, transaction.EdgeUser)
	}
	if m.household != nil {
		edges = append(edges, transaction.EdgeHousehold)
	}
	if m.category != nil {
		edges = append(edges, transaction.EdgeCategory)
	}
	if m.transaction_entries != nil {
		edges = append(edges, transaction.EdgeTransactionEntries)
	}
	if m.investment_lots != nil {
		edges = append(edges, transaction.EdgeInvestmentLots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeHousehold:
		if id := m.household; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.transaction_entries))
		for id := range m.transaction_entries {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeInvestmentLots:
		ids := make([]ent.Value, 0, len(m.investment_lots))
		for id := range m.investment_lots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtransaction_entries != nil {
		edges = append(edges, transaction.EdgeTransactionEntries)
	}
	if m.removedinvestment_lots != nil {
		edges = append(edges, transaction.EdgeInvestmentLots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.removedtransaction_entries))
		for id := range m.removedtransaction_entries {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeInvestmentLots:
		ids := make([]ent.Value, 0, len(m.removedinvestment_lots))
		for id := range m.removedinvestment_lots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, transaction.EdgeUser)
	}
	if m.clearedhousehold {
		edges = append(edges, transaction.EdgeHousehold)
	}
	if m.clearedcategory {
		edges = append(edges, transaction.EdgeCategory)
	}
	if m.clearedtransaction_entries {
		edges = append(edges, transaction.EdgeTransactionEntries)
	}
	if m.clearedinvestment_lots {
		edges = append(edges, transaction.EdgeInvestmentLots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeUser:
		return m.cleareduser
	case transaction.EdgeHousehold:
		return m.clearedhousehold
	case transaction.EdgeCategory:
		return m.clearedcategory
	case transaction.EdgeTransactionEntries:
		return m.clearedtransaction_entries
	case transaction.EdgeInvestmentLots:
		return m.clearedinvestment_lots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeUser:
		m.ClearUser()
		return nil
	case transaction.EdgeHousehold:
		m.ClearHousehold()
		return nil
	case transaction.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeUser:
		m.ResetUser()
		return nil
	case transaction.EdgeHousehold:
		m.ResetHousehold()
		return nil
	case transaction.EdgeCategory:
		m.ResetCategory()
		return nil
	case transaction.EdgeTransactionEntries:
		m.ResetTransactionEntries()
		return nil
	case transaction.EdgeInvestmentLots:
		m.ResetInvestmentLots()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// TransactionCategoryMutation represents an operation that mutates the TransactionCategory nodes in the graph.
type TransactionCategoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	name                *string
	_type               *transactioncategory.Type
	icon                *string
	is_immutable        *bool
	clearedFields       map[string]struct{}
	household           *int
	clearedhousehold    bool
	transactions        map[int]struct{}
	removedtransactions map[int]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*TransactionCategory, error)
	predicates          []predicate.TransactionCategory
}

var _ ent.Mutation = (*TransactionCategoryMutation)(nil)

// transactioncategoryOption allows management of the mutation configuration using functional options.
type transactioncategoryOption func(*TransactionCategoryMutation)

// newTransactionCategoryMutation creates new mutation for the TransactionCategory entity.
func newTransactionCategoryMutation(c config, op Op, opts ...transactioncategoryOption) *TransactionCategoryMutation {
	m := &TransactionCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionCategoryID sets the ID field of the mutation.
func withTransactionCategoryID(id int) transactioncategoryOption {
	return func(m *TransactionCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionCategory
		)
		m.oldValue = func(ctx context.Context) (*TransactionCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionCategory sets the old TransactionCategory of the mutation.
func withTransactionCategory(node *TransactionCategory) transactioncategoryOption {
	return func(m *TransactionCategoryMutation) {
		m.oldValue = func(context.Context) (*TransactionCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransactionCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransactionCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TransactionCategory entity.
// If the TransactionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransactionCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransactionCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransactionCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TransactionCategory entity.
// If the TransactionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransactionCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetHouseholdID sets the "household_id" field.
func (m *TransactionCategoryMutation) SetHouseholdID(i int) {
	m.household = &i
}

// HouseholdID returns the value of the "household_id" field in the mutation.
func (m *TransactionCategoryMutation) HouseholdID() (r int, exists bool) {
	v := m.household
	if v == nil {
		return
	}
	return *v, true
}

// OldHouseholdID returns the old "household_id" field's value of the TransactionCategory entity.
// If the TransactionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionCategoryMutation) OldHouseholdID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHouseholdID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHouseholdID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHouseholdID: %w", err)
	}
	return oldValue.HouseholdID, nil
}

// ResetHouseholdID resets all changes to the "household_id" field.
func (m *TransactionCategoryMutation) ResetHouseholdID() {
	m.household = nil
}

// SetName sets the "name" field.
func (m *TransactionCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TransactionCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TransactionCategory entity.
// If the TransactionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TransactionCategoryMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *TransactionCategoryMutation) SetType(t transactioncategory.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransactionCategoryMutation) GetType() (r transactioncategory.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TransactionCategory entity.
// If the TransactionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionCategoryMutation) OldType(ctx context.Context) (v transactioncategory.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransactionCategoryMutation) ResetType() {
	m._type = nil
}

// SetIcon sets the "icon" field.
func (m *TransactionCategoryMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *TransactionCategoryMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the TransactionCategory entity.
// If the TransactionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionCategoryMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *TransactionCategoryMutation) ResetIcon() {
	m.icon = nil
}

// SetIsImmutable sets the "is_immutable" field.
func (m *TransactionCategoryMutation) SetIsImmutable(b bool) {
	m.is_immutable = &b
}

// IsImmutable returns the value of the "is_immutable" field in the mutation.
func (m *TransactionCategoryMutation) IsImmutable() (r bool, exists bool) {
	v := m.is_immutable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsImmutable returns the old "is_immutable" field's value of the TransactionCategory entity.
// If the TransactionCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionCategoryMutation) OldIsImmutable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsImmutable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsImmutable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsImmutable: %w", err)
	}
	return oldValue.IsImmutable, nil
}

// ResetIsImmutable resets all changes to the "is_immutable" field.
func (m *TransactionCategoryMutation) ResetIsImmutable() {
	m.is_immutable = nil
}

// ClearHousehold clears the "household" edge to the Household entity.
func (m *TransactionCategoryMutation) ClearHousehold() {
	m.clearedhousehold = true
	m.clearedFields[transactioncategory.FieldHouseholdID] = struct{}{}
}

// HouseholdCleared reports if the "household" edge to the Household entity was cleared.
func (m *TransactionCategoryMutation) HouseholdCleared() bool {
	return m.clearedhousehold
}

// HouseholdIDs returns the "household" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HouseholdID instead. It exists only for internal usage by the builders.
func (m *TransactionCategoryMutation) HouseholdIDs() (ids []int) {
	if id := m.household; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHousehold resets all changes to the "household" edge.
func (m *TransactionCategoryMutation) ResetHousehold() {
	m.household = nil
	m.clearedhousehold = false
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *TransactionCategoryMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *TransactionCategoryMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *TransactionCategoryMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *TransactionCategoryMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *TransactionCategoryMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *TransactionCategoryMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *TransactionCategoryMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the TransactionCategoryMutation builder.
func (m *TransactionCategoryMutation) Where(ps ...predicate.TransactionCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransactionCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransactionCategory).
func (m *TransactionCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionCategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, transactioncategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transactioncategory.FieldUpdateTime)
	}
	if m.household != nil {
		fields = append(fields, transactioncategory.FieldHouseholdID)
	}
	if m.name != nil {
		fields = append(fields, transactioncategory.FieldName)
	}
	if m._type != nil {
		fields = append(fields, transactioncategory.FieldType)
	}
	if m.icon != nil {
		fields = append(fields, transactioncategory.FieldIcon)
	}
	if m.is_immutable != nil {
		fields = append(fields, transactioncategory.FieldIsImmutable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactioncategory.FieldCreateTime:
		return m.CreateTime()
	case transactioncategory.FieldUpdateTime:
		return m.UpdateTime()
	case transactioncategory.FieldHouseholdID:
		return m.HouseholdID()
	case transactioncategory.FieldName:
		return m.Name()
	case transactioncategory.FieldType:
		return m.GetType()
	case transactioncategory.FieldIcon:
		return m.Icon()
	case transactioncategory.FieldIsImmutable:
		return m.IsImmutable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactioncategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transactioncategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transactioncategory.FieldHouseholdID:
		return m.OldHouseholdID(ctx)
	case transactioncategory.FieldName:
		return m.OldName(ctx)
	case transactioncategory.FieldType:
		return m.OldType(ctx)
	case transactioncategory.FieldIcon:
		return m.OldIcon(ctx)
	case transactioncategory.FieldIsImmutable:
		return m.OldIsImmutable(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactioncategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transactioncategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transactioncategory.FieldHouseholdID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHouseholdID(v)
		return nil
	case transactioncategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case transactioncategory.FieldType:
		v, ok := value.(transactioncategory.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transactioncategory.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case transactioncategory.FieldIsImmutable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsImmutable(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionCategoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransactionCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransactionCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionCategoryMutation) ResetField(name string) error {
	switch name {
	case transactioncategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transactioncategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transactioncategory.FieldHouseholdID:
		m.ResetHouseholdID()
		return nil
	case transactioncategory.FieldName:
		m.ResetName()
		return nil
	case transactioncategory.FieldType:
		m.ResetType()
		return nil
	case transactioncategory.FieldIcon:
		m.ResetIcon()
		return nil
	case transactioncategory.FieldIsImmutable:
		m.ResetIsImmutable()
		return nil
	}
	return fmt.Errorf("unknown TransactionCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.household != nil {
		edges = append(edges, transactioncategory.EdgeHousehold)
	}
	if m.transactions != nil {
		edges = append(edges, transactioncategory.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactioncategory.EdgeHousehold:
		if id := m.household; id != nil {
			return []ent.Value{*id}
		}
	case transactioncategory.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransactions != nil {
		edges = append(edges, transactioncategory.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transactioncategory.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhousehold {
		edges = append(edges, transactioncategory.EdgeHousehold)
	}
	if m.clearedtransactions {
		edges = append(edges, transactioncategory.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case transactioncategory.EdgeHousehold:
		return m.clearedhousehold
	case transactioncategory.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionCategoryMutation) ClearEdge(name string) error {
	switch name {
	case transactioncategory.EdgeHousehold:
		m.ClearHousehold()
		return nil
	}
	return fmt.Errorf("unknown TransactionCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionCategoryMutation) ResetEdge(name string) error {
	switch name {
	case transactioncategory.EdgeHousehold:
		m.ResetHousehold()
		return nil
	case transactioncategory.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown TransactionCategory edge %s", name)
}

// TransactionEntryMutation represents an operation that mutates the TransactionEntry nodes in the graph.
type TransactionEntryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	amount             *decimal.Decimal
	addamount          *decimal.Decimal
	clearedFields      map[string]struct{}
	household          *int
	clearedhousehold   bool
	account            *int
	clearedaccount     bool
	currency           *int
	clearedcurrency    bool
	transaction        *int
	clearedtransaction bool
	done               bool
	oldValue           func(context.Context) (*TransactionEntry, error)
	predicates         []predicate.TransactionEntry
}

var _ ent.Mutation = (*TransactionEntryMutation)(nil)

// transactionentryOption allows management of the mutation configuration using functional options.
type transactionentryOption func(*TransactionEntryMutation)

// newTransactionEntryMutation creates new mutation for the TransactionEntry entity.
func newTransactionEntryMutation(c config, op Op, opts ...transactionentryOption) *TransactionEntryMutation {
	m := &TransactionEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionEntryID sets the ID field of the mutation.
func withTransactionEntryID(id int) transactionentryOption {
	return func(m *TransactionEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionEntry
		)
		m.oldValue = func(ctx context.Context) (*TransactionEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionEntry sets the old TransactionEntry of the mutation.
func withTransactionEntry(node *TransactionEntry) transactionentryOption {
	return func(m *TransactionEntryMutation) {
		m.oldValue = func(context.Context) (*TransactionEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransactionEntryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransactionEntryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransactionEntryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransactionEntryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransactionEntryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransactionEntryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetHouseholdID sets the "household_id" field.
func (m *TransactionEntryMutation) SetHouseholdID(i int) {
	m.household = &i
}

// HouseholdID returns the value of the "household_id" field in the mutation.
func (m *TransactionEntryMutation) HouseholdID() (r int, exists bool) {
	v := m.household
	if v == nil {
		return
	}
	return *v, true
}

// OldHouseholdID returns the old "household_id" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldHouseholdID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHouseholdID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHouseholdID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHouseholdID: %w", err)
	}
	return oldValue.HouseholdID, nil
}

// ResetHouseholdID resets all changes to the "household_id" field.
func (m *TransactionEntryMutation) ResetHouseholdID() {
	m.household = nil
}

// SetAmount sets the "amount" field.
func (m *TransactionEntryMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionEntryMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *TransactionEntryMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionEntryMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionEntryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetAccountID sets the "account_id" field.
func (m *TransactionEntryMutation) SetAccountID(i int) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *TransactionEntryMutation) AccountID() (r int, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *TransactionEntryMutation) ResetAccountID() {
	m.account = nil
}

// SetCurrencyID sets the "currency_id" field.
func (m *TransactionEntryMutation) SetCurrencyID(i int) {
	m.currency = &i
}

// CurrencyID returns the value of the "currency_id" field in the mutation.
func (m *TransactionEntryMutation) CurrencyID() (r int, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyID returns the old "currency_id" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldCurrencyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyID: %w", err)
	}
	return oldValue.CurrencyID, nil
}

// ResetCurrencyID resets all changes to the "currency_id" field.
func (m *TransactionEntryMutation) ResetCurrencyID() {
	m.currency = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *TransactionEntryMutation) SetTransactionID(i int) {
	m.transaction = &i
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *TransactionEntryMutation) TransactionID() (r int, exists bool) {
	v := m.transaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldTransactionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *TransactionEntryMutation) ResetTransactionID() {
	m.transaction = nil
}

// ClearHousehold clears the "household" edge to the Household entity.
func (m *TransactionEntryMutation) ClearHousehold() {
	m.clearedhousehold = true
	m.clearedFields[transactionentry.FieldHouseholdID] = struct{}{}
}

// HouseholdCleared reports if the "household" edge to the Household entity was cleared.
func (m *TransactionEntryMutation) HouseholdCleared() bool {
	return m.clearedhousehold
}

// HouseholdIDs returns the "household" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HouseholdID instead. It exists only for internal usage by the builders.
func (m *TransactionEntryMutation) HouseholdIDs() (ids []int) {
	if id := m.household; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHousehold resets all changes to the "household" edge.
func (m *TransactionEntryMutation) ResetHousehold() {
	m.household = nil
	m.clearedhousehold = false
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *TransactionEntryMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[transactionentry.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *TransactionEntryMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *TransactionEntryMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *TransactionEntryMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearCurrency clears the "currency" edge to the Currency entity.
func (m *TransactionEntryMutation) ClearCurrency() {
	m.clearedcurrency = true
	m.clearedFields[transactionentry.FieldCurrencyID] = struct{}{}
}

// CurrencyCleared reports if the "currency" edge to the Currency entity was cleared.
func (m *TransactionEntryMutation) CurrencyCleared() bool {
	return m.clearedcurrency
}

// CurrencyIDs returns the "currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyID instead. It exists only for internal usage by the builders.
func (m *TransactionEntryMutation) CurrencyIDs() (ids []int) {
	if id := m.currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrency resets all changes to the "currency" edge.
func (m *TransactionEntryMutation) ResetCurrency() {
	m.currency = nil
	m.clearedcurrency = false
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *TransactionEntryMutation) ClearTransaction() {
	m.clearedtransaction = true
	m.clearedFields[transactionentry.FieldTransactionID] = struct{}{}
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *TransactionEntryMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *TransactionEntryMutation) TransactionIDs() (ids []int) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *TransactionEntryMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// Where appends a list predicates to the TransactionEntryMutation builder.
func (m *TransactionEntryMutation) Where(ps ...predicate.TransactionEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransactionEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransactionEntry).
func (m *TransactionEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionEntryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, transactionentry.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transactionentry.FieldUpdateTime)
	}
	if m.household != nil {
		fields = append(fields, transactionentry.FieldHouseholdID)
	}
	if m.amount != nil {
		fields = append(fields, transactionentry.FieldAmount)
	}
	if m.account != nil {
		fields = append(fields, transactionentry.FieldAccountID)
	}
	if m.currency != nil {
		fields = append(fields, transactionentry.FieldCurrencyID)
	}
	if m.transaction != nil {
		fields = append(fields, transactionentry.FieldTransactionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionentry.FieldCreateTime:
		return m.CreateTime()
	case transactionentry.FieldUpdateTime:
		return m.UpdateTime()
	case transactionentry.FieldHouseholdID:
		return m.HouseholdID()
	case transactionentry.FieldAmount:
		return m.Amount()
	case transactionentry.FieldAccountID:
		return m.AccountID()
	case transactionentry.FieldCurrencyID:
		return m.CurrencyID()
	case transactionentry.FieldTransactionID:
		return m.TransactionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionentry.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transactionentry.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transactionentry.FieldHouseholdID:
		return m.OldHouseholdID(ctx)
	case transactionentry.FieldAmount:
		return m.OldAmount(ctx)
	case transactionentry.FieldAccountID:
		return m.OldAccountID(ctx)
	case transactionentry.FieldCurrencyID:
		return m.OldCurrencyID(ctx)
	case transactionentry.FieldTransactionID:
		return m.OldTransactionID(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionentry.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transactionentry.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transactionentry.FieldHouseholdID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHouseholdID(v)
		return nil
	case transactionentry.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transactionentry.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case transactionentry.FieldCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyID(v)
		return nil
	case transactionentry.FieldTransactionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionEntryMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transactionentry.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transactionentry.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transactionentry.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransactionEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionEntryMutation) ResetField(name string) error {
	switch name {
	case transactionentry.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transactionentry.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transactionentry.FieldHouseholdID:
		m.ResetHouseholdID()
		return nil
	case transactionentry.FieldAmount:
		m.ResetAmount()
		return nil
	case transactionentry.FieldAccountID:
		m.ResetAccountID()
		return nil
	case transactionentry.FieldCurrencyID:
		m.ResetCurrencyID()
		return nil
	case transactionentry.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.household != nil {
		edges = append(edges, transactionentry.EdgeHousehold)
	}
	if m.account != nil {
		edges = append(edges, transactionentry.EdgeAccount)
	}
	if m.currency != nil {
		edges = append(edges, transactionentry.EdgeCurrency)
	}
	if m.transaction != nil {
		edges = append(edges, transactionentry.EdgeTransaction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactionentry.EdgeHousehold:
		if id := m.household; id != nil {
			return []ent.Value{*id}
		}
	case transactionentry.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case transactionentry.EdgeCurrency:
		if id := m.currency; id != nil {
			return []ent.Value{*id}
		}
	case transactionentry.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedhousehold {
		edges = append(edges, transactionentry.EdgeHousehold)
	}
	if m.clearedaccount {
		edges = append(edges, transactionentry.EdgeAccount)
	}
	if m.clearedcurrency {
		edges = append(edges, transactionentry.EdgeCurrency)
	}
	if m.clearedtransaction {
		edges = append(edges, transactionentry.EdgeTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case transactionentry.EdgeHousehold:
		return m.clearedhousehold
	case transactionentry.EdgeAccount:
		return m.clearedaccount
	case transactionentry.EdgeCurrency:
		return m.clearedcurrency
	case transactionentry.EdgeTransaction:
		return m.clearedtransaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionEntryMutation) ClearEdge(name string) error {
	switch name {
	case transactionentry.EdgeHousehold:
		m.ClearHousehold()
		return nil
	case transactionentry.EdgeAccount:
		m.ClearAccount()
		return nil
	case transactionentry.EdgeCurrency:
		m.ClearCurrency()
		return nil
	case transactionentry.EdgeTransaction:
		m.ClearTransaction()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionEntryMutation) ResetEdge(name string) error {
	switch name {
	case transactionentry.EdgeHousehold:
		m.ResetHousehold()
		return nil
	case transactionentry.EdgeAccount:
		m.ResetAccount()
		return nil
	case transactionentry.EdgeCurrency:
		m.ResetCurrency()
		return nil
	case transactionentry.EdgeTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	email                  *string
	name                   *string
	clearedFields          map[string]struct{}
	households             map[int]struct{}
	removedhouseholds      map[int]struct{}
	clearedhouseholds      bool
	accounts               map[int]struct{}
	removedaccounts        map[int]struct{}
	clearedaccounts        bool
	transactions           map[int]struct{}
	removedtransactions    map[int]struct{}
	clearedtransactions    bool
	user_keys              map[int]struct{}
	removeduser_keys       map[int]struct{}
	cleareduser_keys       bool
	user_households        map[int]struct{}
	removeduser_households map[int]struct{}
	cleareduser_households bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// AddHouseholdIDs adds the "households" edge to the Household entity by ids.
func (m *UserMutation) AddHouseholdIDs(ids ...int) {
	if m.households == nil {
		m.households = make(map[int]struct{})
	}
	for i := range ids {
		m.households[ids[i]] = struct{}{}
	}
}

// ClearHouseholds clears the "households" edge to the Household entity.
func (m *UserMutation) ClearHouseholds() {
	m.clearedhouseholds = true
}

// HouseholdsCleared reports if the "households" edge to the Household entity was cleared.
func (m *UserMutation) HouseholdsCleared() bool {
	return m.clearedhouseholds
}

// RemoveHouseholdIDs removes the "households" edge to the Household entity by IDs.
func (m *UserMutation) RemoveHouseholdIDs(ids ...int) {
	if m.removedhouseholds == nil {
		m.removedhouseholds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.households, ids[i])
		m.removedhouseholds[ids[i]] = struct{}{}
	}
}

// RemovedHouseholds returns the removed IDs of the "households" edge to the Household entity.
func (m *UserMutation) RemovedHouseholdsIDs() (ids []int) {
	for id := range m.removedhouseholds {
		ids = append(ids, id)
	}
	return
}

// HouseholdsIDs returns the "households" edge IDs in the mutation.
func (m *UserMutation) HouseholdsIDs() (ids []int) {
	for id := range m.households {
		ids = append(ids, id)
	}
	return
}

// ResetHouseholds resets all changes to the "households" edge.
func (m *UserMutation) ResetHouseholds() {
	m.households = nil
	m.clearedhouseholds = false
	m.removedhouseholds = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *UserMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *UserMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *UserMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *UserMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *UserMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *UserMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *UserMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *UserMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *UserMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *UserMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *UserMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *UserMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *UserMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *UserMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddUserKeyIDs adds the "user_keys" edge to the UserKey entity by ids.
func (m *UserMutation) AddUserKeyIDs(ids ...int) {
	if m.user_keys == nil {
		m.user_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.user_keys[ids[i]] = struct{}{}
	}
}

// ClearUserKeys clears the "user_keys" edge to the UserKey entity.
func (m *UserMutation) ClearUserKeys() {
	m.cleareduser_keys = true
}

// UserKeysCleared reports if the "user_keys" edge to the UserKey entity was cleared.
func (m *UserMutation) UserKeysCleared() bool {
	return m.cleareduser_keys
}

// RemoveUserKeyIDs removes the "user_keys" edge to the UserKey entity by IDs.
func (m *UserMutation) RemoveUserKeyIDs(ids ...int) {
	if m.removeduser_keys == nil {
		m.removeduser_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_keys, ids[i])
		m.removeduser_keys[ids[i]] = struct{}{}
	}
}

// RemovedUserKeys returns the removed IDs of the "user_keys" edge to the UserKey entity.
func (m *UserMutation) RemovedUserKeysIDs() (ids []int) {
	for id := range m.removeduser_keys {
		ids = append(ids, id)
	}
	return
}

// UserKeysIDs returns the "user_keys" edge IDs in the mutation.
func (m *UserMutation) UserKeysIDs() (ids []int) {
	for id := range m.user_keys {
		ids = append(ids, id)
	}
	return
}

// ResetUserKeys resets all changes to the "user_keys" edge.
func (m *UserMutation) ResetUserKeys() {
	m.user_keys = nil
	m.cleareduser_keys = false
	m.removeduser_keys = nil
}

// AddUserHouseholdIDs adds the "user_households" edge to the UserHousehold entity by ids.
func (m *UserMutation) AddUserHouseholdIDs(ids ...int) {
	if m.user_households == nil {
		m.user_households = make(map[int]struct{})
	}
	for i := range ids {
		m.user_households[ids[i]] = struct{}{}
	}
}

// ClearUserHouseholds clears the "user_households" edge to the UserHousehold entity.
func (m *UserMutation) ClearUserHouseholds() {
	m.cleareduser_households = true
}

// UserHouseholdsCleared reports if the "user_households" edge to the UserHousehold entity was cleared.
func (m *UserMutation) UserHouseholdsCleared() bool {
	return m.cleareduser_households
}

// RemoveUserHouseholdIDs removes the "user_households" edge to the UserHousehold entity by IDs.
func (m *UserMutation) RemoveUserHouseholdIDs(ids ...int) {
	if m.removeduser_households == nil {
		m.removeduser_households = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_households, ids[i])
		m.removeduser_households[ids[i]] = struct{}{}
	}
}

// RemovedUserHouseholds returns the removed IDs of the "user_households" edge to the UserHousehold entity.
func (m *UserMutation) RemovedUserHouseholdsIDs() (ids []int) {
	for id := range m.removeduser_households {
		ids = append(ids, id)
	}
	return
}

// UserHouseholdsIDs returns the "user_households" edge IDs in the mutation.
func (m *UserMutation) UserHouseholdsIDs() (ids []int) {
	for id := range m.user_households {
		ids = append(ids, id)
	}
	return
}

// ResetUserHouseholds resets all changes to the "user_households" edge.
func (m *UserMutation) ResetUserHouseholds() {
	m.user_households = nil
	m.cleareduser_households = false
	m.removeduser_households = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.households != nil {
		edges = append(edges, user.EdgeHouseholds)
	}
	if m.accounts != nil {
		edges = append(edges, user.EdgeAccounts)
	}
	if m.transactions != nil {
		edges = append(edges, user.EdgeTransactions)
	}
	if m.user_keys != nil {
		edges = append(edges, user.EdgeUserKeys)
	}
	if m.user_households != nil {
		edges = append(edges, user.EdgeUserHouseholds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeHouseholds:
		ids := make([]ent.Value, 0, len(m.households))
		for id := range m.households {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserKeys:
		ids := make([]ent.Value, 0, len(m.user_keys))
		for id := range m.user_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHouseholds:
		ids := make([]ent.Value, 0, len(m.user_households))
		for id := range m.user_households {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedhouseholds != nil {
		edges = append(edges, user.EdgeHouseholds)
	}
	if m.removedaccounts != nil {
		edges = append(edges, user.EdgeAccounts)
	}
	if m.removedtransactions != nil {
		edges = append(edges, user.EdgeTransactions)
	}
	if m.removeduser_keys != nil {
		edges = append(edges, user.EdgeUserKeys)
	}
	if m.removeduser_households != nil {
		edges = append(edges, user.EdgeUserHouseholds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeHouseholds:
		ids := make([]ent.Value, 0, len(m.removedhouseholds))
		for id := range m.removedhouseholds {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserKeys:
		ids := make([]ent.Value, 0, len(m.removeduser_keys))
		for id := range m.removeduser_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHouseholds:
		ids := make([]ent.Value, 0, len(m.removeduser_households))
		for id := range m.removeduser_households {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedhouseholds {
		edges = append(edges, user.EdgeHouseholds)
	}
	if m.clearedaccounts {
		edges = append(edges, user.EdgeAccounts)
	}
	if m.clearedtransactions {
		edges = append(edges, user.EdgeTransactions)
	}
	if m.cleareduser_keys {
		edges = append(edges, user.EdgeUserKeys)
	}
	if m.cleareduser_households {
		edges = append(edges, user.EdgeUserHouseholds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeHouseholds:
		return m.clearedhouseholds
	case user.EdgeAccounts:
		return m.clearedaccounts
	case user.EdgeTransactions:
		return m.clearedtransactions
	case user.EdgeUserKeys:
		return m.cleareduser_keys
	case user.EdgeUserHouseholds:
		return m.cleareduser_households
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeHouseholds:
		m.ResetHouseholds()
		return nil
	case user.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case user.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case user.EdgeUserKeys:
		m.ResetUserKeys()
		return nil
	case user.EdgeUserHouseholds:
		m.ResetUserHouseholds()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserHouseholdMutation represents an operation that mutates the UserHousehold nodes in the graph.
type UserHouseholdMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	role             *userhousehold.Role
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	household        *int
	clearedhousehold bool
	done             bool
	oldValue         func(context.Context) (*UserHousehold, error)
	predicates       []predicate.UserHousehold
}

var _ ent.Mutation = (*UserHouseholdMutation)(nil)

// userhouseholdOption allows management of the mutation configuration using functional options.
type userhouseholdOption func(*UserHouseholdMutation)

// newUserHouseholdMutation creates new mutation for the UserHousehold entity.
func newUserHouseholdMutation(c config, op Op, opts ...userhouseholdOption) *UserHouseholdMutation {
	m := &UserHouseholdMutation{
		config:        c,
		op:            op,
		typ:           TypeUserHousehold,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserHouseholdID sets the ID field of the mutation.
func withUserHouseholdID(id int) userhouseholdOption {
	return func(m *UserHouseholdMutation) {
		var (
			err   error
			once  sync.Once
			value *UserHousehold
		)
		m.oldValue = func(ctx context.Context) (*UserHousehold, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserHousehold.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserHousehold sets the old UserHousehold of the mutation.
func withUserHousehold(node *UserHousehold) userhouseholdOption {
	return func(m *UserHouseholdMutation) {
		m.oldValue = func(context.Context) (*UserHousehold, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserHouseholdMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserHouseholdMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserHouseholdMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserHouseholdMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserHousehold.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserHouseholdMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserHouseholdMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserHousehold entity.
// If the UserHousehold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHouseholdMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserHouseholdMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserHouseholdMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserHouseholdMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserHousehold entity.
// If the UserHousehold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHouseholdMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserHouseholdMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUserID sets the "user_id" field.
func (m *UserHouseholdMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserHouseholdMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserHousehold entity.
// If the UserHousehold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHouseholdMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserHouseholdMutation) ResetUserID() {
	m.user = nil
}

// SetHouseholdID sets the "household_id" field.
func (m *UserHouseholdMutation) SetHouseholdID(i int) {
	m.household = &i
}

// HouseholdID returns the value of the "household_id" field in the mutation.
func (m *UserHouseholdMutation) HouseholdID() (r int, exists bool) {
	v := m.household
	if v == nil {
		return
	}
	return *v, true
}

// OldHouseholdID returns the old "household_id" field's value of the UserHousehold entity.
// If the UserHousehold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHouseholdMutation) OldHouseholdID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHouseholdID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHouseholdID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHouseholdID: %w", err)
	}
	return oldValue.HouseholdID, nil
}

// ResetHouseholdID resets all changes to the "household_id" field.
func (m *UserHouseholdMutation) ResetHouseholdID() {
	m.household = nil
}

// SetRole sets the "role" field.
func (m *UserHouseholdMutation) SetRole(u userhousehold.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserHouseholdMutation) Role() (r userhousehold.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the UserHousehold entity.
// If the UserHousehold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHouseholdMutation) OldRole(ctx context.Context) (v userhousehold.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserHouseholdMutation) ResetRole() {
	m.role = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserHouseholdMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userhousehold.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserHouseholdMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserHouseholdMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserHouseholdMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearHousehold clears the "household" edge to the Household entity.
func (m *UserHouseholdMutation) ClearHousehold() {
	m.clearedhousehold = true
	m.clearedFields[userhousehold.FieldHouseholdID] = struct{}{}
}

// HouseholdCleared reports if the "household" edge to the Household entity was cleared.
func (m *UserHouseholdMutation) HouseholdCleared() bool {
	return m.clearedhousehold
}

// HouseholdIDs returns the "household" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HouseholdID instead. It exists only for internal usage by the builders.
func (m *UserHouseholdMutation) HouseholdIDs() (ids []int) {
	if id := m.household; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHousehold resets all changes to the "household" edge.
func (m *UserHouseholdMutation) ResetHousehold() {
	m.household = nil
	m.clearedhousehold = false
}

// Where appends a list predicates to the UserHouseholdMutation builder.
func (m *UserHouseholdMutation) Where(ps ...predicate.UserHousehold) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserHouseholdMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserHouseholdMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserHousehold, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserHouseholdMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserHouseholdMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserHousehold).
func (m *UserHouseholdMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserHouseholdMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, userhousehold.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userhousehold.FieldUpdateTime)
	}
	if m.user != nil {
		fields = append(fields, userhousehold.FieldUserID)
	}
	if m.household != nil {
		fields = append(fields, userhousehold.FieldHouseholdID)
	}
	if m.role != nil {
		fields = append(fields, userhousehold.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserHouseholdMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userhousehold.FieldCreateTime:
		return m.CreateTime()
	case userhousehold.FieldUpdateTime:
		return m.UpdateTime()
	case userhousehold.FieldUserID:
		return m.UserID()
	case userhousehold.FieldHouseholdID:
		return m.HouseholdID()
	case userhousehold.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserHouseholdMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userhousehold.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userhousehold.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userhousehold.FieldUserID:
		return m.OldUserID(ctx)
	case userhousehold.FieldHouseholdID:
		return m.OldHouseholdID(ctx)
	case userhousehold.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown UserHousehold field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHouseholdMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userhousehold.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userhousehold.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userhousehold.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userhousehold.FieldHouseholdID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHouseholdID(v)
		return nil
	case userhousehold.FieldRole:
		v, ok := value.(userhousehold.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown UserHousehold field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserHouseholdMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserHouseholdMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHouseholdMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserHousehold numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserHouseholdMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserHouseholdMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserHouseholdMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserHousehold nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserHouseholdMutation) ResetField(name string) error {
	switch name {
	case userhousehold.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userhousehold.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userhousehold.FieldUserID:
		m.ResetUserID()
		return nil
	case userhousehold.FieldHouseholdID:
		m.ResetHouseholdID()
		return nil
	case userhousehold.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserHousehold field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserHouseholdMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userhousehold.EdgeUser)
	}
	if m.household != nil {
		edges = append(edges, userhousehold.EdgeHousehold)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserHouseholdMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userhousehold.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userhousehold.EdgeHousehold:
		if id := m.household; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserHouseholdMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserHouseholdMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserHouseholdMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userhousehold.EdgeUser)
	}
	if m.clearedhousehold {
		edges = append(edges, userhousehold.EdgeHousehold)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserHouseholdMutation) EdgeCleared(name string) bool {
	switch name {
	case userhousehold.EdgeUser:
		return m.cleareduser
	case userhousehold.EdgeHousehold:
		return m.clearedhousehold
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserHouseholdMutation) ClearEdge(name string) error {
	switch name {
	case userhousehold.EdgeUser:
		m.ClearUser()
		return nil
	case userhousehold.EdgeHousehold:
		m.ClearHousehold()
		return nil
	}
	return fmt.Errorf("unknown UserHousehold unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserHouseholdMutation) ResetEdge(name string) error {
	switch name {
	case userhousehold.EdgeUser:
		m.ResetUser()
		return nil
	case userhousehold.EdgeHousehold:
		m.ResetHousehold()
		return nil
	}
	return fmt.Errorf("unknown UserHousehold edge %s", name)
}

// UserKeyMutation represents an operation that mutates the UserKey nodes in the graph.
type UserKeyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	provider      *userkey.Provider
	key           *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserKey, error)
	predicates    []predicate.UserKey
}

var _ ent.Mutation = (*UserKeyMutation)(nil)

// userkeyOption allows management of the mutation configuration using functional options.
type userkeyOption func(*UserKeyMutation)

// newUserKeyMutation creates new mutation for the UserKey entity.
func newUserKeyMutation(c config, op Op, opts ...userkeyOption) *UserKeyMutation {
	m := &UserKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeUserKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserKeyID sets the ID field of the mutation.
func withUserKeyID(id int) userkeyOption {
	return func(m *UserKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *UserKey
		)
		m.oldValue = func(ctx context.Context) (*UserKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserKey sets the old UserKey of the mutation.
func withUserKey(node *UserKey) userkeyOption {
	return func(m *UserKeyMutation) {
		m.oldValue = func(context.Context) (*UserKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserKeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserKeyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserKeyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserKeyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserKeyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserKeyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserKeyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProvider sets the "provider" field.
func (m *UserKeyMutation) SetProvider(u userkey.Provider) {
	m.provider = &u
}

// Provider returns the value of the "provider" field in the mutation.
func (m *UserKeyMutation) Provider() (r userkey.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldProvider(ctx context.Context) (v userkey.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *UserKeyMutation) ResetProvider() {
	m.provider = nil
}

// SetKey sets the "key" field.
func (m *UserKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UserKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UserKeyMutation) ResetKey() {
	m.key = nil
}

// SetUserID sets the "user_id" field.
func (m *UserKeyMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserKeyMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserKeyMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userkey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserKeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserKeyMutation builder.
func (m *UserKeyMutation) Where(ps ...predicate.UserKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserKey).
func (m *UserKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserKeyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, userkey.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userkey.FieldUpdateTime)
	}
	if m.provider != nil {
		fields = append(fields, userkey.FieldProvider)
	}
	if m.key != nil {
		fields = append(fields, userkey.FieldKey)
	}
	if m.user != nil {
		fields = append(fields, userkey.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userkey.FieldCreateTime:
		return m.CreateTime()
	case userkey.FieldUpdateTime:
		return m.UpdateTime()
	case userkey.FieldProvider:
		return m.Provider()
	case userkey.FieldKey:
		return m.Key()
	case userkey.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userkey.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userkey.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userkey.FieldProvider:
		return m.OldProvider(ctx)
	case userkey.FieldKey:
		return m.OldKey(ctx)
	case userkey.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown UserKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userkey.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userkey.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userkey.FieldProvider:
		v, ok := value.(userkey.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case userkey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case userkey.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserKeyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserKeyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserKeyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserKeyMutation) ResetField(name string) error {
	switch name {
	case userkey.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userkey.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userkey.FieldProvider:
		m.ResetProvider()
		return nil
	case userkey.FieldKey:
		m.ResetKey()
		return nil
	case userkey.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown UserKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userkey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userkey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userkey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case userkey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserKeyMutation) ClearEdge(name string) error {
	switch name {
	case userkey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserKeyMutation) ResetEdge(name string) error {
	switch name {
	case userkey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserKey edge %s", name)
}
