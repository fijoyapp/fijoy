// Code generated by ent, DO NOT EDIT.

package ent

import (
	"beavermoney.app/ent/account"
	"beavermoney.app/ent/cryptoquotecache"
	"beavermoney.app/ent/currency"
	"beavermoney.app/ent/fxratecache"
	"beavermoney.app/ent/household"
	"beavermoney.app/ent/investment"
	"beavermoney.app/ent/investmentlot"
	"beavermoney.app/ent/predicate"
	"beavermoney.app/ent/stockquotecache"
	"beavermoney.app/ent/transaction"
	"beavermoney.app/ent/transactioncategory"
	"beavermoney.app/ent/transactionentry"
	"beavermoney.app/ent/user"
	"beavermoney.app/ent/userhousehold"
	"beavermoney.app/ent/userkey"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/entql"
	"entgo.io/ent/schema/field"
)

// schemaGraph holds a representation of ent/schema at runtime.
var schemaGraph = func() *sqlgraph.Schema {
	graph := &sqlgraph.Schema{Nodes: make([]*sqlgraph.Node, 14)}
	graph.Nodes[0] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   account.Table,
			Columns: account.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: account.FieldID,
			},
		},
		Type: "Account",
		Fields: map[string]*sqlgraph.FieldSpec{
			account.FieldCreateTime:  {Type: field.TypeTime, Column: account.FieldCreateTime},
			account.FieldUpdateTime:  {Type: field.TypeTime, Column: account.FieldUpdateTime},
			account.FieldHouseholdID: {Type: field.TypeInt, Column: account.FieldHouseholdID},
			account.FieldName:        {Type: field.TypeString, Column: account.FieldName},
			account.FieldType:        {Type: field.TypeEnum, Column: account.FieldType},
			account.FieldBalance:     {Type: field.TypeFloat64, Column: account.FieldBalance},
			account.FieldIcon:        {Type: field.TypeString, Column: account.FieldIcon},
			account.FieldValue:       {Type: field.TypeFloat64, Column: account.FieldValue},
			account.FieldFxRate:      {Type: field.TypeFloat64, Column: account.FieldFxRate},
			account.FieldCurrencyID:  {Type: field.TypeInt, Column: account.FieldCurrencyID},
			account.FieldUserID:      {Type: field.TypeInt, Column: account.FieldUserID},
		},
	}
	graph.Nodes[1] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   cryptoquotecache.Table,
			Columns: cryptoquotecache.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: cryptoquotecache.FieldID,
			},
		},
		Type: "CryptoQuoteCache",
		Fields: map[string]*sqlgraph.FieldSpec{
			cryptoquotecache.FieldCreateTime: {Type: field.TypeTime, Column: cryptoquotecache.FieldCreateTime},
			cryptoquotecache.FieldUpdateTime: {Type: field.TypeTime, Column: cryptoquotecache.FieldUpdateTime},
			cryptoquotecache.FieldSymbol:     {Type: field.TypeString, Column: cryptoquotecache.FieldSymbol},
			cryptoquotecache.FieldValue:      {Type: field.TypeFloat64, Column: cryptoquotecache.FieldValue},
			cryptoquotecache.FieldDate:       {Type: field.TypeTime, Column: cryptoquotecache.FieldDate},
		},
	}
	graph.Nodes[2] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   currency.Table,
			Columns: currency.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: currency.FieldID,
			},
		},
		Type: "Currency",
		Fields: map[string]*sqlgraph.FieldSpec{
			currency.FieldCode: {Type: field.TypeString, Column: currency.FieldCode},
		},
	}
	graph.Nodes[3] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   fxratecache.Table,
			Columns: fxratecache.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: fxratecache.FieldID,
			},
		},
		Type: "FXRateCache",
		Fields: map[string]*sqlgraph.FieldSpec{
			fxratecache.FieldCreateTime:     {Type: field.TypeTime, Column: fxratecache.FieldCreateTime},
			fxratecache.FieldUpdateTime:     {Type: field.TypeTime, Column: fxratecache.FieldUpdateTime},
			fxratecache.FieldFromCurrencyID: {Type: field.TypeInt, Column: fxratecache.FieldFromCurrencyID},
			fxratecache.FieldToCurrencyID:   {Type: field.TypeInt, Column: fxratecache.FieldToCurrencyID},
			fxratecache.FieldValue:          {Type: field.TypeFloat64, Column: fxratecache.FieldValue},
			fxratecache.FieldDate:           {Type: field.TypeTime, Column: fxratecache.FieldDate},
		},
	}
	graph.Nodes[4] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   household.Table,
			Columns: household.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: household.FieldID,
			},
		},
		Type: "Household",
		Fields: map[string]*sqlgraph.FieldSpec{
			household.FieldCreateTime: {Type: field.TypeTime, Column: household.FieldCreateTime},
			household.FieldUpdateTime: {Type: field.TypeTime, Column: household.FieldUpdateTime},
			household.FieldName:       {Type: field.TypeString, Column: household.FieldName},
			household.FieldLocale:     {Type: field.TypeString, Column: household.FieldLocale},
			household.FieldCurrencyID: {Type: field.TypeInt, Column: household.FieldCurrencyID},
		},
	}
	graph.Nodes[5] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   investment.Table,
			Columns: investment.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: investment.FieldID,
			},
		},
		Type: "Investment",
		Fields: map[string]*sqlgraph.FieldSpec{
			investment.FieldCreateTime:  {Type: field.TypeTime, Column: investment.FieldCreateTime},
			investment.FieldUpdateTime:  {Type: field.TypeTime, Column: investment.FieldUpdateTime},
			investment.FieldHouseholdID: {Type: field.TypeInt, Column: investment.FieldHouseholdID},
			investment.FieldName:        {Type: field.TypeString, Column: investment.FieldName},
			investment.FieldType:        {Type: field.TypeEnum, Column: investment.FieldType},
			investment.FieldSymbol:      {Type: field.TypeString, Column: investment.FieldSymbol},
			investment.FieldAmount:      {Type: field.TypeFloat64, Column: investment.FieldAmount},
			investment.FieldQuote:       {Type: field.TypeFloat64, Column: investment.FieldQuote},
			investment.FieldValue:       {Type: field.TypeFloat64, Column: investment.FieldValue},
			investment.FieldAccountID:   {Type: field.TypeInt, Column: investment.FieldAccountID},
			investment.FieldCurrencyID:  {Type: field.TypeInt, Column: investment.FieldCurrencyID},
		},
	}
	graph.Nodes[6] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   investmentlot.Table,
			Columns: investmentlot.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: investmentlot.FieldID,
			},
		},
		Type: "InvestmentLot",
		Fields: map[string]*sqlgraph.FieldSpec{
			investmentlot.FieldCreateTime:    {Type: field.TypeTime, Column: investmentlot.FieldCreateTime},
			investmentlot.FieldUpdateTime:    {Type: field.TypeTime, Column: investmentlot.FieldUpdateTime},
			investmentlot.FieldHouseholdID:   {Type: field.TypeInt, Column: investmentlot.FieldHouseholdID},
			investmentlot.FieldAmount:        {Type: field.TypeFloat64, Column: investmentlot.FieldAmount},
			investmentlot.FieldPrice:         {Type: field.TypeFloat64, Column: investmentlot.FieldPrice},
			investmentlot.FieldInvestmentID:  {Type: field.TypeInt, Column: investmentlot.FieldInvestmentID},
			investmentlot.FieldTransactionID: {Type: field.TypeInt, Column: investmentlot.FieldTransactionID},
		},
	}
	graph.Nodes[7] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   stockquotecache.Table,
			Columns: stockquotecache.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: stockquotecache.FieldID,
			},
		},
		Type: "StockQuoteCache",
		Fields: map[string]*sqlgraph.FieldSpec{
			stockquotecache.FieldCreateTime: {Type: field.TypeTime, Column: stockquotecache.FieldCreateTime},
			stockquotecache.FieldUpdateTime: {Type: field.TypeTime, Column: stockquotecache.FieldUpdateTime},
			stockquotecache.FieldSymbol:     {Type: field.TypeString, Column: stockquotecache.FieldSymbol},
			stockquotecache.FieldValue:      {Type: field.TypeFloat64, Column: stockquotecache.FieldValue},
			stockquotecache.FieldDate:       {Type: field.TypeTime, Column: stockquotecache.FieldDate},
		},
	}
	graph.Nodes[8] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   transaction.Table,
			Columns: transaction.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: transaction.FieldID,
			},
		},
		Type: "Transaction",
		Fields: map[string]*sqlgraph.FieldSpec{
			transaction.FieldCreateTime:  {Type: field.TypeTime, Column: transaction.FieldCreateTime},
			transaction.FieldUpdateTime:  {Type: field.TypeTime, Column: transaction.FieldUpdateTime},
			transaction.FieldHouseholdID: {Type: field.TypeInt, Column: transaction.FieldHouseholdID},
			transaction.FieldDescription: {Type: field.TypeString, Column: transaction.FieldDescription},
			transaction.FieldDatetime:    {Type: field.TypeTime, Column: transaction.FieldDatetime},
			transaction.FieldUserID:      {Type: field.TypeInt, Column: transaction.FieldUserID},
			transaction.FieldCategoryID:  {Type: field.TypeInt, Column: transaction.FieldCategoryID},
		},
	}
	graph.Nodes[9] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   transactioncategory.Table,
			Columns: transactioncategory.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: transactioncategory.FieldID,
			},
		},
		Type: "TransactionCategory",
		Fields: map[string]*sqlgraph.FieldSpec{
			transactioncategory.FieldCreateTime:  {Type: field.TypeTime, Column: transactioncategory.FieldCreateTime},
			transactioncategory.FieldUpdateTime:  {Type: field.TypeTime, Column: transactioncategory.FieldUpdateTime},
			transactioncategory.FieldHouseholdID: {Type: field.TypeInt, Column: transactioncategory.FieldHouseholdID},
			transactioncategory.FieldName:        {Type: field.TypeString, Column: transactioncategory.FieldName},
			transactioncategory.FieldType:        {Type: field.TypeEnum, Column: transactioncategory.FieldType},
			transactioncategory.FieldIcon:        {Type: field.TypeString, Column: transactioncategory.FieldIcon},
			transactioncategory.FieldIsImmutable: {Type: field.TypeBool, Column: transactioncategory.FieldIsImmutable},
		},
	}
	graph.Nodes[10] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   transactionentry.Table,
			Columns: transactionentry.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: transactionentry.FieldID,
			},
		},
		Type: "TransactionEntry",
		Fields: map[string]*sqlgraph.FieldSpec{
			transactionentry.FieldCreateTime:    {Type: field.TypeTime, Column: transactionentry.FieldCreateTime},
			transactionentry.FieldUpdateTime:    {Type: field.TypeTime, Column: transactionentry.FieldUpdateTime},
			transactionentry.FieldHouseholdID:   {Type: field.TypeInt, Column: transactionentry.FieldHouseholdID},
			transactionentry.FieldAmount:        {Type: field.TypeFloat64, Column: transactionentry.FieldAmount},
			transactionentry.FieldAccountID:     {Type: field.TypeInt, Column: transactionentry.FieldAccountID},
			transactionentry.FieldCurrencyID:    {Type: field.TypeInt, Column: transactionentry.FieldCurrencyID},
			transactionentry.FieldTransactionID: {Type: field.TypeInt, Column: transactionentry.FieldTransactionID},
		},
	}
	graph.Nodes[11] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: user.FieldID,
			},
		},
		Type: "User",
		Fields: map[string]*sqlgraph.FieldSpec{
			user.FieldCreateTime: {Type: field.TypeTime, Column: user.FieldCreateTime},
			user.FieldUpdateTime: {Type: field.TypeTime, Column: user.FieldUpdateTime},
			user.FieldEmail:      {Type: field.TypeString, Column: user.FieldEmail},
			user.FieldName:       {Type: field.TypeString, Column: user.FieldName},
		},
	}
	graph.Nodes[12] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   userhousehold.Table,
			Columns: userhousehold.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: userhousehold.FieldID,
			},
		},
		Type: "UserHousehold",
		Fields: map[string]*sqlgraph.FieldSpec{
			userhousehold.FieldCreateTime:  {Type: field.TypeTime, Column: userhousehold.FieldCreateTime},
			userhousehold.FieldUpdateTime:  {Type: field.TypeTime, Column: userhousehold.FieldUpdateTime},
			userhousehold.FieldUserID:      {Type: field.TypeInt, Column: userhousehold.FieldUserID},
			userhousehold.FieldHouseholdID: {Type: field.TypeInt, Column: userhousehold.FieldHouseholdID},
			userhousehold.FieldRole:        {Type: field.TypeEnum, Column: userhousehold.FieldRole},
		},
	}
	graph.Nodes[13] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   userkey.Table,
			Columns: userkey.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: userkey.FieldID,
			},
		},
		Type: "UserKey",
		Fields: map[string]*sqlgraph.FieldSpec{
			userkey.FieldCreateTime: {Type: field.TypeTime, Column: userkey.FieldCreateTime},
			userkey.FieldUpdateTime: {Type: field.TypeTime, Column: userkey.FieldUpdateTime},
			userkey.FieldProvider:   {Type: field.TypeEnum, Column: userkey.FieldProvider},
			userkey.FieldKey:        {Type: field.TypeString, Column: userkey.FieldKey},
			userkey.FieldUserID:     {Type: field.TypeInt, Column: userkey.FieldUserID},
		},
	}
	graph.MustAddE(
		"household",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   account.HouseholdTable,
			Columns: []string{account.HouseholdColumn},
			Bidi:    false,
		},
		"Account",
		"Household",
	)
	graph.MustAddE(
		"currency",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   account.CurrencyTable,
			Columns: []string{account.CurrencyColumn},
			Bidi:    false,
		},
		"Account",
		"Currency",
	)
	graph.MustAddE(
		"user",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   account.UserTable,
			Columns: []string{account.UserColumn},
			Bidi:    false,
		},
		"Account",
		"User",
	)
	graph.MustAddE(
		"transaction_entries",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   account.TransactionEntriesTable,
			Columns: []string{account.TransactionEntriesColumn},
			Bidi:    false,
		},
		"Account",
		"TransactionEntry",
	)
	graph.MustAddE(
		"investments",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   account.InvestmentsTable,
			Columns: []string{account.InvestmentsColumn},
			Bidi:    false,
		},
		"Account",
		"Investment",
	)
	graph.MustAddE(
		"accounts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   currency.AccountsTable,
			Columns: []string{currency.AccountsColumn},
			Bidi:    false,
		},
		"Currency",
		"Account",
	)
	graph.MustAddE(
		"investments",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   currency.InvestmentsTable,
			Columns: []string{currency.InvestmentsColumn},
			Bidi:    false,
		},
		"Currency",
		"Investment",
	)
	graph.MustAddE(
		"transaction_entries",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   currency.TransactionEntriesTable,
			Columns: []string{currency.TransactionEntriesColumn},
			Bidi:    false,
		},
		"Currency",
		"TransactionEntry",
	)
	graph.MustAddE(
		"households",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   currency.HouseholdsTable,
			Columns: []string{currency.HouseholdsColumn},
			Bidi:    false,
		},
		"Currency",
		"Household",
	)
	graph.MustAddE(
		"fx_rate_caches_from",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   currency.FxRateCachesFromTable,
			Columns: []string{currency.FxRateCachesFromColumn},
			Bidi:    false,
		},
		"Currency",
		"FXRateCache",
	)
	graph.MustAddE(
		"fx_rate_caches_to",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   currency.FxRateCachesToTable,
			Columns: []string{currency.FxRateCachesToColumn},
			Bidi:    false,
		},
		"Currency",
		"FXRateCache",
	)
	graph.MustAddE(
		"from_currency",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   fxratecache.FromCurrencyTable,
			Columns: []string{fxratecache.FromCurrencyColumn},
			Bidi:    false,
		},
		"FXRateCache",
		"Currency",
	)
	graph.MustAddE(
		"to_currency",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   fxratecache.ToCurrencyTable,
			Columns: []string{fxratecache.ToCurrencyColumn},
			Bidi:    false,
		},
		"FXRateCache",
		"Currency",
	)
	graph.MustAddE(
		"currency",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   household.CurrencyTable,
			Columns: []string{household.CurrencyColumn},
			Bidi:    false,
		},
		"Household",
		"Currency",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   household.UsersTable,
			Columns: household.UsersPrimaryKey,
			Bidi:    false,
		},
		"Household",
		"User",
	)
	graph.MustAddE(
		"accounts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   household.AccountsTable,
			Columns: []string{household.AccountsColumn},
			Bidi:    false,
		},
		"Household",
		"Account",
	)
	graph.MustAddE(
		"transactions",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   household.TransactionsTable,
			Columns: []string{household.TransactionsColumn},
			Bidi:    false,
		},
		"Household",
		"Transaction",
	)
	graph.MustAddE(
		"investments",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   household.InvestmentsTable,
			Columns: []string{household.InvestmentsColumn},
			Bidi:    false,
		},
		"Household",
		"Investment",
	)
	graph.MustAddE(
		"investment_lots",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   household.InvestmentLotsTable,
			Columns: []string{household.InvestmentLotsColumn},
			Bidi:    false,
		},
		"Household",
		"InvestmentLot",
	)
	graph.MustAddE(
		"transaction_categories",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   household.TransactionCategoriesTable,
			Columns: []string{household.TransactionCategoriesColumn},
			Bidi:    false,
		},
		"Household",
		"TransactionCategory",
	)
	graph.MustAddE(
		"transaction_entries",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   household.TransactionEntriesTable,
			Columns: []string{household.TransactionEntriesColumn},
			Bidi:    false,
		},
		"Household",
		"TransactionEntry",
	)
	graph.MustAddE(
		"user_households",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   household.UserHouseholdsTable,
			Columns: []string{household.UserHouseholdsColumn},
			Bidi:    false,
		},
		"Household",
		"UserHousehold",
	)
	graph.MustAddE(
		"account",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   investment.AccountTable,
			Columns: []string{investment.AccountColumn},
			Bidi:    false,
		},
		"Investment",
		"Account",
	)
	graph.MustAddE(
		"household",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   investment.HouseholdTable,
			Columns: []string{investment.HouseholdColumn},
			Bidi:    false,
		},
		"Investment",
		"Household",
	)
	graph.MustAddE(
		"currency",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   investment.CurrencyTable,
			Columns: []string{investment.CurrencyColumn},
			Bidi:    false,
		},
		"Investment",
		"Currency",
	)
	graph.MustAddE(
		"investment_lots",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   investment.InvestmentLotsTable,
			Columns: []string{investment.InvestmentLotsColumn},
			Bidi:    false,
		},
		"Investment",
		"InvestmentLot",
	)
	graph.MustAddE(
		"household",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   investmentlot.HouseholdTable,
			Columns: []string{investmentlot.HouseholdColumn},
			Bidi:    false,
		},
		"InvestmentLot",
		"Household",
	)
	graph.MustAddE(
		"investment",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   investmentlot.InvestmentTable,
			Columns: []string{investmentlot.InvestmentColumn},
			Bidi:    false,
		},
		"InvestmentLot",
		"Investment",
	)
	graph.MustAddE(
		"transaction",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   investmentlot.TransactionTable,
			Columns: []string{investmentlot.TransactionColumn},
			Bidi:    false,
		},
		"InvestmentLot",
		"Transaction",
	)
	graph.MustAddE(
		"user",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   transaction.UserTable,
			Columns: []string{transaction.UserColumn},
			Bidi:    false,
		},
		"Transaction",
		"User",
	)
	graph.MustAddE(
		"household",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   transaction.HouseholdTable,
			Columns: []string{transaction.HouseholdColumn},
			Bidi:    false,
		},
		"Transaction",
		"Household",
	)
	graph.MustAddE(
		"category",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   transaction.CategoryTable,
			Columns: []string{transaction.CategoryColumn},
			Bidi:    false,
		},
		"Transaction",
		"TransactionCategory",
	)
	graph.MustAddE(
		"transaction_entries",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   transaction.TransactionEntriesTable,
			Columns: []string{transaction.TransactionEntriesColumn},
			Bidi:    false,
		},
		"Transaction",
		"TransactionEntry",
	)
	graph.MustAddE(
		"investment_lots",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   transaction.InvestmentLotsTable,
			Columns: []string{transaction.InvestmentLotsColumn},
			Bidi:    false,
		},
		"Transaction",
		"InvestmentLot",
	)
	graph.MustAddE(
		"household",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   transactioncategory.HouseholdTable,
			Columns: []string{transactioncategory.HouseholdColumn},
			Bidi:    false,
		},
		"TransactionCategory",
		"Household",
	)
	graph.MustAddE(
		"transactions",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   transactioncategory.TransactionsTable,
			Columns: []string{transactioncategory.TransactionsColumn},
			Bidi:    false,
		},
		"TransactionCategory",
		"Transaction",
	)
	graph.MustAddE(
		"household",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   transactionentry.HouseholdTable,
			Columns: []string{transactionentry.HouseholdColumn},
			Bidi:    false,
		},
		"TransactionEntry",
		"Household",
	)
	graph.MustAddE(
		"account",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   transactionentry.AccountTable,
			Columns: []string{transactionentry.AccountColumn},
			Bidi:    false,
		},
		"TransactionEntry",
		"Account",
	)
	graph.MustAddE(
		"currency",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   transactionentry.CurrencyTable,
			Columns: []string{transactionentry.CurrencyColumn},
			Bidi:    false,
		},
		"TransactionEntry",
		"Currency",
	)
	graph.MustAddE(
		"transaction",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   transactionentry.TransactionTable,
			Columns: []string{transactionentry.TransactionColumn},
			Bidi:    false,
		},
		"TransactionEntry",
		"Transaction",
	)
	graph.MustAddE(
		"households",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.HouseholdsTable,
			Columns: user.HouseholdsPrimaryKey,
			Bidi:    false,
		},
		"User",
		"Household",
	)
	graph.MustAddE(
		"accounts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.AccountsTable,
			Columns: []string{user.AccountsColumn},
			Bidi:    false,
		},
		"User",
		"Account",
	)
	graph.MustAddE(
		"transactions",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TransactionsTable,
			Columns: []string{user.TransactionsColumn},
			Bidi:    false,
		},
		"User",
		"Transaction",
	)
	graph.MustAddE(
		"user_keys",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserKeysTable,
			Columns: []string{user.UserKeysColumn},
			Bidi:    false,
		},
		"User",
		"UserKey",
	)
	graph.MustAddE(
		"user_households",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UserHouseholdsTable,
			Columns: []string{user.UserHouseholdsColumn},
			Bidi:    false,
		},
		"User",
		"UserHousehold",
	)
	graph.MustAddE(
		"user",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   userhousehold.UserTable,
			Columns: []string{userhousehold.UserColumn},
			Bidi:    false,
		},
		"UserHousehold",
		"User",
	)
	graph.MustAddE(
		"household",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   userhousehold.HouseholdTable,
			Columns: []string{userhousehold.HouseholdColumn},
			Bidi:    false,
		},
		"UserHousehold",
		"Household",
	)
	graph.MustAddE(
		"user",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   userkey.UserTable,
			Columns: []string{userkey.UserColumn},
			Bidi:    false,
		},
		"UserKey",
		"User",
	)
	return graph
}()

// predicateAdder wraps the addPredicate method.
// All update, update-one and query builders implement this interface.
type predicateAdder interface {
	addPredicate(func(s *sql.Selector))
}

// addPredicate implements the predicateAdder interface.
func (_q *AccountQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the AccountQuery builder.
func (_q *AccountQuery) Filter() *AccountFilter {
	return &AccountFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *AccountMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the AccountMutation builder.
func (m *AccountMutation) Filter() *AccountFilter {
	return &AccountFilter{config: m.config, predicateAdder: m}
}

// AccountFilter provides a generic filtering capability at runtime for AccountQuery.
type AccountFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *AccountFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[0].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *AccountFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(account.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *AccountFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(account.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *AccountFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(account.FieldUpdateTime))
}

// WhereHouseholdID applies the entql int predicate on the household_id field.
func (f *AccountFilter) WhereHouseholdID(p entql.IntP) {
	f.Where(p.Field(account.FieldHouseholdID))
}

// WhereName applies the entql string predicate on the name field.
func (f *AccountFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(account.FieldName))
}

// WhereType applies the entql string predicate on the type field.
func (f *AccountFilter) WhereType(p entql.StringP) {
	f.Where(p.Field(account.FieldType))
}

// WhereBalance applies the entql float64 predicate on the balance field.
func (f *AccountFilter) WhereBalance(p entql.Float64P) {
	f.Where(p.Field(account.FieldBalance))
}

// WhereIcon applies the entql string predicate on the icon field.
func (f *AccountFilter) WhereIcon(p entql.StringP) {
	f.Where(p.Field(account.FieldIcon))
}

// WhereValue applies the entql float64 predicate on the value field.
func (f *AccountFilter) WhereValue(p entql.Float64P) {
	f.Where(p.Field(account.FieldValue))
}

// WhereFxRate applies the entql float64 predicate on the fx_rate field.
func (f *AccountFilter) WhereFxRate(p entql.Float64P) {
	f.Where(p.Field(account.FieldFxRate))
}

// WhereCurrencyID applies the entql int predicate on the currency_id field.
func (f *AccountFilter) WhereCurrencyID(p entql.IntP) {
	f.Where(p.Field(account.FieldCurrencyID))
}

// WhereUserID applies the entql int predicate on the user_id field.
func (f *AccountFilter) WhereUserID(p entql.IntP) {
	f.Where(p.Field(account.FieldUserID))
}

// WhereHasHousehold applies a predicate to check if query has an edge household.
func (f *AccountFilter) WhereHasHousehold() {
	f.Where(entql.HasEdge("household"))
}

// WhereHasHouseholdWith applies a predicate to check if query has an edge household with a given conditions (other predicates).
func (f *AccountFilter) WhereHasHouseholdWith(preds ...predicate.Household) {
	f.Where(entql.HasEdgeWith("household", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasCurrency applies a predicate to check if query has an edge currency.
func (f *AccountFilter) WhereHasCurrency() {
	f.Where(entql.HasEdge("currency"))
}

// WhereHasCurrencyWith applies a predicate to check if query has an edge currency with a given conditions (other predicates).
func (f *AccountFilter) WhereHasCurrencyWith(preds ...predicate.Currency) {
	f.Where(entql.HasEdgeWith("currency", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUser applies a predicate to check if query has an edge user.
func (f *AccountFilter) WhereHasUser() {
	f.Where(entql.HasEdge("user"))
}

// WhereHasUserWith applies a predicate to check if query has an edge user with a given conditions (other predicates).
func (f *AccountFilter) WhereHasUserWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("user", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTransactionEntries applies a predicate to check if query has an edge transaction_entries.
func (f *AccountFilter) WhereHasTransactionEntries() {
	f.Where(entql.HasEdge("transaction_entries"))
}

// WhereHasTransactionEntriesWith applies a predicate to check if query has an edge transaction_entries with a given conditions (other predicates).
func (f *AccountFilter) WhereHasTransactionEntriesWith(preds ...predicate.TransactionEntry) {
	f.Where(entql.HasEdgeWith("transaction_entries", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasInvestments applies a predicate to check if query has an edge investments.
func (f *AccountFilter) WhereHasInvestments() {
	f.Where(entql.HasEdge("investments"))
}

// WhereHasInvestmentsWith applies a predicate to check if query has an edge investments with a given conditions (other predicates).
func (f *AccountFilter) WhereHasInvestmentsWith(preds ...predicate.Investment) {
	f.Where(entql.HasEdgeWith("investments", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *CryptoQuoteCacheQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the CryptoQuoteCacheQuery builder.
func (_q *CryptoQuoteCacheQuery) Filter() *CryptoQuoteCacheFilter {
	return &CryptoQuoteCacheFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *CryptoQuoteCacheMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the CryptoQuoteCacheMutation builder.
func (m *CryptoQuoteCacheMutation) Filter() *CryptoQuoteCacheFilter {
	return &CryptoQuoteCacheFilter{config: m.config, predicateAdder: m}
}

// CryptoQuoteCacheFilter provides a generic filtering capability at runtime for CryptoQuoteCacheQuery.
type CryptoQuoteCacheFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *CryptoQuoteCacheFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[1].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *CryptoQuoteCacheFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(cryptoquotecache.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *CryptoQuoteCacheFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(cryptoquotecache.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *CryptoQuoteCacheFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(cryptoquotecache.FieldUpdateTime))
}

// WhereSymbol applies the entql string predicate on the symbol field.
func (f *CryptoQuoteCacheFilter) WhereSymbol(p entql.StringP) {
	f.Where(p.Field(cryptoquotecache.FieldSymbol))
}

// WhereValue applies the entql float64 predicate on the value field.
func (f *CryptoQuoteCacheFilter) WhereValue(p entql.Float64P) {
	f.Where(p.Field(cryptoquotecache.FieldValue))
}

// WhereDate applies the entql time.Time predicate on the date field.
func (f *CryptoQuoteCacheFilter) WhereDate(p entql.TimeP) {
	f.Where(p.Field(cryptoquotecache.FieldDate))
}

// addPredicate implements the predicateAdder interface.
func (_q *CurrencyQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the CurrencyQuery builder.
func (_q *CurrencyQuery) Filter() *CurrencyFilter {
	return &CurrencyFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *CurrencyMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the CurrencyMutation builder.
func (m *CurrencyMutation) Filter() *CurrencyFilter {
	return &CurrencyFilter{config: m.config, predicateAdder: m}
}

// CurrencyFilter provides a generic filtering capability at runtime for CurrencyQuery.
type CurrencyFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *CurrencyFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[2].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *CurrencyFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(currency.FieldID))
}

// WhereCode applies the entql string predicate on the code field.
func (f *CurrencyFilter) WhereCode(p entql.StringP) {
	f.Where(p.Field(currency.FieldCode))
}

// WhereHasAccounts applies a predicate to check if query has an edge accounts.
func (f *CurrencyFilter) WhereHasAccounts() {
	f.Where(entql.HasEdge("accounts"))
}

// WhereHasAccountsWith applies a predicate to check if query has an edge accounts with a given conditions (other predicates).
func (f *CurrencyFilter) WhereHasAccountsWith(preds ...predicate.Account) {
	f.Where(entql.HasEdgeWith("accounts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasInvestments applies a predicate to check if query has an edge investments.
func (f *CurrencyFilter) WhereHasInvestments() {
	f.Where(entql.HasEdge("investments"))
}

// WhereHasInvestmentsWith applies a predicate to check if query has an edge investments with a given conditions (other predicates).
func (f *CurrencyFilter) WhereHasInvestmentsWith(preds ...predicate.Investment) {
	f.Where(entql.HasEdgeWith("investments", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTransactionEntries applies a predicate to check if query has an edge transaction_entries.
func (f *CurrencyFilter) WhereHasTransactionEntries() {
	f.Where(entql.HasEdge("transaction_entries"))
}

// WhereHasTransactionEntriesWith applies a predicate to check if query has an edge transaction_entries with a given conditions (other predicates).
func (f *CurrencyFilter) WhereHasTransactionEntriesWith(preds ...predicate.TransactionEntry) {
	f.Where(entql.HasEdgeWith("transaction_entries", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHouseholds applies a predicate to check if query has an edge households.
func (f *CurrencyFilter) WhereHasHouseholds() {
	f.Where(entql.HasEdge("households"))
}

// WhereHasHouseholdsWith applies a predicate to check if query has an edge households with a given conditions (other predicates).
func (f *CurrencyFilter) WhereHasHouseholdsWith(preds ...predicate.Household) {
	f.Where(entql.HasEdgeWith("households", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasFxRateCachesFrom applies a predicate to check if query has an edge fx_rate_caches_from.
func (f *CurrencyFilter) WhereHasFxRateCachesFrom() {
	f.Where(entql.HasEdge("fx_rate_caches_from"))
}

// WhereHasFxRateCachesFromWith applies a predicate to check if query has an edge fx_rate_caches_from with a given conditions (other predicates).
func (f *CurrencyFilter) WhereHasFxRateCachesFromWith(preds ...predicate.FXRateCache) {
	f.Where(entql.HasEdgeWith("fx_rate_caches_from", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasFxRateCachesTo applies a predicate to check if query has an edge fx_rate_caches_to.
func (f *CurrencyFilter) WhereHasFxRateCachesTo() {
	f.Where(entql.HasEdge("fx_rate_caches_to"))
}

// WhereHasFxRateCachesToWith applies a predicate to check if query has an edge fx_rate_caches_to with a given conditions (other predicates).
func (f *CurrencyFilter) WhereHasFxRateCachesToWith(preds ...predicate.FXRateCache) {
	f.Where(entql.HasEdgeWith("fx_rate_caches_to", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *FXRateCacheQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the FXRateCacheQuery builder.
func (_q *FXRateCacheQuery) Filter() *FXRateCacheFilter {
	return &FXRateCacheFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *FXRateCacheMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the FXRateCacheMutation builder.
func (m *FXRateCacheMutation) Filter() *FXRateCacheFilter {
	return &FXRateCacheFilter{config: m.config, predicateAdder: m}
}

// FXRateCacheFilter provides a generic filtering capability at runtime for FXRateCacheQuery.
type FXRateCacheFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *FXRateCacheFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[3].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *FXRateCacheFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(fxratecache.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *FXRateCacheFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(fxratecache.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *FXRateCacheFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(fxratecache.FieldUpdateTime))
}

// WhereFromCurrencyID applies the entql int predicate on the from_currency_id field.
func (f *FXRateCacheFilter) WhereFromCurrencyID(p entql.IntP) {
	f.Where(p.Field(fxratecache.FieldFromCurrencyID))
}

// WhereToCurrencyID applies the entql int predicate on the to_currency_id field.
func (f *FXRateCacheFilter) WhereToCurrencyID(p entql.IntP) {
	f.Where(p.Field(fxratecache.FieldToCurrencyID))
}

// WhereValue applies the entql float64 predicate on the value field.
func (f *FXRateCacheFilter) WhereValue(p entql.Float64P) {
	f.Where(p.Field(fxratecache.FieldValue))
}

// WhereDate applies the entql time.Time predicate on the date field.
func (f *FXRateCacheFilter) WhereDate(p entql.TimeP) {
	f.Where(p.Field(fxratecache.FieldDate))
}

// WhereHasFromCurrency applies a predicate to check if query has an edge from_currency.
func (f *FXRateCacheFilter) WhereHasFromCurrency() {
	f.Where(entql.HasEdge("from_currency"))
}

// WhereHasFromCurrencyWith applies a predicate to check if query has an edge from_currency with a given conditions (other predicates).
func (f *FXRateCacheFilter) WhereHasFromCurrencyWith(preds ...predicate.Currency) {
	f.Where(entql.HasEdgeWith("from_currency", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasToCurrency applies a predicate to check if query has an edge to_currency.
func (f *FXRateCacheFilter) WhereHasToCurrency() {
	f.Where(entql.HasEdge("to_currency"))
}

// WhereHasToCurrencyWith applies a predicate to check if query has an edge to_currency with a given conditions (other predicates).
func (f *FXRateCacheFilter) WhereHasToCurrencyWith(preds ...predicate.Currency) {
	f.Where(entql.HasEdgeWith("to_currency", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *HouseholdQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the HouseholdQuery builder.
func (_q *HouseholdQuery) Filter() *HouseholdFilter {
	return &HouseholdFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *HouseholdMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the HouseholdMutation builder.
func (m *HouseholdMutation) Filter() *HouseholdFilter {
	return &HouseholdFilter{config: m.config, predicateAdder: m}
}

// HouseholdFilter provides a generic filtering capability at runtime for HouseholdQuery.
type HouseholdFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *HouseholdFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[4].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *HouseholdFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(household.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *HouseholdFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(household.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *HouseholdFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(household.FieldUpdateTime))
}

// WhereName applies the entql string predicate on the name field.
func (f *HouseholdFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(household.FieldName))
}

// WhereLocale applies the entql string predicate on the locale field.
func (f *HouseholdFilter) WhereLocale(p entql.StringP) {
	f.Where(p.Field(household.FieldLocale))
}

// WhereCurrencyID applies the entql int predicate on the currency_id field.
func (f *HouseholdFilter) WhereCurrencyID(p entql.IntP) {
	f.Where(p.Field(household.FieldCurrencyID))
}

// WhereHasCurrency applies a predicate to check if query has an edge currency.
func (f *HouseholdFilter) WhereHasCurrency() {
	f.Where(entql.HasEdge("currency"))
}

// WhereHasCurrencyWith applies a predicate to check if query has an edge currency with a given conditions (other predicates).
func (f *HouseholdFilter) WhereHasCurrencyWith(preds ...predicate.Currency) {
	f.Where(entql.HasEdgeWith("currency", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *HouseholdFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *HouseholdFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasAccounts applies a predicate to check if query has an edge accounts.
func (f *HouseholdFilter) WhereHasAccounts() {
	f.Where(entql.HasEdge("accounts"))
}

// WhereHasAccountsWith applies a predicate to check if query has an edge accounts with a given conditions (other predicates).
func (f *HouseholdFilter) WhereHasAccountsWith(preds ...predicate.Account) {
	f.Where(entql.HasEdgeWith("accounts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTransactions applies a predicate to check if query has an edge transactions.
func (f *HouseholdFilter) WhereHasTransactions() {
	f.Where(entql.HasEdge("transactions"))
}

// WhereHasTransactionsWith applies a predicate to check if query has an edge transactions with a given conditions (other predicates).
func (f *HouseholdFilter) WhereHasTransactionsWith(preds ...predicate.Transaction) {
	f.Where(entql.HasEdgeWith("transactions", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasInvestments applies a predicate to check if query has an edge investments.
func (f *HouseholdFilter) WhereHasInvestments() {
	f.Where(entql.HasEdge("investments"))
}

// WhereHasInvestmentsWith applies a predicate to check if query has an edge investments with a given conditions (other predicates).
func (f *HouseholdFilter) WhereHasInvestmentsWith(preds ...predicate.Investment) {
	f.Where(entql.HasEdgeWith("investments", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasInvestmentLots applies a predicate to check if query has an edge investment_lots.
func (f *HouseholdFilter) WhereHasInvestmentLots() {
	f.Where(entql.HasEdge("investment_lots"))
}

// WhereHasInvestmentLotsWith applies a predicate to check if query has an edge investment_lots with a given conditions (other predicates).
func (f *HouseholdFilter) WhereHasInvestmentLotsWith(preds ...predicate.InvestmentLot) {
	f.Where(entql.HasEdgeWith("investment_lots", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTransactionCategories applies a predicate to check if query has an edge transaction_categories.
func (f *HouseholdFilter) WhereHasTransactionCategories() {
	f.Where(entql.HasEdge("transaction_categories"))
}

// WhereHasTransactionCategoriesWith applies a predicate to check if query has an edge transaction_categories with a given conditions (other predicates).
func (f *HouseholdFilter) WhereHasTransactionCategoriesWith(preds ...predicate.TransactionCategory) {
	f.Where(entql.HasEdgeWith("transaction_categories", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTransactionEntries applies a predicate to check if query has an edge transaction_entries.
func (f *HouseholdFilter) WhereHasTransactionEntries() {
	f.Where(entql.HasEdge("transaction_entries"))
}

// WhereHasTransactionEntriesWith applies a predicate to check if query has an edge transaction_entries with a given conditions (other predicates).
func (f *HouseholdFilter) WhereHasTransactionEntriesWith(preds ...predicate.TransactionEntry) {
	f.Where(entql.HasEdgeWith("transaction_entries", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUserHouseholds applies a predicate to check if query has an edge user_households.
func (f *HouseholdFilter) WhereHasUserHouseholds() {
	f.Where(entql.HasEdge("user_households"))
}

// WhereHasUserHouseholdsWith applies a predicate to check if query has an edge user_households with a given conditions (other predicates).
func (f *HouseholdFilter) WhereHasUserHouseholdsWith(preds ...predicate.UserHousehold) {
	f.Where(entql.HasEdgeWith("user_households", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *InvestmentQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the InvestmentQuery builder.
func (_q *InvestmentQuery) Filter() *InvestmentFilter {
	return &InvestmentFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *InvestmentMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the InvestmentMutation builder.
func (m *InvestmentMutation) Filter() *InvestmentFilter {
	return &InvestmentFilter{config: m.config, predicateAdder: m}
}

// InvestmentFilter provides a generic filtering capability at runtime for InvestmentQuery.
type InvestmentFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *InvestmentFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[5].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *InvestmentFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(investment.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *InvestmentFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(investment.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *InvestmentFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(investment.FieldUpdateTime))
}

// WhereHouseholdID applies the entql int predicate on the household_id field.
func (f *InvestmentFilter) WhereHouseholdID(p entql.IntP) {
	f.Where(p.Field(investment.FieldHouseholdID))
}

// WhereName applies the entql string predicate on the name field.
func (f *InvestmentFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(investment.FieldName))
}

// WhereType applies the entql string predicate on the type field.
func (f *InvestmentFilter) WhereType(p entql.StringP) {
	f.Where(p.Field(investment.FieldType))
}

// WhereSymbol applies the entql string predicate on the symbol field.
func (f *InvestmentFilter) WhereSymbol(p entql.StringP) {
	f.Where(p.Field(investment.FieldSymbol))
}

// WhereAmount applies the entql float64 predicate on the amount field.
func (f *InvestmentFilter) WhereAmount(p entql.Float64P) {
	f.Where(p.Field(investment.FieldAmount))
}

// WhereQuote applies the entql float64 predicate on the quote field.
func (f *InvestmentFilter) WhereQuote(p entql.Float64P) {
	f.Where(p.Field(investment.FieldQuote))
}

// WhereValue applies the entql float64 predicate on the value field.
func (f *InvestmentFilter) WhereValue(p entql.Float64P) {
	f.Where(p.Field(investment.FieldValue))
}

// WhereAccountID applies the entql int predicate on the account_id field.
func (f *InvestmentFilter) WhereAccountID(p entql.IntP) {
	f.Where(p.Field(investment.FieldAccountID))
}

// WhereCurrencyID applies the entql int predicate on the currency_id field.
func (f *InvestmentFilter) WhereCurrencyID(p entql.IntP) {
	f.Where(p.Field(investment.FieldCurrencyID))
}

// WhereHasAccount applies a predicate to check if query has an edge account.
func (f *InvestmentFilter) WhereHasAccount() {
	f.Where(entql.HasEdge("account"))
}

// WhereHasAccountWith applies a predicate to check if query has an edge account with a given conditions (other predicates).
func (f *InvestmentFilter) WhereHasAccountWith(preds ...predicate.Account) {
	f.Where(entql.HasEdgeWith("account", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHousehold applies a predicate to check if query has an edge household.
func (f *InvestmentFilter) WhereHasHousehold() {
	f.Where(entql.HasEdge("household"))
}

// WhereHasHouseholdWith applies a predicate to check if query has an edge household with a given conditions (other predicates).
func (f *InvestmentFilter) WhereHasHouseholdWith(preds ...predicate.Household) {
	f.Where(entql.HasEdgeWith("household", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasCurrency applies a predicate to check if query has an edge currency.
func (f *InvestmentFilter) WhereHasCurrency() {
	f.Where(entql.HasEdge("currency"))
}

// WhereHasCurrencyWith applies a predicate to check if query has an edge currency with a given conditions (other predicates).
func (f *InvestmentFilter) WhereHasCurrencyWith(preds ...predicate.Currency) {
	f.Where(entql.HasEdgeWith("currency", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasInvestmentLots applies a predicate to check if query has an edge investment_lots.
func (f *InvestmentFilter) WhereHasInvestmentLots() {
	f.Where(entql.HasEdge("investment_lots"))
}

// WhereHasInvestmentLotsWith applies a predicate to check if query has an edge investment_lots with a given conditions (other predicates).
func (f *InvestmentFilter) WhereHasInvestmentLotsWith(preds ...predicate.InvestmentLot) {
	f.Where(entql.HasEdgeWith("investment_lots", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *InvestmentLotQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the InvestmentLotQuery builder.
func (_q *InvestmentLotQuery) Filter() *InvestmentLotFilter {
	return &InvestmentLotFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *InvestmentLotMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the InvestmentLotMutation builder.
func (m *InvestmentLotMutation) Filter() *InvestmentLotFilter {
	return &InvestmentLotFilter{config: m.config, predicateAdder: m}
}

// InvestmentLotFilter provides a generic filtering capability at runtime for InvestmentLotQuery.
type InvestmentLotFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *InvestmentLotFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[6].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *InvestmentLotFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(investmentlot.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *InvestmentLotFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(investmentlot.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *InvestmentLotFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(investmentlot.FieldUpdateTime))
}

// WhereHouseholdID applies the entql int predicate on the household_id field.
func (f *InvestmentLotFilter) WhereHouseholdID(p entql.IntP) {
	f.Where(p.Field(investmentlot.FieldHouseholdID))
}

// WhereAmount applies the entql float64 predicate on the amount field.
func (f *InvestmentLotFilter) WhereAmount(p entql.Float64P) {
	f.Where(p.Field(investmentlot.FieldAmount))
}

// WherePrice applies the entql float64 predicate on the price field.
func (f *InvestmentLotFilter) WherePrice(p entql.Float64P) {
	f.Where(p.Field(investmentlot.FieldPrice))
}

// WhereInvestmentID applies the entql int predicate on the investment_id field.
func (f *InvestmentLotFilter) WhereInvestmentID(p entql.IntP) {
	f.Where(p.Field(investmentlot.FieldInvestmentID))
}

// WhereTransactionID applies the entql int predicate on the transaction_id field.
func (f *InvestmentLotFilter) WhereTransactionID(p entql.IntP) {
	f.Where(p.Field(investmentlot.FieldTransactionID))
}

// WhereHasHousehold applies a predicate to check if query has an edge household.
func (f *InvestmentLotFilter) WhereHasHousehold() {
	f.Where(entql.HasEdge("household"))
}

// WhereHasHouseholdWith applies a predicate to check if query has an edge household with a given conditions (other predicates).
func (f *InvestmentLotFilter) WhereHasHouseholdWith(preds ...predicate.Household) {
	f.Where(entql.HasEdgeWith("household", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasInvestment applies a predicate to check if query has an edge investment.
func (f *InvestmentLotFilter) WhereHasInvestment() {
	f.Where(entql.HasEdge("investment"))
}

// WhereHasInvestmentWith applies a predicate to check if query has an edge investment with a given conditions (other predicates).
func (f *InvestmentLotFilter) WhereHasInvestmentWith(preds ...predicate.Investment) {
	f.Where(entql.HasEdgeWith("investment", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTransaction applies a predicate to check if query has an edge transaction.
func (f *InvestmentLotFilter) WhereHasTransaction() {
	f.Where(entql.HasEdge("transaction"))
}

// WhereHasTransactionWith applies a predicate to check if query has an edge transaction with a given conditions (other predicates).
func (f *InvestmentLotFilter) WhereHasTransactionWith(preds ...predicate.Transaction) {
	f.Where(entql.HasEdgeWith("transaction", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *StockQuoteCacheQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the StockQuoteCacheQuery builder.
func (_q *StockQuoteCacheQuery) Filter() *StockQuoteCacheFilter {
	return &StockQuoteCacheFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *StockQuoteCacheMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the StockQuoteCacheMutation builder.
func (m *StockQuoteCacheMutation) Filter() *StockQuoteCacheFilter {
	return &StockQuoteCacheFilter{config: m.config, predicateAdder: m}
}

// StockQuoteCacheFilter provides a generic filtering capability at runtime for StockQuoteCacheQuery.
type StockQuoteCacheFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *StockQuoteCacheFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[7].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *StockQuoteCacheFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(stockquotecache.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *StockQuoteCacheFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(stockquotecache.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *StockQuoteCacheFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(stockquotecache.FieldUpdateTime))
}

// WhereSymbol applies the entql string predicate on the symbol field.
func (f *StockQuoteCacheFilter) WhereSymbol(p entql.StringP) {
	f.Where(p.Field(stockquotecache.FieldSymbol))
}

// WhereValue applies the entql float64 predicate on the value field.
func (f *StockQuoteCacheFilter) WhereValue(p entql.Float64P) {
	f.Where(p.Field(stockquotecache.FieldValue))
}

// WhereDate applies the entql time.Time predicate on the date field.
func (f *StockQuoteCacheFilter) WhereDate(p entql.TimeP) {
	f.Where(p.Field(stockquotecache.FieldDate))
}

// addPredicate implements the predicateAdder interface.
func (_q *TransactionQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the TransactionQuery builder.
func (_q *TransactionQuery) Filter() *TransactionFilter {
	return &TransactionFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *TransactionMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the TransactionMutation builder.
func (m *TransactionMutation) Filter() *TransactionFilter {
	return &TransactionFilter{config: m.config, predicateAdder: m}
}

// TransactionFilter provides a generic filtering capability at runtime for TransactionQuery.
type TransactionFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *TransactionFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[8].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *TransactionFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(transaction.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *TransactionFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(transaction.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *TransactionFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(transaction.FieldUpdateTime))
}

// WhereHouseholdID applies the entql int predicate on the household_id field.
func (f *TransactionFilter) WhereHouseholdID(p entql.IntP) {
	f.Where(p.Field(transaction.FieldHouseholdID))
}

// WhereDescription applies the entql string predicate on the description field.
func (f *TransactionFilter) WhereDescription(p entql.StringP) {
	f.Where(p.Field(transaction.FieldDescription))
}

// WhereDatetime applies the entql time.Time predicate on the datetime field.
func (f *TransactionFilter) WhereDatetime(p entql.TimeP) {
	f.Where(p.Field(transaction.FieldDatetime))
}

// WhereUserID applies the entql int predicate on the user_id field.
func (f *TransactionFilter) WhereUserID(p entql.IntP) {
	f.Where(p.Field(transaction.FieldUserID))
}

// WhereCategoryID applies the entql int predicate on the category_id field.
func (f *TransactionFilter) WhereCategoryID(p entql.IntP) {
	f.Where(p.Field(transaction.FieldCategoryID))
}

// WhereHasUser applies a predicate to check if query has an edge user.
func (f *TransactionFilter) WhereHasUser() {
	f.Where(entql.HasEdge("user"))
}

// WhereHasUserWith applies a predicate to check if query has an edge user with a given conditions (other predicates).
func (f *TransactionFilter) WhereHasUserWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("user", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHousehold applies a predicate to check if query has an edge household.
func (f *TransactionFilter) WhereHasHousehold() {
	f.Where(entql.HasEdge("household"))
}

// WhereHasHouseholdWith applies a predicate to check if query has an edge household with a given conditions (other predicates).
func (f *TransactionFilter) WhereHasHouseholdWith(preds ...predicate.Household) {
	f.Where(entql.HasEdgeWith("household", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasCategory applies a predicate to check if query has an edge category.
func (f *TransactionFilter) WhereHasCategory() {
	f.Where(entql.HasEdge("category"))
}

// WhereHasCategoryWith applies a predicate to check if query has an edge category with a given conditions (other predicates).
func (f *TransactionFilter) WhereHasCategoryWith(preds ...predicate.TransactionCategory) {
	f.Where(entql.HasEdgeWith("category", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTransactionEntries applies a predicate to check if query has an edge transaction_entries.
func (f *TransactionFilter) WhereHasTransactionEntries() {
	f.Where(entql.HasEdge("transaction_entries"))
}

// WhereHasTransactionEntriesWith applies a predicate to check if query has an edge transaction_entries with a given conditions (other predicates).
func (f *TransactionFilter) WhereHasTransactionEntriesWith(preds ...predicate.TransactionEntry) {
	f.Where(entql.HasEdgeWith("transaction_entries", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasInvestmentLots applies a predicate to check if query has an edge investment_lots.
func (f *TransactionFilter) WhereHasInvestmentLots() {
	f.Where(entql.HasEdge("investment_lots"))
}

// WhereHasInvestmentLotsWith applies a predicate to check if query has an edge investment_lots with a given conditions (other predicates).
func (f *TransactionFilter) WhereHasInvestmentLotsWith(preds ...predicate.InvestmentLot) {
	f.Where(entql.HasEdgeWith("investment_lots", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *TransactionCategoryQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the TransactionCategoryQuery builder.
func (_q *TransactionCategoryQuery) Filter() *TransactionCategoryFilter {
	return &TransactionCategoryFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *TransactionCategoryMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the TransactionCategoryMutation builder.
func (m *TransactionCategoryMutation) Filter() *TransactionCategoryFilter {
	return &TransactionCategoryFilter{config: m.config, predicateAdder: m}
}

// TransactionCategoryFilter provides a generic filtering capability at runtime for TransactionCategoryQuery.
type TransactionCategoryFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *TransactionCategoryFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[9].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *TransactionCategoryFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(transactioncategory.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *TransactionCategoryFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(transactioncategory.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *TransactionCategoryFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(transactioncategory.FieldUpdateTime))
}

// WhereHouseholdID applies the entql int predicate on the household_id field.
func (f *TransactionCategoryFilter) WhereHouseholdID(p entql.IntP) {
	f.Where(p.Field(transactioncategory.FieldHouseholdID))
}

// WhereName applies the entql string predicate on the name field.
func (f *TransactionCategoryFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(transactioncategory.FieldName))
}

// WhereType applies the entql string predicate on the type field.
func (f *TransactionCategoryFilter) WhereType(p entql.StringP) {
	f.Where(p.Field(transactioncategory.FieldType))
}

// WhereIcon applies the entql string predicate on the icon field.
func (f *TransactionCategoryFilter) WhereIcon(p entql.StringP) {
	f.Where(p.Field(transactioncategory.FieldIcon))
}

// WhereIsImmutable applies the entql bool predicate on the is_immutable field.
func (f *TransactionCategoryFilter) WhereIsImmutable(p entql.BoolP) {
	f.Where(p.Field(transactioncategory.FieldIsImmutable))
}

// WhereHasHousehold applies a predicate to check if query has an edge household.
func (f *TransactionCategoryFilter) WhereHasHousehold() {
	f.Where(entql.HasEdge("household"))
}

// WhereHasHouseholdWith applies a predicate to check if query has an edge household with a given conditions (other predicates).
func (f *TransactionCategoryFilter) WhereHasHouseholdWith(preds ...predicate.Household) {
	f.Where(entql.HasEdgeWith("household", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTransactions applies a predicate to check if query has an edge transactions.
func (f *TransactionCategoryFilter) WhereHasTransactions() {
	f.Where(entql.HasEdge("transactions"))
}

// WhereHasTransactionsWith applies a predicate to check if query has an edge transactions with a given conditions (other predicates).
func (f *TransactionCategoryFilter) WhereHasTransactionsWith(preds ...predicate.Transaction) {
	f.Where(entql.HasEdgeWith("transactions", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *TransactionEntryQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the TransactionEntryQuery builder.
func (_q *TransactionEntryQuery) Filter() *TransactionEntryFilter {
	return &TransactionEntryFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *TransactionEntryMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the TransactionEntryMutation builder.
func (m *TransactionEntryMutation) Filter() *TransactionEntryFilter {
	return &TransactionEntryFilter{config: m.config, predicateAdder: m}
}

// TransactionEntryFilter provides a generic filtering capability at runtime for TransactionEntryQuery.
type TransactionEntryFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *TransactionEntryFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[10].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *TransactionEntryFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(transactionentry.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *TransactionEntryFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(transactionentry.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *TransactionEntryFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(transactionentry.FieldUpdateTime))
}

// WhereHouseholdID applies the entql int predicate on the household_id field.
func (f *TransactionEntryFilter) WhereHouseholdID(p entql.IntP) {
	f.Where(p.Field(transactionentry.FieldHouseholdID))
}

// WhereAmount applies the entql float64 predicate on the amount field.
func (f *TransactionEntryFilter) WhereAmount(p entql.Float64P) {
	f.Where(p.Field(transactionentry.FieldAmount))
}

// WhereAccountID applies the entql int predicate on the account_id field.
func (f *TransactionEntryFilter) WhereAccountID(p entql.IntP) {
	f.Where(p.Field(transactionentry.FieldAccountID))
}

// WhereCurrencyID applies the entql int predicate on the currency_id field.
func (f *TransactionEntryFilter) WhereCurrencyID(p entql.IntP) {
	f.Where(p.Field(transactionentry.FieldCurrencyID))
}

// WhereTransactionID applies the entql int predicate on the transaction_id field.
func (f *TransactionEntryFilter) WhereTransactionID(p entql.IntP) {
	f.Where(p.Field(transactionentry.FieldTransactionID))
}

// WhereHasHousehold applies a predicate to check if query has an edge household.
func (f *TransactionEntryFilter) WhereHasHousehold() {
	f.Where(entql.HasEdge("household"))
}

// WhereHasHouseholdWith applies a predicate to check if query has an edge household with a given conditions (other predicates).
func (f *TransactionEntryFilter) WhereHasHouseholdWith(preds ...predicate.Household) {
	f.Where(entql.HasEdgeWith("household", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasAccount applies a predicate to check if query has an edge account.
func (f *TransactionEntryFilter) WhereHasAccount() {
	f.Where(entql.HasEdge("account"))
}

// WhereHasAccountWith applies a predicate to check if query has an edge account with a given conditions (other predicates).
func (f *TransactionEntryFilter) WhereHasAccountWith(preds ...predicate.Account) {
	f.Where(entql.HasEdgeWith("account", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasCurrency applies a predicate to check if query has an edge currency.
func (f *TransactionEntryFilter) WhereHasCurrency() {
	f.Where(entql.HasEdge("currency"))
}

// WhereHasCurrencyWith applies a predicate to check if query has an edge currency with a given conditions (other predicates).
func (f *TransactionEntryFilter) WhereHasCurrencyWith(preds ...predicate.Currency) {
	f.Where(entql.HasEdgeWith("currency", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTransaction applies a predicate to check if query has an edge transaction.
func (f *TransactionEntryFilter) WhereHasTransaction() {
	f.Where(entql.HasEdge("transaction"))
}

// WhereHasTransactionWith applies a predicate to check if query has an edge transaction with a given conditions (other predicates).
func (f *TransactionEntryFilter) WhereHasTransactionWith(preds ...predicate.Transaction) {
	f.Where(entql.HasEdgeWith("transaction", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *UserQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserQuery builder.
func (_q *UserQuery) Filter() *UserFilter {
	return &UserFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *UserMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserMutation builder.
func (m *UserMutation) Filter() *UserFilter {
	return &UserFilter{config: m.config, predicateAdder: m}
}

// UserFilter provides a generic filtering capability at runtime for UserQuery.
type UserFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[11].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *UserFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(user.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *UserFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(user.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *UserFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(user.FieldUpdateTime))
}

// WhereEmail applies the entql string predicate on the email field.
func (f *UserFilter) WhereEmail(p entql.StringP) {
	f.Where(p.Field(user.FieldEmail))
}

// WhereName applies the entql string predicate on the name field.
func (f *UserFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(user.FieldName))
}

// WhereHasHouseholds applies a predicate to check if query has an edge households.
func (f *UserFilter) WhereHasHouseholds() {
	f.Where(entql.HasEdge("households"))
}

// WhereHasHouseholdsWith applies a predicate to check if query has an edge households with a given conditions (other predicates).
func (f *UserFilter) WhereHasHouseholdsWith(preds ...predicate.Household) {
	f.Where(entql.HasEdgeWith("households", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasAccounts applies a predicate to check if query has an edge accounts.
func (f *UserFilter) WhereHasAccounts() {
	f.Where(entql.HasEdge("accounts"))
}

// WhereHasAccountsWith applies a predicate to check if query has an edge accounts with a given conditions (other predicates).
func (f *UserFilter) WhereHasAccountsWith(preds ...predicate.Account) {
	f.Where(entql.HasEdgeWith("accounts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTransactions applies a predicate to check if query has an edge transactions.
func (f *UserFilter) WhereHasTransactions() {
	f.Where(entql.HasEdge("transactions"))
}

// WhereHasTransactionsWith applies a predicate to check if query has an edge transactions with a given conditions (other predicates).
func (f *UserFilter) WhereHasTransactionsWith(preds ...predicate.Transaction) {
	f.Where(entql.HasEdgeWith("transactions", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUserKeys applies a predicate to check if query has an edge user_keys.
func (f *UserFilter) WhereHasUserKeys() {
	f.Where(entql.HasEdge("user_keys"))
}

// WhereHasUserKeysWith applies a predicate to check if query has an edge user_keys with a given conditions (other predicates).
func (f *UserFilter) WhereHasUserKeysWith(preds ...predicate.UserKey) {
	f.Where(entql.HasEdgeWith("user_keys", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUserHouseholds applies a predicate to check if query has an edge user_households.
func (f *UserFilter) WhereHasUserHouseholds() {
	f.Where(entql.HasEdge("user_households"))
}

// WhereHasUserHouseholdsWith applies a predicate to check if query has an edge user_households with a given conditions (other predicates).
func (f *UserFilter) WhereHasUserHouseholdsWith(preds ...predicate.UserHousehold) {
	f.Where(entql.HasEdgeWith("user_households", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *UserHouseholdQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserHouseholdQuery builder.
func (_q *UserHouseholdQuery) Filter() *UserHouseholdFilter {
	return &UserHouseholdFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *UserHouseholdMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserHouseholdMutation builder.
func (m *UserHouseholdMutation) Filter() *UserHouseholdFilter {
	return &UserHouseholdFilter{config: m.config, predicateAdder: m}
}

// UserHouseholdFilter provides a generic filtering capability at runtime for UserHouseholdQuery.
type UserHouseholdFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserHouseholdFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[12].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *UserHouseholdFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(userhousehold.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *UserHouseholdFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(userhousehold.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *UserHouseholdFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(userhousehold.FieldUpdateTime))
}

// WhereUserID applies the entql int predicate on the user_id field.
func (f *UserHouseholdFilter) WhereUserID(p entql.IntP) {
	f.Where(p.Field(userhousehold.FieldUserID))
}

// WhereHouseholdID applies the entql int predicate on the household_id field.
func (f *UserHouseholdFilter) WhereHouseholdID(p entql.IntP) {
	f.Where(p.Field(userhousehold.FieldHouseholdID))
}

// WhereRole applies the entql string predicate on the role field.
func (f *UserHouseholdFilter) WhereRole(p entql.StringP) {
	f.Where(p.Field(userhousehold.FieldRole))
}

// WhereHasUser applies a predicate to check if query has an edge user.
func (f *UserHouseholdFilter) WhereHasUser() {
	f.Where(entql.HasEdge("user"))
}

// WhereHasUserWith applies a predicate to check if query has an edge user with a given conditions (other predicates).
func (f *UserHouseholdFilter) WhereHasUserWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("user", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHousehold applies a predicate to check if query has an edge household.
func (f *UserHouseholdFilter) WhereHasHousehold() {
	f.Where(entql.HasEdge("household"))
}

// WhereHasHouseholdWith applies a predicate to check if query has an edge household with a given conditions (other predicates).
func (f *UserHouseholdFilter) WhereHasHouseholdWith(preds ...predicate.Household) {
	f.Where(entql.HasEdgeWith("household", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (_q *UserKeyQuery) addPredicate(pred func(s *sql.Selector)) {
	_q.predicates = append(_q.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserKeyQuery builder.
func (_q *UserKeyQuery) Filter() *UserKeyFilter {
	return &UserKeyFilter{config: _q.config, predicateAdder: _q}
}

// addPredicate implements the predicateAdder interface.
func (m *UserKeyMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserKeyMutation builder.
func (m *UserKeyMutation) Filter() *UserKeyFilter {
	return &UserKeyFilter{config: m.config, predicateAdder: m}
}

// UserKeyFilter provides a generic filtering capability at runtime for UserKeyQuery.
type UserKeyFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserKeyFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[13].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *UserKeyFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(userkey.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *UserKeyFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(userkey.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *UserKeyFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(userkey.FieldUpdateTime))
}

// WhereProvider applies the entql string predicate on the provider field.
func (f *UserKeyFilter) WhereProvider(p entql.StringP) {
	f.Where(p.Field(userkey.FieldProvider))
}

// WhereKey applies the entql string predicate on the key field.
func (f *UserKeyFilter) WhereKey(p entql.StringP) {
	f.Where(p.Field(userkey.FieldKey))
}

// WhereUserID applies the entql int predicate on the user_id field.
func (f *UserKeyFilter) WhereUserID(p entql.IntP) {
	f.Where(p.Field(userkey.FieldUserID))
}

// WhereHasUser applies a predicate to check if query has an edge user.
func (f *UserKeyFilter) WhereHasUser() {
	f.Where(entql.HasEdge("user"))
}

// WhereHasUserWith applies a predicate to check if query has an edge user with a given conditions (other predicates).
func (f *UserKeyFilter) WhereHasUserWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("user", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}
