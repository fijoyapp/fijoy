// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fijoy/ent/account"
	"fijoy/ent/predicate"
	"fijoy/ent/profile"
	"fijoy/ent/transaction"
	"fijoy/ent/transactionentry"
	"fijoy/ent/user"
	"fijoy/ent/userkey"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount          = "Account"
	TypeProfile          = "Profile"
	TypeTransaction      = "Transaction"
	TypeTransactionEntry = "TransactionEntry"
	TypeUser             = "User"
	TypeUserKey          = "UserKey"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	create_time              *time.Time
	update_time              *time.Time
	name                     *string
	account_type             *account.AccountType
	currency_symbol          *string
	ticker                   *string
	ticker_type              *account.TickerType
	amount                   *decimal.Decimal
	addamount                *decimal.Decimal
	value                    *decimal.Decimal
	addvalue                 *decimal.Decimal
	fx_rate                  *decimal.Decimal
	addfx_rate               *decimal.Decimal
	balance                  *decimal.Decimal
	addbalance               *decimal.Decimal
	archived                 *bool
	clearedFields            map[string]struct{}
	profile                  *string
	clearedprofile           bool
	transaction_entry        map[string]struct{}
	removedtransaction_entry map[string]struct{}
	clearedtransaction_entry bool
	done                     bool
	oldValue                 func(context.Context) (*Account, error)
	predicates               []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id string) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AccountMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AccountMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AccountMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AccountMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AccountMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AccountMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetAccountType sets the "account_type" field.
func (m *AccountMutation) SetAccountType(at account.AccountType) {
	m.account_type = &at
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *AccountMutation) AccountType() (r account.AccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccountType(ctx context.Context) (v account.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *AccountMutation) ResetAccountType() {
	m.account_type = nil
}

// SetCurrencySymbol sets the "currency_symbol" field.
func (m *AccountMutation) SetCurrencySymbol(s string) {
	m.currency_symbol = &s
}

// CurrencySymbol returns the value of the "currency_symbol" field in the mutation.
func (m *AccountMutation) CurrencySymbol() (r string, exists bool) {
	v := m.currency_symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencySymbol returns the old "currency_symbol" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCurrencySymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencySymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencySymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencySymbol: %w", err)
	}
	return oldValue.CurrencySymbol, nil
}

// ResetCurrencySymbol resets all changes to the "currency_symbol" field.
func (m *AccountMutation) ResetCurrencySymbol() {
	m.currency_symbol = nil
}

// SetTicker sets the "ticker" field.
func (m *AccountMutation) SetTicker(s string) {
	m.ticker = &s
}

// Ticker returns the value of the "ticker" field in the mutation.
func (m *AccountMutation) Ticker() (r string, exists bool) {
	v := m.ticker
	if v == nil {
		return
	}
	return *v, true
}

// OldTicker returns the old "ticker" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTicker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicker: %w", err)
	}
	return oldValue.Ticker, nil
}

// ResetTicker resets all changes to the "ticker" field.
func (m *AccountMutation) ResetTicker() {
	m.ticker = nil
}

// SetTickerType sets the "ticker_type" field.
func (m *AccountMutation) SetTickerType(at account.TickerType) {
	m.ticker_type = &at
}

// TickerType returns the value of the "ticker_type" field in the mutation.
func (m *AccountMutation) TickerType() (r account.TickerType, exists bool) {
	v := m.ticker_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTickerType returns the old "ticker_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTickerType(ctx context.Context) (v account.TickerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTickerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTickerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTickerType: %w", err)
	}
	return oldValue.TickerType, nil
}

// ResetTickerType resets all changes to the "ticker_type" field.
func (m *AccountMutation) ResetTickerType() {
	m.ticker_type = nil
}

// SetAmount sets the "amount" field.
func (m *AccountMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AccountMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *AccountMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AccountMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *AccountMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetValue sets the "value" field.
func (m *AccountMutation) SetValue(d decimal.Decimal) {
	m.value = &d
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *AccountMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds d to the "value" field.
func (m *AccountMutation) AddValue(d decimal.Decimal) {
	if m.addvalue != nil {
		*m.addvalue = m.addvalue.Add(d)
	} else {
		m.addvalue = &d
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *AccountMutation) AddedValue() (r decimal.Decimal, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *AccountMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetFxRate sets the "fx_rate" field.
func (m *AccountMutation) SetFxRate(d decimal.Decimal) {
	m.fx_rate = &d
	m.addfx_rate = nil
}

// FxRate returns the value of the "fx_rate" field in the mutation.
func (m *AccountMutation) FxRate() (r decimal.Decimal, exists bool) {
	v := m.fx_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFxRate returns the old "fx_rate" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldFxRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFxRate: %w", err)
	}
	return oldValue.FxRate, nil
}

// AddFxRate adds d to the "fx_rate" field.
func (m *AccountMutation) AddFxRate(d decimal.Decimal) {
	if m.addfx_rate != nil {
		*m.addfx_rate = m.addfx_rate.Add(d)
	} else {
		m.addfx_rate = &d
	}
}

// AddedFxRate returns the value that was added to the "fx_rate" field in this mutation.
func (m *AccountMutation) AddedFxRate() (r decimal.Decimal, exists bool) {
	v := m.addfx_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearFxRate clears the value of the "fx_rate" field.
func (m *AccountMutation) ClearFxRate() {
	m.fx_rate = nil
	m.addfx_rate = nil
	m.clearedFields[account.FieldFxRate] = struct{}{}
}

// FxRateCleared returns if the "fx_rate" field was cleared in this mutation.
func (m *AccountMutation) FxRateCleared() bool {
	_, ok := m.clearedFields[account.FieldFxRate]
	return ok
}

// ResetFxRate resets all changes to the "fx_rate" field.
func (m *AccountMutation) ResetFxRate() {
	m.fx_rate = nil
	m.addfx_rate = nil
	delete(m.clearedFields, account.FieldFxRate)
}

// SetBalance sets the "balance" field.
func (m *AccountMutation) SetBalance(d decimal.Decimal) {
	m.balance = &d
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *AccountMutation) Balance() (r decimal.Decimal, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBalance(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds d to the "balance" field.
func (m *AccountMutation) AddBalance(d decimal.Decimal) {
	if m.addbalance != nil {
		*m.addbalance = m.addbalance.Add(d)
	} else {
		m.addbalance = &d
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *AccountMutation) AddedBalance() (r decimal.Decimal, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *AccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetArchived sets the "archived" field.
func (m *AccountMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *AccountMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *AccountMutation) ResetArchived() {
	m.archived = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *AccountMutation) SetProfileID(id string) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *AccountMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *AccountMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *AccountMutation) ProfileID() (id string, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) ProfileIDs() (ids []string) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *AccountMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddTransactionEntryIDs adds the "transaction_entry" edge to the TransactionEntry entity by ids.
func (m *AccountMutation) AddTransactionEntryIDs(ids ...string) {
	if m.transaction_entry == nil {
		m.transaction_entry = make(map[string]struct{})
	}
	for i := range ids {
		m.transaction_entry[ids[i]] = struct{}{}
	}
}

// ClearTransactionEntry clears the "transaction_entry" edge to the TransactionEntry entity.
func (m *AccountMutation) ClearTransactionEntry() {
	m.clearedtransaction_entry = true
}

// TransactionEntryCleared reports if the "transaction_entry" edge to the TransactionEntry entity was cleared.
func (m *AccountMutation) TransactionEntryCleared() bool {
	return m.clearedtransaction_entry
}

// RemoveTransactionEntryIDs removes the "transaction_entry" edge to the TransactionEntry entity by IDs.
func (m *AccountMutation) RemoveTransactionEntryIDs(ids ...string) {
	if m.removedtransaction_entry == nil {
		m.removedtransaction_entry = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transaction_entry, ids[i])
		m.removedtransaction_entry[ids[i]] = struct{}{}
	}
}

// RemovedTransactionEntry returns the removed IDs of the "transaction_entry" edge to the TransactionEntry entity.
func (m *AccountMutation) RemovedTransactionEntryIDs() (ids []string) {
	for id := range m.removedtransaction_entry {
		ids = append(ids, id)
	}
	return
}

// TransactionEntryIDs returns the "transaction_entry" edge IDs in the mutation.
func (m *AccountMutation) TransactionEntryIDs() (ids []string) {
	for id := range m.transaction_entry {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionEntry resets all changes to the "transaction_entry" edge.
func (m *AccountMutation) ResetTransactionEntry() {
	m.transaction_entry = nil
	m.clearedtransaction_entry = false
	m.removedtransaction_entry = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, account.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, account.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.account_type != nil {
		fields = append(fields, account.FieldAccountType)
	}
	if m.currency_symbol != nil {
		fields = append(fields, account.FieldCurrencySymbol)
	}
	if m.ticker != nil {
		fields = append(fields, account.FieldTicker)
	}
	if m.ticker_type != nil {
		fields = append(fields, account.FieldTickerType)
	}
	if m.amount != nil {
		fields = append(fields, account.FieldAmount)
	}
	if m.value != nil {
		fields = append(fields, account.FieldValue)
	}
	if m.fx_rate != nil {
		fields = append(fields, account.FieldFxRate)
	}
	if m.balance != nil {
		fields = append(fields, account.FieldBalance)
	}
	if m.archived != nil {
		fields = append(fields, account.FieldArchived)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreateTime:
		return m.CreateTime()
	case account.FieldUpdateTime:
		return m.UpdateTime()
	case account.FieldName:
		return m.Name()
	case account.FieldAccountType:
		return m.AccountType()
	case account.FieldCurrencySymbol:
		return m.CurrencySymbol()
	case account.FieldTicker:
		return m.Ticker()
	case account.FieldTickerType:
		return m.TickerType()
	case account.FieldAmount:
		return m.Amount()
	case account.FieldValue:
		return m.Value()
	case account.FieldFxRate:
		return m.FxRate()
	case account.FieldBalance:
		return m.Balance()
	case account.FieldArchived:
		return m.Archived()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case account.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldAccountType:
		return m.OldAccountType(ctx)
	case account.FieldCurrencySymbol:
		return m.OldCurrencySymbol(ctx)
	case account.FieldTicker:
		return m.OldTicker(ctx)
	case account.FieldTickerType:
		return m.OldTickerType(ctx)
	case account.FieldAmount:
		return m.OldAmount(ctx)
	case account.FieldValue:
		return m.OldValue(ctx)
	case account.FieldFxRate:
		return m.OldFxRate(ctx)
	case account.FieldBalance:
		return m.OldBalance(ctx)
	case account.FieldArchived:
		return m.OldArchived(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case account.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldAccountType:
		v, ok := value.(account.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case account.FieldCurrencySymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencySymbol(v)
		return nil
	case account.FieldTicker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicker(v)
		return nil
	case account.FieldTickerType:
		v, ok := value.(account.TickerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTickerType(v)
		return nil
	case account.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case account.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case account.FieldFxRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFxRate(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case account.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, account.FieldAmount)
	}
	if m.addvalue != nil {
		fields = append(fields, account.FieldValue)
	}
	if m.addfx_rate != nil {
		fields = append(fields, account.FieldFxRate)
	}
	if m.addbalance != nil {
		fields = append(fields, account.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldAmount:
		return m.AddedAmount()
	case account.FieldValue:
		return m.AddedValue()
	case account.FieldFxRate:
		return m.AddedFxRate()
	case account.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case account.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case account.FieldFxRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFxRate(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldFxRate) {
		fields = append(fields, account.FieldFxRate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldFxRate:
		m.ClearFxRate()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case account.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldAccountType:
		m.ResetAccountType()
		return nil
	case account.FieldCurrencySymbol:
		m.ResetCurrencySymbol()
		return nil
	case account.FieldTicker:
		m.ResetTicker()
		return nil
	case account.FieldTickerType:
		m.ResetTickerType()
		return nil
	case account.FieldAmount:
		m.ResetAmount()
		return nil
	case account.FieldValue:
		m.ResetValue()
		return nil
	case account.FieldFxRate:
		m.ResetFxRate()
		return nil
	case account.FieldBalance:
		m.ResetBalance()
		return nil
	case account.FieldArchived:
		m.ResetArchived()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.profile != nil {
		edges = append(edges, account.EdgeProfile)
	}
	if m.transaction_entry != nil {
		edges = append(edges, account.EdgeTransactionEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeTransactionEntry:
		ids := make([]ent.Value, 0, len(m.transaction_entry))
		for id := range m.transaction_entry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransaction_entry != nil {
		edges = append(edges, account.EdgeTransactionEntry)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTransactionEntry:
		ids := make([]ent.Value, 0, len(m.removedtransaction_entry))
		for id := range m.removedtransaction_entry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprofile {
		edges = append(edges, account.EdgeProfile)
	}
	if m.clearedtransaction_entry {
		edges = append(edges, account.EdgeTransactionEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeProfile:
		return m.clearedprofile
	case account.EdgeTransactionEntry:
		return m.clearedtransaction_entry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeProfile:
		m.ResetProfile()
		return nil
	case account.EdgeTransactionEntry:
		m.ResetTransactionEntry()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	create_time        *time.Time
	update_time        *time.Time
	locale             *string
	currencies         *string
	net_worth_goal     *decimal.Decimal
	addnet_worth_goal  *decimal.Decimal
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	account            map[string]struct{}
	removedaccount     map[string]struct{}
	clearedaccount     bool
	transaction        map[string]struct{}
	removedtransaction map[string]struct{}
	clearedtransaction bool
	done               bool
	oldValue           func(context.Context) (*Profile, error)
	predicates         []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id string) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Profile entities.
func (m *ProfileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ProfileMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProfileMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProfileMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProfileMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProfileMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProfileMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetLocale sets the "locale" field.
func (m *ProfileMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *ProfileMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *ProfileMutation) ResetLocale() {
	m.locale = nil
}

// SetCurrencies sets the "currencies" field.
func (m *ProfileMutation) SetCurrencies(s string) {
	m.currencies = &s
}

// Currencies returns the value of the "currencies" field in the mutation.
func (m *ProfileMutation) Currencies() (r string, exists bool) {
	v := m.currencies
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencies returns the old "currencies" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCurrencies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencies: %w", err)
	}
	return oldValue.Currencies, nil
}

// ResetCurrencies resets all changes to the "currencies" field.
func (m *ProfileMutation) ResetCurrencies() {
	m.currencies = nil
}

// SetNetWorthGoal sets the "net_worth_goal" field.
func (m *ProfileMutation) SetNetWorthGoal(d decimal.Decimal) {
	m.net_worth_goal = &d
	m.addnet_worth_goal = nil
}

// NetWorthGoal returns the value of the "net_worth_goal" field in the mutation.
func (m *ProfileMutation) NetWorthGoal() (r decimal.Decimal, exists bool) {
	v := m.net_worth_goal
	if v == nil {
		return
	}
	return *v, true
}

// OldNetWorthGoal returns the old "net_worth_goal" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldNetWorthGoal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetWorthGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetWorthGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetWorthGoal: %w", err)
	}
	return oldValue.NetWorthGoal, nil
}

// AddNetWorthGoal adds d to the "net_worth_goal" field.
func (m *ProfileMutation) AddNetWorthGoal(d decimal.Decimal) {
	if m.addnet_worth_goal != nil {
		*m.addnet_worth_goal = m.addnet_worth_goal.Add(d)
	} else {
		m.addnet_worth_goal = &d
	}
}

// AddedNetWorthGoal returns the value that was added to the "net_worth_goal" field in this mutation.
func (m *ProfileMutation) AddedNetWorthGoal() (r decimal.Decimal, exists bool) {
	v := m.addnet_worth_goal
	if v == nil {
		return
	}
	return *v, true
}

// ResetNetWorthGoal resets all changes to the "net_worth_goal" field.
func (m *ProfileMutation) ResetNetWorthGoal() {
	m.net_worth_goal = nil
	m.addnet_worth_goal = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProfileMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProfileMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddAccountIDs adds the "account" edge to the Account entity by ids.
func (m *ProfileMutation) AddAccountIDs(ids ...string) {
	if m.account == nil {
		m.account = make(map[string]struct{})
	}
	for i := range ids {
		m.account[ids[i]] = struct{}{}
	}
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *ProfileMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *ProfileMutation) AccountCleared() bool {
	return m.clearedaccount
}

// RemoveAccountIDs removes the "account" edge to the Account entity by IDs.
func (m *ProfileMutation) RemoveAccountIDs(ids ...string) {
	if m.removedaccount == nil {
		m.removedaccount = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.account, ids[i])
		m.removedaccount[ids[i]] = struct{}{}
	}
}

// RemovedAccount returns the removed IDs of the "account" edge to the Account entity.
func (m *ProfileMutation) RemovedAccountIDs() (ids []string) {
	for id := range m.removedaccount {
		ids = append(ids, id)
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
func (m *ProfileMutation) AccountIDs() (ids []string) {
	for id := range m.account {
		ids = append(ids, id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *ProfileMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
	m.removedaccount = nil
}

// AddTransactionIDs adds the "transaction" edge to the Transaction entity by ids.
func (m *ProfileMutation) AddTransactionIDs(ids ...string) {
	if m.transaction == nil {
		m.transaction = make(map[string]struct{})
	}
	for i := range ids {
		m.transaction[ids[i]] = struct{}{}
	}
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *ProfileMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *ProfileMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// RemoveTransactionIDs removes the "transaction" edge to the Transaction entity by IDs.
func (m *ProfileMutation) RemoveTransactionIDs(ids ...string) {
	if m.removedtransaction == nil {
		m.removedtransaction = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transaction, ids[i])
		m.removedtransaction[ids[i]] = struct{}{}
	}
}

// RemovedTransaction returns the removed IDs of the "transaction" edge to the Transaction entity.
func (m *ProfileMutation) RemovedTransactionIDs() (ids []string) {
	for id := range m.removedtransaction {
		ids = append(ids, id)
	}
	return
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
func (m *ProfileMutation) TransactionIDs() (ids []string) {
	for id := range m.transaction {
		ids = append(ids, id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *ProfileMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
	m.removedtransaction = nil
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, profile.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, profile.FieldUpdateTime)
	}
	if m.locale != nil {
		fields = append(fields, profile.FieldLocale)
	}
	if m.currencies != nil {
		fields = append(fields, profile.FieldCurrencies)
	}
	if m.net_worth_goal != nil {
		fields = append(fields, profile.FieldNetWorthGoal)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldCreateTime:
		return m.CreateTime()
	case profile.FieldUpdateTime:
		return m.UpdateTime()
	case profile.FieldLocale:
		return m.Locale()
	case profile.FieldCurrencies:
		return m.Currencies()
	case profile.FieldNetWorthGoal:
		return m.NetWorthGoal()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case profile.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case profile.FieldLocale:
		return m.OldLocale(ctx)
	case profile.FieldCurrencies:
		return m.OldCurrencies(ctx)
	case profile.FieldNetWorthGoal:
		return m.OldNetWorthGoal(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case profile.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case profile.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case profile.FieldCurrencies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencies(v)
		return nil
	case profile.FieldNetWorthGoal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetWorthGoal(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	var fields []string
	if m.addnet_worth_goal != nil {
		fields = append(fields, profile.FieldNetWorthGoal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldNetWorthGoal:
		return m.AddedNetWorthGoal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profile.FieldNetWorthGoal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetWorthGoal(v)
		return nil
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case profile.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case profile.FieldLocale:
		m.ResetLocale()
		return nil
	case profile.FieldCurrencies:
		m.ResetCurrencies()
		return nil
	case profile.FieldNetWorthGoal:
		m.ResetNetWorthGoal()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, profile.EdgeUser)
	}
	if m.account != nil {
		edges = append(edges, profile.EdgeAccount)
	}
	if m.transaction != nil {
		edges = append(edges, profile.EdgeTransaction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case profile.EdgeAccount:
		ids := make([]ent.Value, 0, len(m.account))
		for id := range m.account {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeTransaction:
		ids := make([]ent.Value, 0, len(m.transaction))
		for id := range m.transaction {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedaccount != nil {
		edges = append(edges, profile.EdgeAccount)
	}
	if m.removedtransaction != nil {
		edges = append(edges, profile.EdgeTransaction)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeAccount:
		ids := make([]ent.Value, 0, len(m.removedaccount))
		for id := range m.removedaccount {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeTransaction:
		ids := make([]ent.Value, 0, len(m.removedtransaction))
		for id := range m.removedtransaction {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, profile.EdgeUser)
	}
	if m.clearedaccount {
		edges = append(edges, profile.EdgeAccount)
	}
	if m.clearedtransaction {
		edges = append(edges, profile.EdgeTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeUser:
		return m.cleareduser
	case profile.EdgeAccount:
		return m.clearedaccount
	case profile.EdgeTransaction:
		return m.clearedtransaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ResetUser()
		return nil
	case profile.EdgeAccount:
		m.ResetAccount()
		return nil
	case profile.EdgeTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	create_time                *time.Time
	update_time                *time.Time
	balance                    *decimal.Decimal
	addbalance                 *decimal.Decimal
	note                       *string
	datetime                   *time.Time
	clearedFields              map[string]struct{}
	profile                    *string
	clearedprofile             bool
	transaction_entries        map[string]struct{}
	removedtransaction_entries map[string]struct{}
	clearedtransaction_entries bool
	done                       bool
	oldValue                   func(context.Context) (*Transaction, error)
	predicates                 []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id string) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransactionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransactionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransactionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransactionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransactionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransactionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBalance sets the "balance" field.
func (m *TransactionMutation) SetBalance(d decimal.Decimal) {
	m.balance = &d
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *TransactionMutation) Balance() (r decimal.Decimal, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldBalance(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds d to the "balance" field.
func (m *TransactionMutation) AddBalance(d decimal.Decimal) {
	if m.addbalance != nil {
		*m.addbalance = m.addbalance.Add(d)
	} else {
		m.addbalance = &d
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *TransactionMutation) AddedBalance() (r decimal.Decimal, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *TransactionMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetNote sets the "note" field.
func (m *TransactionMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *TransactionMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *TransactionMutation) ClearNote() {
	m.note = nil
	m.clearedFields[transaction.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *TransactionMutation) NoteCleared() bool {
	_, ok := m.clearedFields[transaction.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *TransactionMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, transaction.FieldNote)
}

// SetDatetime sets the "datetime" field.
func (m *TransactionMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the value of the "datetime" field in the mutation.
func (m *TransactionMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old "datetime" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime resets all changes to the "datetime" field.
func (m *TransactionMutation) ResetDatetime() {
	m.datetime = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *TransactionMutation) SetProfileID(id string) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *TransactionMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *TransactionMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *TransactionMutation) ProfileID() (id string, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) ProfileIDs() (ids []string) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *TransactionMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddTransactionEntryIDs adds the "transaction_entries" edge to the TransactionEntry entity by ids.
func (m *TransactionMutation) AddTransactionEntryIDs(ids ...string) {
	if m.transaction_entries == nil {
		m.transaction_entries = make(map[string]struct{})
	}
	for i := range ids {
		m.transaction_entries[ids[i]] = struct{}{}
	}
}

// ClearTransactionEntries clears the "transaction_entries" edge to the TransactionEntry entity.
func (m *TransactionMutation) ClearTransactionEntries() {
	m.clearedtransaction_entries = true
}

// TransactionEntriesCleared reports if the "transaction_entries" edge to the TransactionEntry entity was cleared.
func (m *TransactionMutation) TransactionEntriesCleared() bool {
	return m.clearedtransaction_entries
}

// RemoveTransactionEntryIDs removes the "transaction_entries" edge to the TransactionEntry entity by IDs.
func (m *TransactionMutation) RemoveTransactionEntryIDs(ids ...string) {
	if m.removedtransaction_entries == nil {
		m.removedtransaction_entries = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transaction_entries, ids[i])
		m.removedtransaction_entries[ids[i]] = struct{}{}
	}
}

// RemovedTransactionEntries returns the removed IDs of the "transaction_entries" edge to the TransactionEntry entity.
func (m *TransactionMutation) RemovedTransactionEntriesIDs() (ids []string) {
	for id := range m.removedtransaction_entries {
		ids = append(ids, id)
	}
	return
}

// TransactionEntriesIDs returns the "transaction_entries" edge IDs in the mutation.
func (m *TransactionMutation) TransactionEntriesIDs() (ids []string) {
	for id := range m.transaction_entries {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionEntries resets all changes to the "transaction_entries" edge.
func (m *TransactionMutation) ResetTransactionEntries() {
	m.transaction_entries = nil
	m.clearedtransaction_entries = false
	m.removedtransaction_entries = nil
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, transaction.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transaction.FieldUpdateTime)
	}
	if m.balance != nil {
		fields = append(fields, transaction.FieldBalance)
	}
	if m.note != nil {
		fields = append(fields, transaction.FieldNote)
	}
	if m.datetime != nil {
		fields = append(fields, transaction.FieldDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldCreateTime:
		return m.CreateTime()
	case transaction.FieldUpdateTime:
		return m.UpdateTime()
	case transaction.FieldBalance:
		return m.Balance()
	case transaction.FieldNote:
		return m.Note()
	case transaction.FieldDatetime:
		return m.Datetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transaction.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transaction.FieldBalance:
		return m.OldBalance(ctx)
	case transaction.FieldNote:
		return m.OldNote(ctx)
	case transaction.FieldDatetime:
		return m.OldDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transaction.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transaction.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case transaction.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case transaction.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, transaction.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldNote) {
		fields = append(fields, transaction.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transaction.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transaction.FieldBalance:
		m.ResetBalance()
		return nil
	case transaction.FieldNote:
		m.ResetNote()
		return nil
	case transaction.FieldDatetime:
		m.ResetDatetime()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.profile != nil {
		edges = append(edges, transaction.EdgeProfile)
	}
	if m.transaction_entries != nil {
		edges = append(edges, transaction.EdgeTransactionEntries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.transaction_entries))
		for id := range m.transaction_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransaction_entries != nil {
		edges = append(edges, transaction.EdgeTransactionEntries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.removedtransaction_entries))
		for id := range m.removedtransaction_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprofile {
		edges = append(edges, transaction.EdgeProfile)
	}
	if m.clearedtransaction_entries {
		edges = append(edges, transaction.EdgeTransactionEntries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeProfile:
		return m.clearedprofile
	case transaction.EdgeTransactionEntries:
		return m.clearedtransaction_entries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeProfile:
		m.ResetProfile()
		return nil
	case transaction.EdgeTransactionEntries:
		m.ResetTransactionEntries()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// TransactionEntryMutation represents an operation that mutates the TransactionEntry nodes in the graph.
type TransactionEntryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	create_time        *time.Time
	update_time        *time.Time
	amount             *decimal.Decimal
	addamount          *decimal.Decimal
	value              *decimal.Decimal
	addvalue           *decimal.Decimal
	fx_rate            *decimal.Decimal
	addfx_rate         *decimal.Decimal
	balance            *decimal.Decimal
	addbalance         *decimal.Decimal
	clearedFields      map[string]struct{}
	account            *string
	clearedaccount     bool
	transaction        *string
	clearedtransaction bool
	done               bool
	oldValue           func(context.Context) (*TransactionEntry, error)
	predicates         []predicate.TransactionEntry
}

var _ ent.Mutation = (*TransactionEntryMutation)(nil)

// transactionentryOption allows management of the mutation configuration using functional options.
type transactionentryOption func(*TransactionEntryMutation)

// newTransactionEntryMutation creates new mutation for the TransactionEntry entity.
func newTransactionEntryMutation(c config, op Op, opts ...transactionentryOption) *TransactionEntryMutation {
	m := &TransactionEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionEntryID sets the ID field of the mutation.
func withTransactionEntryID(id string) transactionentryOption {
	return func(m *TransactionEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionEntry
		)
		m.oldValue = func(ctx context.Context) (*TransactionEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionEntry sets the old TransactionEntry of the mutation.
func withTransactionEntry(node *TransactionEntry) transactionentryOption {
	return func(m *TransactionEntryMutation) {
		m.oldValue = func(context.Context) (*TransactionEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransactionEntry entities.
func (m *TransactionEntryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionEntryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionEntryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransactionEntryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransactionEntryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransactionEntryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransactionEntryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransactionEntryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransactionEntryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAmount sets the "amount" field.
func (m *TransactionEntryMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionEntryMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *TransactionEntryMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionEntryMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionEntryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetValue sets the "value" field.
func (m *TransactionEntryMutation) SetValue(d decimal.Decimal) {
	m.value = &d
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *TransactionEntryMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds d to the "value" field.
func (m *TransactionEntryMutation) AddValue(d decimal.Decimal) {
	if m.addvalue != nil {
		*m.addvalue = m.addvalue.Add(d)
	} else {
		m.addvalue = &d
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *TransactionEntryMutation) AddedValue() (r decimal.Decimal, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *TransactionEntryMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetFxRate sets the "fx_rate" field.
func (m *TransactionEntryMutation) SetFxRate(d decimal.Decimal) {
	m.fx_rate = &d
	m.addfx_rate = nil
}

// FxRate returns the value of the "fx_rate" field in the mutation.
func (m *TransactionEntryMutation) FxRate() (r decimal.Decimal, exists bool) {
	v := m.fx_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFxRate returns the old "fx_rate" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldFxRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFxRate: %w", err)
	}
	return oldValue.FxRate, nil
}

// AddFxRate adds d to the "fx_rate" field.
func (m *TransactionEntryMutation) AddFxRate(d decimal.Decimal) {
	if m.addfx_rate != nil {
		*m.addfx_rate = m.addfx_rate.Add(d)
	} else {
		m.addfx_rate = &d
	}
}

// AddedFxRate returns the value that was added to the "fx_rate" field in this mutation.
func (m *TransactionEntryMutation) AddedFxRate() (r decimal.Decimal, exists bool) {
	v := m.addfx_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearFxRate clears the value of the "fx_rate" field.
func (m *TransactionEntryMutation) ClearFxRate() {
	m.fx_rate = nil
	m.addfx_rate = nil
	m.clearedFields[transactionentry.FieldFxRate] = struct{}{}
}

// FxRateCleared returns if the "fx_rate" field was cleared in this mutation.
func (m *TransactionEntryMutation) FxRateCleared() bool {
	_, ok := m.clearedFields[transactionentry.FieldFxRate]
	return ok
}

// ResetFxRate resets all changes to the "fx_rate" field.
func (m *TransactionEntryMutation) ResetFxRate() {
	m.fx_rate = nil
	m.addfx_rate = nil
	delete(m.clearedFields, transactionentry.FieldFxRate)
}

// SetBalance sets the "balance" field.
func (m *TransactionEntryMutation) SetBalance(d decimal.Decimal) {
	m.balance = &d
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *TransactionEntryMutation) Balance() (r decimal.Decimal, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldBalance(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds d to the "balance" field.
func (m *TransactionEntryMutation) AddBalance(d decimal.Decimal) {
	if m.addbalance != nil {
		*m.addbalance = m.addbalance.Add(d)
	} else {
		m.addbalance = &d
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *TransactionEntryMutation) AddedBalance() (r decimal.Decimal, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *TransactionEntryMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *TransactionEntryMutation) SetAccountID(id string) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *TransactionEntryMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *TransactionEntryMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *TransactionEntryMutation) AccountID() (id string, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *TransactionEntryMutation) AccountIDs() (ids []string) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *TransactionEntryMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetTransactionID sets the "transaction" edge to the Transaction entity by id.
func (m *TransactionEntryMutation) SetTransactionID(id string) {
	m.transaction = &id
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *TransactionEntryMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *TransactionEntryMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the "transaction" edge ID in the mutation.
func (m *TransactionEntryMutation) TransactionID() (id string, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *TransactionEntryMutation) TransactionIDs() (ids []string) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *TransactionEntryMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// Where appends a list predicates to the TransactionEntryMutation builder.
func (m *TransactionEntryMutation) Where(ps ...predicate.TransactionEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransactionEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransactionEntry).
func (m *TransactionEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionEntryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, transactionentry.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transactionentry.FieldUpdateTime)
	}
	if m.amount != nil {
		fields = append(fields, transactionentry.FieldAmount)
	}
	if m.value != nil {
		fields = append(fields, transactionentry.FieldValue)
	}
	if m.fx_rate != nil {
		fields = append(fields, transactionentry.FieldFxRate)
	}
	if m.balance != nil {
		fields = append(fields, transactionentry.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionentry.FieldCreateTime:
		return m.CreateTime()
	case transactionentry.FieldUpdateTime:
		return m.UpdateTime()
	case transactionentry.FieldAmount:
		return m.Amount()
	case transactionentry.FieldValue:
		return m.Value()
	case transactionentry.FieldFxRate:
		return m.FxRate()
	case transactionentry.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionentry.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transactionentry.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transactionentry.FieldAmount:
		return m.OldAmount(ctx)
	case transactionentry.FieldValue:
		return m.OldValue(ctx)
	case transactionentry.FieldFxRate:
		return m.OldFxRate(ctx)
	case transactionentry.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionentry.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transactionentry.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transactionentry.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transactionentry.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case transactionentry.FieldFxRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFxRate(v)
		return nil
	case transactionentry.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionEntryMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transactionentry.FieldAmount)
	}
	if m.addvalue != nil {
		fields = append(fields, transactionentry.FieldValue)
	}
	if m.addfx_rate != nil {
		fields = append(fields, transactionentry.FieldFxRate)
	}
	if m.addbalance != nil {
		fields = append(fields, transactionentry.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transactionentry.FieldAmount:
		return m.AddedAmount()
	case transactionentry.FieldValue:
		return m.AddedValue()
	case transactionentry.FieldFxRate:
		return m.AddedFxRate()
	case transactionentry.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transactionentry.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case transactionentry.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case transactionentry.FieldFxRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFxRate(v)
		return nil
	case transactionentry.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactionentry.FieldFxRate) {
		fields = append(fields, transactionentry.FieldFxRate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionEntryMutation) ClearField(name string) error {
	switch name {
	case transactionentry.FieldFxRate:
		m.ClearFxRate()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionEntryMutation) ResetField(name string) error {
	switch name {
	case transactionentry.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transactionentry.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transactionentry.FieldAmount:
		m.ResetAmount()
		return nil
	case transactionentry.FieldValue:
		m.ResetValue()
		return nil
	case transactionentry.FieldFxRate:
		m.ResetFxRate()
		return nil
	case transactionentry.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, transactionentry.EdgeAccount)
	}
	if m.transaction != nil {
		edges = append(edges, transactionentry.EdgeTransaction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactionentry.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case transactionentry.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, transactionentry.EdgeAccount)
	}
	if m.clearedtransaction {
		edges = append(edges, transactionentry.EdgeTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case transactionentry.EdgeAccount:
		return m.clearedaccount
	case transactionentry.EdgeTransaction:
		return m.clearedtransaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionEntryMutation) ClearEdge(name string) error {
	switch name {
	case transactionentry.EdgeAccount:
		m.ClearAccount()
		return nil
	case transactionentry.EdgeTransaction:
		m.ClearTransaction()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionEntryMutation) ResetEdge(name string) error {
	switch name {
	case transactionentry.EdgeAccount:
		m.ResetAccount()
		return nil
	case transactionentry.EdgeTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *string
	create_time     *time.Time
	update_time     *time.Time
	email           *string
	clearedFields   map[string]struct{}
	user_key        map[string]struct{}
	removeduser_key map[string]struct{}
	cleareduser_key bool
	profile         map[string]struct{}
	removedprofile  map[string]struct{}
	clearedprofile  bool
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddUserKeyIDs adds the "user_key" edge to the UserKey entity by ids.
func (m *UserMutation) AddUserKeyIDs(ids ...string) {
	if m.user_key == nil {
		m.user_key = make(map[string]struct{})
	}
	for i := range ids {
		m.user_key[ids[i]] = struct{}{}
	}
}

// ClearUserKey clears the "user_key" edge to the UserKey entity.
func (m *UserMutation) ClearUserKey() {
	m.cleareduser_key = true
}

// UserKeyCleared reports if the "user_key" edge to the UserKey entity was cleared.
func (m *UserMutation) UserKeyCleared() bool {
	return m.cleareduser_key
}

// RemoveUserKeyIDs removes the "user_key" edge to the UserKey entity by IDs.
func (m *UserMutation) RemoveUserKeyIDs(ids ...string) {
	if m.removeduser_key == nil {
		m.removeduser_key = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_key, ids[i])
		m.removeduser_key[ids[i]] = struct{}{}
	}
}

// RemovedUserKey returns the removed IDs of the "user_key" edge to the UserKey entity.
func (m *UserMutation) RemovedUserKeyIDs() (ids []string) {
	for id := range m.removeduser_key {
		ids = append(ids, id)
	}
	return
}

// UserKeyIDs returns the "user_key" edge IDs in the mutation.
func (m *UserMutation) UserKeyIDs() (ids []string) {
	for id := range m.user_key {
		ids = append(ids, id)
	}
	return
}

// ResetUserKey resets all changes to the "user_key" edge.
func (m *UserMutation) ResetUserKey() {
	m.user_key = nil
	m.cleareduser_key = false
	m.removeduser_key = nil
}

// AddProfileIDs adds the "profile" edge to the Profile entity by ids.
func (m *UserMutation) AddProfileIDs(ids ...string) {
	if m.profile == nil {
		m.profile = make(map[string]struct{})
	}
	for i := range ids {
		m.profile[ids[i]] = struct{}{}
	}
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *UserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *UserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// RemoveProfileIDs removes the "profile" edge to the Profile entity by IDs.
func (m *UserMutation) RemoveProfileIDs(ids ...string) {
	if m.removedprofile == nil {
		m.removedprofile = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.profile, ids[i])
		m.removedprofile[ids[i]] = struct{}{}
	}
}

// RemovedProfile returns the removed IDs of the "profile" edge to the Profile entity.
func (m *UserMutation) RemovedProfileIDs() (ids []string) {
	for id := range m.removedprofile {
		ids = append(ids, id)
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
func (m *UserMutation) ProfileIDs() (ids []string) {
	for id := range m.profile {
		ids = append(ids, id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
	m.removedprofile = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_key != nil {
		edges = append(edges, user.EdgeUserKey)
	}
	if m.profile != nil {
		edges = append(edges, user.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserKey:
		ids := make([]ent.Value, 0, len(m.user_key))
		for id := range m.user_key {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfile:
		ids := make([]ent.Value, 0, len(m.profile))
		for id := range m.profile {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_key != nil {
		edges = append(edges, user.EdgeUserKey)
	}
	if m.removedprofile != nil {
		edges = append(edges, user.EdgeProfile)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserKey:
		ids := make([]ent.Value, 0, len(m.removeduser_key))
		for id := range m.removeduser_key {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfile:
		ids := make([]ent.Value, 0, len(m.removedprofile))
		for id := range m.removedprofile {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_key {
		edges = append(edges, user.EdgeUserKey)
	}
	if m.clearedprofile {
		edges = append(edges, user.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserKey:
		return m.cleareduser_key
	case user.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserKey:
		m.ResetUserKey()
		return nil
	case user.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserKeyMutation represents an operation that mutates the UserKey nodes in the graph.
type UserKeyMutation struct {
	config
	op              Op
	typ             string
	id              *string
	create_time     *time.Time
	update_time     *time.Time
	hashed_password *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*UserKey, error)
	predicates      []predicate.UserKey
}

var _ ent.Mutation = (*UserKeyMutation)(nil)

// userkeyOption allows management of the mutation configuration using functional options.
type userkeyOption func(*UserKeyMutation)

// newUserKeyMutation creates new mutation for the UserKey entity.
func newUserKeyMutation(c config, op Op, opts ...userkeyOption) *UserKeyMutation {
	m := &UserKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeUserKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserKeyID sets the ID field of the mutation.
func withUserKeyID(id string) userkeyOption {
	return func(m *UserKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *UserKey
		)
		m.oldValue = func(ctx context.Context) (*UserKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserKey sets the old UserKey of the mutation.
func withUserKey(node *UserKey) userkeyOption {
	return func(m *UserKeyMutation) {
		m.oldValue = func(context.Context) (*UserKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserKey entities.
func (m *UserKeyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserKeyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserKeyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserKeyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserKeyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserKeyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserKeyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserKeyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserKeyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *UserKeyMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *UserKeyMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ClearHashedPassword clears the value of the "hashed_password" field.
func (m *UserKeyMutation) ClearHashedPassword() {
	m.hashed_password = nil
	m.clearedFields[userkey.FieldHashedPassword] = struct{}{}
}

// HashedPasswordCleared returns if the "hashed_password" field was cleared in this mutation.
func (m *UserKeyMutation) HashedPasswordCleared() bool {
	_, ok := m.clearedFields[userkey.FieldHashedPassword]
	return ok
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *UserKeyMutation) ResetHashedPassword() {
	m.hashed_password = nil
	delete(m.clearedFields, userkey.FieldHashedPassword)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserKeyMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserKeyMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserKeyMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserKeyMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserKeyMutation builder.
func (m *UserKeyMutation) Where(ps ...predicate.UserKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserKey).
func (m *UserKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserKeyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, userkey.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userkey.FieldUpdateTime)
	}
	if m.hashed_password != nil {
		fields = append(fields, userkey.FieldHashedPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userkey.FieldCreateTime:
		return m.CreateTime()
	case userkey.FieldUpdateTime:
		return m.UpdateTime()
	case userkey.FieldHashedPassword:
		return m.HashedPassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userkey.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userkey.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userkey.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	}
	return nil, fmt.Errorf("unknown UserKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userkey.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userkey.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userkey.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	}
	return fmt.Errorf("unknown UserKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userkey.FieldHashedPassword) {
		fields = append(fields, userkey.FieldHashedPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserKeyMutation) ClearField(name string) error {
	switch name {
	case userkey.FieldHashedPassword:
		m.ClearHashedPassword()
		return nil
	}
	return fmt.Errorf("unknown UserKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserKeyMutation) ResetField(name string) error {
	switch name {
	case userkey.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userkey.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userkey.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	}
	return fmt.Errorf("unknown UserKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userkey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userkey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userkey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case userkey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserKeyMutation) ClearEdge(name string) error {
	switch name {
	case userkey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserKeyMutation) ResetEdge(name string) error {
	switch name {
	case userkey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserKey edge %s", name)
}
