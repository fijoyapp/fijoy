// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fijoy/ent/account"
	"fijoy/ent/category"
	"fijoy/ent/predicate"
	"fijoy/ent/profile"
	"fijoy/ent/snapshot"
	"fijoy/ent/snapshotaccount"
	"fijoy/ent/snapshotfxrate"
	"fijoy/ent/transaction"
	"fijoy/ent/transactionentry"
	"fijoy/ent/user"
	"fijoy/ent/userkey"
	"fijoy/ent/userprofile"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount          = "Account"
	TypeCategory         = "Category"
	TypeProfile          = "Profile"
	TypeSnapshot         = "Snapshot"
	TypeSnapshotAccount  = "SnapshotAccount"
	TypeSnapshotFXRate   = "SnapshotFXRate"
	TypeTransaction      = "Transaction"
	TypeTransactionEntry = "TransactionEntry"
	TypeUser             = "User"
	TypeUserKey          = "UserKey"
	TypeUserProfile      = "UserProfile"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	update_time                *time.Time
	name                       *string
	institution                *string
	account_type               *account.AccountType
	investment_type            *account.InvestmentType
	currency_code              *string
	ticker                     *string
	ticker_type                *account.TickerType
	amount                     *decimal.Decimal
	addamount                  *decimal.Decimal
	value                      *decimal.Decimal
	addvalue                   *decimal.Decimal
	balance                    *decimal.Decimal
	addbalance                 *decimal.Decimal
	archived                   *bool
	clearedFields              map[string]struct{}
	profile                    *int
	clearedprofile             bool
	transaction_entries        map[int]struct{}
	removedtransaction_entries map[int]struct{}
	clearedtransaction_entries bool
	snapshot_accounts          map[int]struct{}
	removedsnapshot_accounts   map[int]struct{}
	clearedsnapshot_accounts   bool
	done                       bool
	oldValue                   func(context.Context) (*Account, error)
	predicates                 []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AccountMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AccountMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AccountMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AccountMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AccountMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AccountMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetInstitution sets the "institution" field.
func (m *AccountMutation) SetInstitution(s string) {
	m.institution = &s
}

// Institution returns the value of the "institution" field in the mutation.
func (m *AccountMutation) Institution() (r string, exists bool) {
	v := m.institution
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitution returns the old "institution" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldInstitution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitution: %w", err)
	}
	return oldValue.Institution, nil
}

// ResetInstitution resets all changes to the "institution" field.
func (m *AccountMutation) ResetInstitution() {
	m.institution = nil
}

// SetAccountType sets the "account_type" field.
func (m *AccountMutation) SetAccountType(at account.AccountType) {
	m.account_type = &at
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *AccountMutation) AccountType() (r account.AccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccountType(ctx context.Context) (v account.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *AccountMutation) ResetAccountType() {
	m.account_type = nil
}

// SetInvestmentType sets the "investment_type" field.
func (m *AccountMutation) SetInvestmentType(at account.InvestmentType) {
	m.investment_type = &at
}

// InvestmentType returns the value of the "investment_type" field in the mutation.
func (m *AccountMutation) InvestmentType() (r account.InvestmentType, exists bool) {
	v := m.investment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInvestmentType returns the old "investment_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldInvestmentType(ctx context.Context) (v account.InvestmentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvestmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvestmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvestmentType: %w", err)
	}
	return oldValue.InvestmentType, nil
}

// ResetInvestmentType resets all changes to the "investment_type" field.
func (m *AccountMutation) ResetInvestmentType() {
	m.investment_type = nil
}

// SetCurrencyCode sets the "currency_code" field.
func (m *AccountMutation) SetCurrencyCode(s string) {
	m.currency_code = &s
}

// CurrencyCode returns the value of the "currency_code" field in the mutation.
func (m *AccountMutation) CurrencyCode() (r string, exists bool) {
	v := m.currency_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyCode returns the old "currency_code" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCurrencyCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyCode: %w", err)
	}
	return oldValue.CurrencyCode, nil
}

// ResetCurrencyCode resets all changes to the "currency_code" field.
func (m *AccountMutation) ResetCurrencyCode() {
	m.currency_code = nil
}

// SetTicker sets the "ticker" field.
func (m *AccountMutation) SetTicker(s string) {
	m.ticker = &s
}

// Ticker returns the value of the "ticker" field in the mutation.
func (m *AccountMutation) Ticker() (r string, exists bool) {
	v := m.ticker
	if v == nil {
		return
	}
	return *v, true
}

// OldTicker returns the old "ticker" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTicker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicker: %w", err)
	}
	return oldValue.Ticker, nil
}

// ResetTicker resets all changes to the "ticker" field.
func (m *AccountMutation) ResetTicker() {
	m.ticker = nil
}

// SetTickerType sets the "ticker_type" field.
func (m *AccountMutation) SetTickerType(at account.TickerType) {
	m.ticker_type = &at
}

// TickerType returns the value of the "ticker_type" field in the mutation.
func (m *AccountMutation) TickerType() (r account.TickerType, exists bool) {
	v := m.ticker_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTickerType returns the old "ticker_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTickerType(ctx context.Context) (v account.TickerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTickerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTickerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTickerType: %w", err)
	}
	return oldValue.TickerType, nil
}

// ResetTickerType resets all changes to the "ticker_type" field.
func (m *AccountMutation) ResetTickerType() {
	m.ticker_type = nil
}

// SetAmount sets the "amount" field.
func (m *AccountMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AccountMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *AccountMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AccountMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *AccountMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetValue sets the "value" field.
func (m *AccountMutation) SetValue(d decimal.Decimal) {
	m.value = &d
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *AccountMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds d to the "value" field.
func (m *AccountMutation) AddValue(d decimal.Decimal) {
	if m.addvalue != nil {
		*m.addvalue = m.addvalue.Add(d)
	} else {
		m.addvalue = &d
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *AccountMutation) AddedValue() (r decimal.Decimal, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *AccountMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetBalance sets the "balance" field.
func (m *AccountMutation) SetBalance(d decimal.Decimal) {
	m.balance = &d
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *AccountMutation) Balance() (r decimal.Decimal, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBalance(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds d to the "balance" field.
func (m *AccountMutation) AddBalance(d decimal.Decimal) {
	if m.addbalance != nil {
		*m.addbalance = m.addbalance.Add(d)
	} else {
		m.addbalance = &d
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *AccountMutation) AddedBalance() (r decimal.Decimal, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *AccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetArchived sets the "archived" field.
func (m *AccountMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *AccountMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *AccountMutation) ResetArchived() {
	m.archived = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *AccountMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *AccountMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *AccountMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *AccountMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *AccountMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddTransactionEntryIDs adds the "transaction_entries" edge to the TransactionEntry entity by ids.
func (m *AccountMutation) AddTransactionEntryIDs(ids ...int) {
	if m.transaction_entries == nil {
		m.transaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_entries[ids[i]] = struct{}{}
	}
}

// ClearTransactionEntries clears the "transaction_entries" edge to the TransactionEntry entity.
func (m *AccountMutation) ClearTransactionEntries() {
	m.clearedtransaction_entries = true
}

// TransactionEntriesCleared reports if the "transaction_entries" edge to the TransactionEntry entity was cleared.
func (m *AccountMutation) TransactionEntriesCleared() bool {
	return m.clearedtransaction_entries
}

// RemoveTransactionEntryIDs removes the "transaction_entries" edge to the TransactionEntry entity by IDs.
func (m *AccountMutation) RemoveTransactionEntryIDs(ids ...int) {
	if m.removedtransaction_entries == nil {
		m.removedtransaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_entries, ids[i])
		m.removedtransaction_entries[ids[i]] = struct{}{}
	}
}

// RemovedTransactionEntries returns the removed IDs of the "transaction_entries" edge to the TransactionEntry entity.
func (m *AccountMutation) RemovedTransactionEntriesIDs() (ids []int) {
	for id := range m.removedtransaction_entries {
		ids = append(ids, id)
	}
	return
}

// TransactionEntriesIDs returns the "transaction_entries" edge IDs in the mutation.
func (m *AccountMutation) TransactionEntriesIDs() (ids []int) {
	for id := range m.transaction_entries {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionEntries resets all changes to the "transaction_entries" edge.
func (m *AccountMutation) ResetTransactionEntries() {
	m.transaction_entries = nil
	m.clearedtransaction_entries = false
	m.removedtransaction_entries = nil
}

// AddSnapshotAccountIDs adds the "snapshot_accounts" edge to the SnapshotAccount entity by ids.
func (m *AccountMutation) AddSnapshotAccountIDs(ids ...int) {
	if m.snapshot_accounts == nil {
		m.snapshot_accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.snapshot_accounts[ids[i]] = struct{}{}
	}
}

// ClearSnapshotAccounts clears the "snapshot_accounts" edge to the SnapshotAccount entity.
func (m *AccountMutation) ClearSnapshotAccounts() {
	m.clearedsnapshot_accounts = true
}

// SnapshotAccountsCleared reports if the "snapshot_accounts" edge to the SnapshotAccount entity was cleared.
func (m *AccountMutation) SnapshotAccountsCleared() bool {
	return m.clearedsnapshot_accounts
}

// RemoveSnapshotAccountIDs removes the "snapshot_accounts" edge to the SnapshotAccount entity by IDs.
func (m *AccountMutation) RemoveSnapshotAccountIDs(ids ...int) {
	if m.removedsnapshot_accounts == nil {
		m.removedsnapshot_accounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.snapshot_accounts, ids[i])
		m.removedsnapshot_accounts[ids[i]] = struct{}{}
	}
}

// RemovedSnapshotAccounts returns the removed IDs of the "snapshot_accounts" edge to the SnapshotAccount entity.
func (m *AccountMutation) RemovedSnapshotAccountsIDs() (ids []int) {
	for id := range m.removedsnapshot_accounts {
		ids = append(ids, id)
	}
	return
}

// SnapshotAccountsIDs returns the "snapshot_accounts" edge IDs in the mutation.
func (m *AccountMutation) SnapshotAccountsIDs() (ids []int) {
	for id := range m.snapshot_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetSnapshotAccounts resets all changes to the "snapshot_accounts" edge.
func (m *AccountMutation) ResetSnapshotAccounts() {
	m.snapshot_accounts = nil
	m.clearedsnapshot_accounts = false
	m.removedsnapshot_accounts = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_time != nil {
		fields = append(fields, account.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, account.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.institution != nil {
		fields = append(fields, account.FieldInstitution)
	}
	if m.account_type != nil {
		fields = append(fields, account.FieldAccountType)
	}
	if m.investment_type != nil {
		fields = append(fields, account.FieldInvestmentType)
	}
	if m.currency_code != nil {
		fields = append(fields, account.FieldCurrencyCode)
	}
	if m.ticker != nil {
		fields = append(fields, account.FieldTicker)
	}
	if m.ticker_type != nil {
		fields = append(fields, account.FieldTickerType)
	}
	if m.amount != nil {
		fields = append(fields, account.FieldAmount)
	}
	if m.value != nil {
		fields = append(fields, account.FieldValue)
	}
	if m.balance != nil {
		fields = append(fields, account.FieldBalance)
	}
	if m.archived != nil {
		fields = append(fields, account.FieldArchived)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreateTime:
		return m.CreateTime()
	case account.FieldUpdateTime:
		return m.UpdateTime()
	case account.FieldName:
		return m.Name()
	case account.FieldInstitution:
		return m.Institution()
	case account.FieldAccountType:
		return m.AccountType()
	case account.FieldInvestmentType:
		return m.InvestmentType()
	case account.FieldCurrencyCode:
		return m.CurrencyCode()
	case account.FieldTicker:
		return m.Ticker()
	case account.FieldTickerType:
		return m.TickerType()
	case account.FieldAmount:
		return m.Amount()
	case account.FieldValue:
		return m.Value()
	case account.FieldBalance:
		return m.Balance()
	case account.FieldArchived:
		return m.Archived()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case account.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldInstitution:
		return m.OldInstitution(ctx)
	case account.FieldAccountType:
		return m.OldAccountType(ctx)
	case account.FieldInvestmentType:
		return m.OldInvestmentType(ctx)
	case account.FieldCurrencyCode:
		return m.OldCurrencyCode(ctx)
	case account.FieldTicker:
		return m.OldTicker(ctx)
	case account.FieldTickerType:
		return m.OldTickerType(ctx)
	case account.FieldAmount:
		return m.OldAmount(ctx)
	case account.FieldValue:
		return m.OldValue(ctx)
	case account.FieldBalance:
		return m.OldBalance(ctx)
	case account.FieldArchived:
		return m.OldArchived(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case account.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldInstitution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitution(v)
		return nil
	case account.FieldAccountType:
		v, ok := value.(account.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case account.FieldInvestmentType:
		v, ok := value.(account.InvestmentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvestmentType(v)
		return nil
	case account.FieldCurrencyCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyCode(v)
		return nil
	case account.FieldTicker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicker(v)
		return nil
	case account.FieldTickerType:
		v, ok := value.(account.TickerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTickerType(v)
		return nil
	case account.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case account.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case account.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, account.FieldAmount)
	}
	if m.addvalue != nil {
		fields = append(fields, account.FieldValue)
	}
	if m.addbalance != nil {
		fields = append(fields, account.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldAmount:
		return m.AddedAmount()
	case account.FieldValue:
		return m.AddedValue()
	case account.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case account.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case account.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldInstitution:
		m.ResetInstitution()
		return nil
	case account.FieldAccountType:
		m.ResetAccountType()
		return nil
	case account.FieldInvestmentType:
		m.ResetInvestmentType()
		return nil
	case account.FieldCurrencyCode:
		m.ResetCurrencyCode()
		return nil
	case account.FieldTicker:
		m.ResetTicker()
		return nil
	case account.FieldTickerType:
		m.ResetTickerType()
		return nil
	case account.FieldAmount:
		m.ResetAmount()
		return nil
	case account.FieldValue:
		m.ResetValue()
		return nil
	case account.FieldBalance:
		m.ResetBalance()
		return nil
	case account.FieldArchived:
		m.ResetArchived()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.profile != nil {
		edges = append(edges, account.EdgeProfile)
	}
	if m.transaction_entries != nil {
		edges = append(edges, account.EdgeTransactionEntries)
	}
	if m.snapshot_accounts != nil {
		edges = append(edges, account.EdgeSnapshotAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.transaction_entries))
		for id := range m.transaction_entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeSnapshotAccounts:
		ids := make([]ent.Value, 0, len(m.snapshot_accounts))
		for id := range m.snapshot_accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtransaction_entries != nil {
		edges = append(edges, account.EdgeTransactionEntries)
	}
	if m.removedsnapshot_accounts != nil {
		edges = append(edges, account.EdgeSnapshotAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.removedtransaction_entries))
		for id := range m.removedtransaction_entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeSnapshotAccounts:
		ids := make([]ent.Value, 0, len(m.removedsnapshot_accounts))
		for id := range m.removedsnapshot_accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprofile {
		edges = append(edges, account.EdgeProfile)
	}
	if m.clearedtransaction_entries {
		edges = append(edges, account.EdgeTransactionEntries)
	}
	if m.clearedsnapshot_accounts {
		edges = append(edges, account.EdgeSnapshotAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeProfile:
		return m.clearedprofile
	case account.EdgeTransactionEntries:
		return m.clearedtransaction_entries
	case account.EdgeSnapshotAccounts:
		return m.clearedsnapshot_accounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeProfile:
		m.ResetProfile()
		return nil
	case account.EdgeTransactionEntries:
		m.ResetTransactionEntries()
		return nil
	case account.EdgeSnapshotAccounts:
		m.ResetSnapshotAccounts()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	name                *string
	category_type       *category.CategoryType
	clearedFields       map[string]struct{}
	profile             *int
	clearedprofile      bool
	transactions        map[int]struct{}
	removedtransactions map[int]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*Category, error)
	predicates          []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetCategoryType sets the "category_type" field.
func (m *CategoryMutation) SetCategoryType(ct category.CategoryType) {
	m.category_type = &ct
}

// CategoryType returns the value of the "category_type" field in the mutation.
func (m *CategoryMutation) CategoryType() (r category.CategoryType, exists bool) {
	v := m.category_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryType returns the old "category_type" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCategoryType(ctx context.Context) (v category.CategoryType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryType: %w", err)
	}
	return oldValue.CategoryType, nil
}

// ResetCategoryType resets all changes to the "category_type" field.
func (m *CategoryMutation) ResetCategoryType() {
	m.category_type = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *CategoryMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *CategoryMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *CategoryMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *CategoryMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *CategoryMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *CategoryMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *CategoryMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *CategoryMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *CategoryMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *CategoryMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *CategoryMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *CategoryMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, category.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, category.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.category_type != nil {
		fields = append(fields, category.FieldCategoryType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreateTime:
		return m.CreateTime()
	case category.FieldUpdateTime:
		return m.UpdateTime()
	case category.FieldName:
		return m.Name()
	case category.FieldCategoryType:
		return m.CategoryType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case category.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldCategoryType:
		return m.OldCategoryType(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case category.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldCategoryType:
		v, ok := value.(category.CategoryType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryType(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case category.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldCategoryType:
		m.ResetCategoryType()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.profile != nil {
		edges = append(edges, category.EdgeProfile)
	}
	if m.transactions != nil {
		edges = append(edges, category.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransactions != nil {
		edges = append(edges, category.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprofile {
		edges = append(edges, category.EdgeProfile)
	}
	if m.clearedtransactions {
		edges = append(edges, category.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeProfile:
		return m.clearedprofile
	case category.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeProfile:
		m.ResetProfile()
		return nil
	case category.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	name                *string
	locale              *string
	currencies          *[]string
	appendcurrencies    []string
	net_worth_goal      *decimal.Decimal
	addnet_worth_goal   *decimal.Decimal
	clearedFields       map[string]struct{}
	users               map[int]struct{}
	removedusers        map[int]struct{}
	clearedusers        bool
	accounts            map[int]struct{}
	removedaccounts     map[int]struct{}
	clearedaccounts     bool
	transactions        map[int]struct{}
	removedtransactions map[int]struct{}
	clearedtransactions bool
	snapshots           map[int]struct{}
	removedsnapshots    map[int]struct{}
	clearedsnapshots    bool
	categories          map[int]struct{}
	removedcategories   map[int]struct{}
	clearedcategories   bool
	done                bool
	oldValue            func(context.Context) (*Profile, error)
	predicates          []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id int) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ProfileMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProfileMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProfileMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProfileMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProfileMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProfileMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *ProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProfileMutation) ResetName() {
	m.name = nil
}

// SetLocale sets the "locale" field.
func (m *ProfileMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *ProfileMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *ProfileMutation) ResetLocale() {
	m.locale = nil
}

// SetCurrencies sets the "currencies" field.
func (m *ProfileMutation) SetCurrencies(s []string) {
	m.currencies = &s
	m.appendcurrencies = nil
}

// Currencies returns the value of the "currencies" field in the mutation.
func (m *ProfileMutation) Currencies() (r []string, exists bool) {
	v := m.currencies
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencies returns the old "currencies" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCurrencies(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencies: %w", err)
	}
	return oldValue.Currencies, nil
}

// AppendCurrencies adds s to the "currencies" field.
func (m *ProfileMutation) AppendCurrencies(s []string) {
	m.appendcurrencies = append(m.appendcurrencies, s...)
}

// AppendedCurrencies returns the list of values that were appended to the "currencies" field in this mutation.
func (m *ProfileMutation) AppendedCurrencies() ([]string, bool) {
	if len(m.appendcurrencies) == 0 {
		return nil, false
	}
	return m.appendcurrencies, true
}

// ResetCurrencies resets all changes to the "currencies" field.
func (m *ProfileMutation) ResetCurrencies() {
	m.currencies = nil
	m.appendcurrencies = nil
}

// SetNetWorthGoal sets the "net_worth_goal" field.
func (m *ProfileMutation) SetNetWorthGoal(d decimal.Decimal) {
	m.net_worth_goal = &d
	m.addnet_worth_goal = nil
}

// NetWorthGoal returns the value of the "net_worth_goal" field in the mutation.
func (m *ProfileMutation) NetWorthGoal() (r decimal.Decimal, exists bool) {
	v := m.net_worth_goal
	if v == nil {
		return
	}
	return *v, true
}

// OldNetWorthGoal returns the old "net_worth_goal" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldNetWorthGoal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetWorthGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetWorthGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetWorthGoal: %w", err)
	}
	return oldValue.NetWorthGoal, nil
}

// AddNetWorthGoal adds d to the "net_worth_goal" field.
func (m *ProfileMutation) AddNetWorthGoal(d decimal.Decimal) {
	if m.addnet_worth_goal != nil {
		*m.addnet_worth_goal = m.addnet_worth_goal.Add(d)
	} else {
		m.addnet_worth_goal = &d
	}
}

// AddedNetWorthGoal returns the value that was added to the "net_worth_goal" field in this mutation.
func (m *ProfileMutation) AddedNetWorthGoal() (r decimal.Decimal, exists bool) {
	v := m.addnet_worth_goal
	if v == nil {
		return
	}
	return *v, true
}

// ResetNetWorthGoal resets all changes to the "net_worth_goal" field.
func (m *ProfileMutation) ResetNetWorthGoal() {
	m.net_worth_goal = nil
	m.addnet_worth_goal = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *ProfileMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ProfileMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ProfileMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *ProfileMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *ProfileMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *ProfileMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ProfileMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *ProfileMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *ProfileMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *ProfileMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *ProfileMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *ProfileMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *ProfileMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *ProfileMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *ProfileMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *ProfileMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *ProfileMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *ProfileMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *ProfileMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *ProfileMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *ProfileMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddSnapshotIDs adds the "snapshots" edge to the Snapshot entity by ids.
func (m *ProfileMutation) AddSnapshotIDs(ids ...int) {
	if m.snapshots == nil {
		m.snapshots = make(map[int]struct{})
	}
	for i := range ids {
		m.snapshots[ids[i]] = struct{}{}
	}
}

// ClearSnapshots clears the "snapshots" edge to the Snapshot entity.
func (m *ProfileMutation) ClearSnapshots() {
	m.clearedsnapshots = true
}

// SnapshotsCleared reports if the "snapshots" edge to the Snapshot entity was cleared.
func (m *ProfileMutation) SnapshotsCleared() bool {
	return m.clearedsnapshots
}

// RemoveSnapshotIDs removes the "snapshots" edge to the Snapshot entity by IDs.
func (m *ProfileMutation) RemoveSnapshotIDs(ids ...int) {
	if m.removedsnapshots == nil {
		m.removedsnapshots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.snapshots, ids[i])
		m.removedsnapshots[ids[i]] = struct{}{}
	}
}

// RemovedSnapshots returns the removed IDs of the "snapshots" edge to the Snapshot entity.
func (m *ProfileMutation) RemovedSnapshotsIDs() (ids []int) {
	for id := range m.removedsnapshots {
		ids = append(ids, id)
	}
	return
}

// SnapshotsIDs returns the "snapshots" edge IDs in the mutation.
func (m *ProfileMutation) SnapshotsIDs() (ids []int) {
	for id := range m.snapshots {
		ids = append(ids, id)
	}
	return
}

// ResetSnapshots resets all changes to the "snapshots" edge.
func (m *ProfileMutation) ResetSnapshots() {
	m.snapshots = nil
	m.clearedsnapshots = false
	m.removedsnapshots = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *ProfileMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *ProfileMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *ProfileMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *ProfileMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *ProfileMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *ProfileMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *ProfileMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, profile.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, profile.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, profile.FieldName)
	}
	if m.locale != nil {
		fields = append(fields, profile.FieldLocale)
	}
	if m.currencies != nil {
		fields = append(fields, profile.FieldCurrencies)
	}
	if m.net_worth_goal != nil {
		fields = append(fields, profile.FieldNetWorthGoal)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldCreateTime:
		return m.CreateTime()
	case profile.FieldUpdateTime:
		return m.UpdateTime()
	case profile.FieldName:
		return m.Name()
	case profile.FieldLocale:
		return m.Locale()
	case profile.FieldCurrencies:
		return m.Currencies()
	case profile.FieldNetWorthGoal:
		return m.NetWorthGoal()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case profile.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case profile.FieldName:
		return m.OldName(ctx)
	case profile.FieldLocale:
		return m.OldLocale(ctx)
	case profile.FieldCurrencies:
		return m.OldCurrencies(ctx)
	case profile.FieldNetWorthGoal:
		return m.OldNetWorthGoal(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case profile.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case profile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case profile.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case profile.FieldCurrencies:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencies(v)
		return nil
	case profile.FieldNetWorthGoal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetWorthGoal(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	var fields []string
	if m.addnet_worth_goal != nil {
		fields = append(fields, profile.FieldNetWorthGoal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldNetWorthGoal:
		return m.AddedNetWorthGoal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profile.FieldNetWorthGoal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetWorthGoal(v)
		return nil
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case profile.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case profile.FieldName:
		m.ResetName()
		return nil
	case profile.FieldLocale:
		m.ResetLocale()
		return nil
	case profile.FieldCurrencies:
		m.ResetCurrencies()
		return nil
	case profile.FieldNetWorthGoal:
		m.ResetNetWorthGoal()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.users != nil {
		edges = append(edges, profile.EdgeUsers)
	}
	if m.accounts != nil {
		edges = append(edges, profile.EdgeAccounts)
	}
	if m.transactions != nil {
		edges = append(edges, profile.EdgeTransactions)
	}
	if m.snapshots != nil {
		edges = append(edges, profile.EdgeSnapshots)
	}
	if m.categories != nil {
		edges = append(edges, profile.EdgeCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeSnapshots:
		ids := make([]ent.Value, 0, len(m.snapshots))
		for id := range m.snapshots {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedusers != nil {
		edges = append(edges, profile.EdgeUsers)
	}
	if m.removedaccounts != nil {
		edges = append(edges, profile.EdgeAccounts)
	}
	if m.removedtransactions != nil {
		edges = append(edges, profile.EdgeTransactions)
	}
	if m.removedsnapshots != nil {
		edges = append(edges, profile.EdgeSnapshots)
	}
	if m.removedcategories != nil {
		edges = append(edges, profile.EdgeCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeSnapshots:
		ids := make([]ent.Value, 0, len(m.removedsnapshots))
		for id := range m.removedsnapshots {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedusers {
		edges = append(edges, profile.EdgeUsers)
	}
	if m.clearedaccounts {
		edges = append(edges, profile.EdgeAccounts)
	}
	if m.clearedtransactions {
		edges = append(edges, profile.EdgeTransactions)
	}
	if m.clearedsnapshots {
		edges = append(edges, profile.EdgeSnapshots)
	}
	if m.clearedcategories {
		edges = append(edges, profile.EdgeCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeUsers:
		return m.clearedusers
	case profile.EdgeAccounts:
		return m.clearedaccounts
	case profile.EdgeTransactions:
		return m.clearedtransactions
	case profile.EdgeSnapshots:
		return m.clearedsnapshots
	case profile.EdgeCategories:
		return m.clearedcategories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeUsers:
		m.ResetUsers()
		return nil
	case profile.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case profile.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case profile.EdgeSnapshots:
		m.ResetSnapshots()
		return nil
	case profile.EdgeCategories:
		m.ResetCategories()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// SnapshotMutation represents an operation that mutates the Snapshot nodes in the graph.
type SnapshotMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	create_time              *time.Time
	update_time              *time.Time
	note                     *string
	clearedFields            map[string]struct{}
	profile                  *int
	clearedprofile           bool
	snapshot_accounts        map[int]struct{}
	removedsnapshot_accounts map[int]struct{}
	clearedsnapshot_accounts bool
	snapshot_fx_rates        map[int]struct{}
	removedsnapshot_fx_rates map[int]struct{}
	clearedsnapshot_fx_rates bool
	done                     bool
	oldValue                 func(context.Context) (*Snapshot, error)
	predicates               []predicate.Snapshot
}

var _ ent.Mutation = (*SnapshotMutation)(nil)

// snapshotOption allows management of the mutation configuration using functional options.
type snapshotOption func(*SnapshotMutation)

// newSnapshotMutation creates new mutation for the Snapshot entity.
func newSnapshotMutation(c config, op Op, opts ...snapshotOption) *SnapshotMutation {
	m := &SnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSnapshotID sets the ID field of the mutation.
func withSnapshotID(id int) snapshotOption {
	return func(m *SnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *Snapshot
		)
		m.oldValue = func(ctx context.Context) (*Snapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Snapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSnapshot sets the old Snapshot of the mutation.
func withSnapshot(node *Snapshot) snapshotOption {
	return func(m *SnapshotMutation) {
		m.oldValue = func(context.Context) (*Snapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SnapshotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SnapshotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Snapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SnapshotMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SnapshotMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SnapshotMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SnapshotMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SnapshotMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SnapshotMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNote sets the "note" field.
func (m *SnapshotMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *SnapshotMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *SnapshotMutation) ClearNote() {
	m.note = nil
	m.clearedFields[snapshot.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *SnapshotMutation) NoteCleared() bool {
	_, ok := m.clearedFields[snapshot.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *SnapshotMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, snapshot.FieldNote)
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *SnapshotMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *SnapshotMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *SnapshotMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *SnapshotMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *SnapshotMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *SnapshotMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddSnapshotAccountIDs adds the "snapshot_accounts" edge to the SnapshotAccount entity by ids.
func (m *SnapshotMutation) AddSnapshotAccountIDs(ids ...int) {
	if m.snapshot_accounts == nil {
		m.snapshot_accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.snapshot_accounts[ids[i]] = struct{}{}
	}
}

// ClearSnapshotAccounts clears the "snapshot_accounts" edge to the SnapshotAccount entity.
func (m *SnapshotMutation) ClearSnapshotAccounts() {
	m.clearedsnapshot_accounts = true
}

// SnapshotAccountsCleared reports if the "snapshot_accounts" edge to the SnapshotAccount entity was cleared.
func (m *SnapshotMutation) SnapshotAccountsCleared() bool {
	return m.clearedsnapshot_accounts
}

// RemoveSnapshotAccountIDs removes the "snapshot_accounts" edge to the SnapshotAccount entity by IDs.
func (m *SnapshotMutation) RemoveSnapshotAccountIDs(ids ...int) {
	if m.removedsnapshot_accounts == nil {
		m.removedsnapshot_accounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.snapshot_accounts, ids[i])
		m.removedsnapshot_accounts[ids[i]] = struct{}{}
	}
}

// RemovedSnapshotAccounts returns the removed IDs of the "snapshot_accounts" edge to the SnapshotAccount entity.
func (m *SnapshotMutation) RemovedSnapshotAccountsIDs() (ids []int) {
	for id := range m.removedsnapshot_accounts {
		ids = append(ids, id)
	}
	return
}

// SnapshotAccountsIDs returns the "snapshot_accounts" edge IDs in the mutation.
func (m *SnapshotMutation) SnapshotAccountsIDs() (ids []int) {
	for id := range m.snapshot_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetSnapshotAccounts resets all changes to the "snapshot_accounts" edge.
func (m *SnapshotMutation) ResetSnapshotAccounts() {
	m.snapshot_accounts = nil
	m.clearedsnapshot_accounts = false
	m.removedsnapshot_accounts = nil
}

// AddSnapshotFxRateIDs adds the "snapshot_fx_rates" edge to the SnapshotFXRate entity by ids.
func (m *SnapshotMutation) AddSnapshotFxRateIDs(ids ...int) {
	if m.snapshot_fx_rates == nil {
		m.snapshot_fx_rates = make(map[int]struct{})
	}
	for i := range ids {
		m.snapshot_fx_rates[ids[i]] = struct{}{}
	}
}

// ClearSnapshotFxRates clears the "snapshot_fx_rates" edge to the SnapshotFXRate entity.
func (m *SnapshotMutation) ClearSnapshotFxRates() {
	m.clearedsnapshot_fx_rates = true
}

// SnapshotFxRatesCleared reports if the "snapshot_fx_rates" edge to the SnapshotFXRate entity was cleared.
func (m *SnapshotMutation) SnapshotFxRatesCleared() bool {
	return m.clearedsnapshot_fx_rates
}

// RemoveSnapshotFxRateIDs removes the "snapshot_fx_rates" edge to the SnapshotFXRate entity by IDs.
func (m *SnapshotMutation) RemoveSnapshotFxRateIDs(ids ...int) {
	if m.removedsnapshot_fx_rates == nil {
		m.removedsnapshot_fx_rates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.snapshot_fx_rates, ids[i])
		m.removedsnapshot_fx_rates[ids[i]] = struct{}{}
	}
}

// RemovedSnapshotFxRates returns the removed IDs of the "snapshot_fx_rates" edge to the SnapshotFXRate entity.
func (m *SnapshotMutation) RemovedSnapshotFxRatesIDs() (ids []int) {
	for id := range m.removedsnapshot_fx_rates {
		ids = append(ids, id)
	}
	return
}

// SnapshotFxRatesIDs returns the "snapshot_fx_rates" edge IDs in the mutation.
func (m *SnapshotMutation) SnapshotFxRatesIDs() (ids []int) {
	for id := range m.snapshot_fx_rates {
		ids = append(ids, id)
	}
	return
}

// ResetSnapshotFxRates resets all changes to the "snapshot_fx_rates" edge.
func (m *SnapshotMutation) ResetSnapshotFxRates() {
	m.snapshot_fx_rates = nil
	m.clearedsnapshot_fx_rates = false
	m.removedsnapshot_fx_rates = nil
}

// Where appends a list predicates to the SnapshotMutation builder.
func (m *SnapshotMutation) Where(ps ...predicate.Snapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Snapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Snapshot).
func (m *SnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SnapshotMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, snapshot.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, snapshot.FieldUpdateTime)
	}
	if m.note != nil {
		fields = append(fields, snapshot.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case snapshot.FieldCreateTime:
		return m.CreateTime()
	case snapshot.FieldUpdateTime:
		return m.UpdateTime()
	case snapshot.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case snapshot.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case snapshot.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case snapshot.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown Snapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case snapshot.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case snapshot.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case snapshot.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown Snapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SnapshotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SnapshotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Snapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(snapshot.FieldNote) {
		fields = append(fields, snapshot.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SnapshotMutation) ClearField(name string) error {
	switch name {
	case snapshot.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Snapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SnapshotMutation) ResetField(name string) error {
	switch name {
	case snapshot.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case snapshot.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case snapshot.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown Snapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.profile != nil {
		edges = append(edges, snapshot.EdgeProfile)
	}
	if m.snapshot_accounts != nil {
		edges = append(edges, snapshot.EdgeSnapshotAccounts)
	}
	if m.snapshot_fx_rates != nil {
		edges = append(edges, snapshot.EdgeSnapshotFxRates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case snapshot.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case snapshot.EdgeSnapshotAccounts:
		ids := make([]ent.Value, 0, len(m.snapshot_accounts))
		for id := range m.snapshot_accounts {
			ids = append(ids, id)
		}
		return ids
	case snapshot.EdgeSnapshotFxRates:
		ids := make([]ent.Value, 0, len(m.snapshot_fx_rates))
		for id := range m.snapshot_fx_rates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsnapshot_accounts != nil {
		edges = append(edges, snapshot.EdgeSnapshotAccounts)
	}
	if m.removedsnapshot_fx_rates != nil {
		edges = append(edges, snapshot.EdgeSnapshotFxRates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SnapshotMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case snapshot.EdgeSnapshotAccounts:
		ids := make([]ent.Value, 0, len(m.removedsnapshot_accounts))
		for id := range m.removedsnapshot_accounts {
			ids = append(ids, id)
		}
		return ids
	case snapshot.EdgeSnapshotFxRates:
		ids := make([]ent.Value, 0, len(m.removedsnapshot_fx_rates))
		for id := range m.removedsnapshot_fx_rates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprofile {
		edges = append(edges, snapshot.EdgeProfile)
	}
	if m.clearedsnapshot_accounts {
		edges = append(edges, snapshot.EdgeSnapshotAccounts)
	}
	if m.clearedsnapshot_fx_rates {
		edges = append(edges, snapshot.EdgeSnapshotFxRates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case snapshot.EdgeProfile:
		return m.clearedprofile
	case snapshot.EdgeSnapshotAccounts:
		return m.clearedsnapshot_accounts
	case snapshot.EdgeSnapshotFxRates:
		return m.clearedsnapshot_fx_rates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SnapshotMutation) ClearEdge(name string) error {
	switch name {
	case snapshot.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown Snapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SnapshotMutation) ResetEdge(name string) error {
	switch name {
	case snapshot.EdgeProfile:
		m.ResetProfile()
		return nil
	case snapshot.EdgeSnapshotAccounts:
		m.ResetSnapshotAccounts()
		return nil
	case snapshot.EdgeSnapshotFxRates:
		m.ResetSnapshotFxRates()
		return nil
	}
	return fmt.Errorf("unknown Snapshot edge %s", name)
}

// SnapshotAccountMutation represents an operation that mutates the SnapshotAccount nodes in the graph.
type SnapshotAccountMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	amount          *decimal.Decimal
	addamount       *decimal.Decimal
	value           *decimal.Decimal
	addvalue        *decimal.Decimal
	balance         *decimal.Decimal
	addbalance      *decimal.Decimal
	clearedFields   map[string]struct{}
	account         *int
	clearedaccount  bool
	snapshot        *int
	clearedsnapshot bool
	done            bool
	oldValue        func(context.Context) (*SnapshotAccount, error)
	predicates      []predicate.SnapshotAccount
}

var _ ent.Mutation = (*SnapshotAccountMutation)(nil)

// snapshotaccountOption allows management of the mutation configuration using functional options.
type snapshotaccountOption func(*SnapshotAccountMutation)

// newSnapshotAccountMutation creates new mutation for the SnapshotAccount entity.
func newSnapshotAccountMutation(c config, op Op, opts ...snapshotaccountOption) *SnapshotAccountMutation {
	m := &SnapshotAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeSnapshotAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSnapshotAccountID sets the ID field of the mutation.
func withSnapshotAccountID(id int) snapshotaccountOption {
	return func(m *SnapshotAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *SnapshotAccount
		)
		m.oldValue = func(ctx context.Context) (*SnapshotAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SnapshotAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSnapshotAccount sets the old SnapshotAccount of the mutation.
func withSnapshotAccount(node *SnapshotAccount) snapshotaccountOption {
	return func(m *SnapshotAccountMutation) {
		m.oldValue = func(context.Context) (*SnapshotAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SnapshotAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SnapshotAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SnapshotAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SnapshotAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SnapshotAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SnapshotAccountMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SnapshotAccountMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SnapshotAccount entity.
// If the SnapshotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotAccountMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SnapshotAccountMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SnapshotAccountMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SnapshotAccountMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SnapshotAccount entity.
// If the SnapshotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotAccountMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SnapshotAccountMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAmount sets the "amount" field.
func (m *SnapshotAccountMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *SnapshotAccountMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the SnapshotAccount entity.
// If the SnapshotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotAccountMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *SnapshotAccountMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *SnapshotAccountMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *SnapshotAccountMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetValue sets the "value" field.
func (m *SnapshotAccountMutation) SetValue(d decimal.Decimal) {
	m.value = &d
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *SnapshotAccountMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the SnapshotAccount entity.
// If the SnapshotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotAccountMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds d to the "value" field.
func (m *SnapshotAccountMutation) AddValue(d decimal.Decimal) {
	if m.addvalue != nil {
		*m.addvalue = m.addvalue.Add(d)
	} else {
		m.addvalue = &d
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *SnapshotAccountMutation) AddedValue() (r decimal.Decimal, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *SnapshotAccountMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetBalance sets the "balance" field.
func (m *SnapshotAccountMutation) SetBalance(d decimal.Decimal) {
	m.balance = &d
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *SnapshotAccountMutation) Balance() (r decimal.Decimal, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the SnapshotAccount entity.
// If the SnapshotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotAccountMutation) OldBalance(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds d to the "balance" field.
func (m *SnapshotAccountMutation) AddBalance(d decimal.Decimal) {
	if m.addbalance != nil {
		*m.addbalance = m.addbalance.Add(d)
	} else {
		m.addbalance = &d
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *SnapshotAccountMutation) AddedBalance() (r decimal.Decimal, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *SnapshotAccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *SnapshotAccountMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *SnapshotAccountMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *SnapshotAccountMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *SnapshotAccountMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *SnapshotAccountMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *SnapshotAccountMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetSnapshotID sets the "snapshot" edge to the Snapshot entity by id.
func (m *SnapshotAccountMutation) SetSnapshotID(id int) {
	m.snapshot = &id
}

// ClearSnapshot clears the "snapshot" edge to the Snapshot entity.
func (m *SnapshotAccountMutation) ClearSnapshot() {
	m.clearedsnapshot = true
}

// SnapshotCleared reports if the "snapshot" edge to the Snapshot entity was cleared.
func (m *SnapshotAccountMutation) SnapshotCleared() bool {
	return m.clearedsnapshot
}

// SnapshotID returns the "snapshot" edge ID in the mutation.
func (m *SnapshotAccountMutation) SnapshotID() (id int, exists bool) {
	if m.snapshot != nil {
		return *m.snapshot, true
	}
	return
}

// SnapshotIDs returns the "snapshot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SnapshotID instead. It exists only for internal usage by the builders.
func (m *SnapshotAccountMutation) SnapshotIDs() (ids []int) {
	if id := m.snapshot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSnapshot resets all changes to the "snapshot" edge.
func (m *SnapshotAccountMutation) ResetSnapshot() {
	m.snapshot = nil
	m.clearedsnapshot = false
}

// Where appends a list predicates to the SnapshotAccountMutation builder.
func (m *SnapshotAccountMutation) Where(ps ...predicate.SnapshotAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SnapshotAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SnapshotAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SnapshotAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SnapshotAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SnapshotAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SnapshotAccount).
func (m *SnapshotAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SnapshotAccountMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, snapshotaccount.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, snapshotaccount.FieldUpdateTime)
	}
	if m.amount != nil {
		fields = append(fields, snapshotaccount.FieldAmount)
	}
	if m.value != nil {
		fields = append(fields, snapshotaccount.FieldValue)
	}
	if m.balance != nil {
		fields = append(fields, snapshotaccount.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SnapshotAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case snapshotaccount.FieldCreateTime:
		return m.CreateTime()
	case snapshotaccount.FieldUpdateTime:
		return m.UpdateTime()
	case snapshotaccount.FieldAmount:
		return m.Amount()
	case snapshotaccount.FieldValue:
		return m.Value()
	case snapshotaccount.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SnapshotAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case snapshotaccount.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case snapshotaccount.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case snapshotaccount.FieldAmount:
		return m.OldAmount(ctx)
	case snapshotaccount.FieldValue:
		return m.OldValue(ctx)
	case snapshotaccount.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown SnapshotAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case snapshotaccount.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case snapshotaccount.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case snapshotaccount.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case snapshotaccount.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case snapshotaccount.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown SnapshotAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SnapshotAccountMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, snapshotaccount.FieldAmount)
	}
	if m.addvalue != nil {
		fields = append(fields, snapshotaccount.FieldValue)
	}
	if m.addbalance != nil {
		fields = append(fields, snapshotaccount.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SnapshotAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case snapshotaccount.FieldAmount:
		return m.AddedAmount()
	case snapshotaccount.FieldValue:
		return m.AddedValue()
	case snapshotaccount.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case snapshotaccount.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case snapshotaccount.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case snapshotaccount.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown SnapshotAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SnapshotAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SnapshotAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SnapshotAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SnapshotAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SnapshotAccountMutation) ResetField(name string) error {
	switch name {
	case snapshotaccount.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case snapshotaccount.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case snapshotaccount.FieldAmount:
		m.ResetAmount()
		return nil
	case snapshotaccount.FieldValue:
		m.ResetValue()
		return nil
	case snapshotaccount.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown SnapshotAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SnapshotAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, snapshotaccount.EdgeAccount)
	}
	if m.snapshot != nil {
		edges = append(edges, snapshotaccount.EdgeSnapshot)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SnapshotAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case snapshotaccount.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case snapshotaccount.EdgeSnapshot:
		if id := m.snapshot; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SnapshotAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SnapshotAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SnapshotAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, snapshotaccount.EdgeAccount)
	}
	if m.clearedsnapshot {
		edges = append(edges, snapshotaccount.EdgeSnapshot)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SnapshotAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case snapshotaccount.EdgeAccount:
		return m.clearedaccount
	case snapshotaccount.EdgeSnapshot:
		return m.clearedsnapshot
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SnapshotAccountMutation) ClearEdge(name string) error {
	switch name {
	case snapshotaccount.EdgeAccount:
		m.ClearAccount()
		return nil
	case snapshotaccount.EdgeSnapshot:
		m.ClearSnapshot()
		return nil
	}
	return fmt.Errorf("unknown SnapshotAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SnapshotAccountMutation) ResetEdge(name string) error {
	switch name {
	case snapshotaccount.EdgeAccount:
		m.ResetAccount()
		return nil
	case snapshotaccount.EdgeSnapshot:
		m.ResetSnapshot()
		return nil
	}
	return fmt.Errorf("unknown SnapshotAccount edge %s", name)
}

// SnapshotFXRateMutation represents an operation that mutates the SnapshotFXRate nodes in the graph.
type SnapshotFXRateMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	from_currency   *string
	to_currency     *string
	fx_rate         *decimal.Decimal
	addfx_rate      *decimal.Decimal
	clearedFields   map[string]struct{}
	snapshot        *int
	clearedsnapshot bool
	done            bool
	oldValue        func(context.Context) (*SnapshotFXRate, error)
	predicates      []predicate.SnapshotFXRate
}

var _ ent.Mutation = (*SnapshotFXRateMutation)(nil)

// snapshotfxrateOption allows management of the mutation configuration using functional options.
type snapshotfxrateOption func(*SnapshotFXRateMutation)

// newSnapshotFXRateMutation creates new mutation for the SnapshotFXRate entity.
func newSnapshotFXRateMutation(c config, op Op, opts ...snapshotfxrateOption) *SnapshotFXRateMutation {
	m := &SnapshotFXRateMutation{
		config:        c,
		op:            op,
		typ:           TypeSnapshotFXRate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSnapshotFXRateID sets the ID field of the mutation.
func withSnapshotFXRateID(id int) snapshotfxrateOption {
	return func(m *SnapshotFXRateMutation) {
		var (
			err   error
			once  sync.Once
			value *SnapshotFXRate
		)
		m.oldValue = func(ctx context.Context) (*SnapshotFXRate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SnapshotFXRate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSnapshotFXRate sets the old SnapshotFXRate of the mutation.
func withSnapshotFXRate(node *SnapshotFXRate) snapshotfxrateOption {
	return func(m *SnapshotFXRateMutation) {
		m.oldValue = func(context.Context) (*SnapshotFXRate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SnapshotFXRateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SnapshotFXRateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SnapshotFXRateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SnapshotFXRateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SnapshotFXRate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SnapshotFXRateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SnapshotFXRateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SnapshotFXRate entity.
// If the SnapshotFXRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotFXRateMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SnapshotFXRateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SnapshotFXRateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SnapshotFXRateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SnapshotFXRate entity.
// If the SnapshotFXRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotFXRateMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SnapshotFXRateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetFromCurrency sets the "from_currency" field.
func (m *SnapshotFXRateMutation) SetFromCurrency(s string) {
	m.from_currency = &s
}

// FromCurrency returns the value of the "from_currency" field in the mutation.
func (m *SnapshotFXRateMutation) FromCurrency() (r string, exists bool) {
	v := m.from_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldFromCurrency returns the old "from_currency" field's value of the SnapshotFXRate entity.
// If the SnapshotFXRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotFXRateMutation) OldFromCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromCurrency: %w", err)
	}
	return oldValue.FromCurrency, nil
}

// ResetFromCurrency resets all changes to the "from_currency" field.
func (m *SnapshotFXRateMutation) ResetFromCurrency() {
	m.from_currency = nil
}

// SetToCurrency sets the "to_currency" field.
func (m *SnapshotFXRateMutation) SetToCurrency(s string) {
	m.to_currency = &s
}

// ToCurrency returns the value of the "to_currency" field in the mutation.
func (m *SnapshotFXRateMutation) ToCurrency() (r string, exists bool) {
	v := m.to_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldToCurrency returns the old "to_currency" field's value of the SnapshotFXRate entity.
// If the SnapshotFXRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotFXRateMutation) OldToCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToCurrency: %w", err)
	}
	return oldValue.ToCurrency, nil
}

// ResetToCurrency resets all changes to the "to_currency" field.
func (m *SnapshotFXRateMutation) ResetToCurrency() {
	m.to_currency = nil
}

// SetFxRate sets the "fx_rate" field.
func (m *SnapshotFXRateMutation) SetFxRate(d decimal.Decimal) {
	m.fx_rate = &d
	m.addfx_rate = nil
}

// FxRate returns the value of the "fx_rate" field in the mutation.
func (m *SnapshotFXRateMutation) FxRate() (r decimal.Decimal, exists bool) {
	v := m.fx_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFxRate returns the old "fx_rate" field's value of the SnapshotFXRate entity.
// If the SnapshotFXRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotFXRateMutation) OldFxRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFxRate: %w", err)
	}
	return oldValue.FxRate, nil
}

// AddFxRate adds d to the "fx_rate" field.
func (m *SnapshotFXRateMutation) AddFxRate(d decimal.Decimal) {
	if m.addfx_rate != nil {
		*m.addfx_rate = m.addfx_rate.Add(d)
	} else {
		m.addfx_rate = &d
	}
}

// AddedFxRate returns the value that was added to the "fx_rate" field in this mutation.
func (m *SnapshotFXRateMutation) AddedFxRate() (r decimal.Decimal, exists bool) {
	v := m.addfx_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetFxRate resets all changes to the "fx_rate" field.
func (m *SnapshotFXRateMutation) ResetFxRate() {
	m.fx_rate = nil
	m.addfx_rate = nil
}

// SetSnapshotID sets the "snapshot" edge to the Snapshot entity by id.
func (m *SnapshotFXRateMutation) SetSnapshotID(id int) {
	m.snapshot = &id
}

// ClearSnapshot clears the "snapshot" edge to the Snapshot entity.
func (m *SnapshotFXRateMutation) ClearSnapshot() {
	m.clearedsnapshot = true
}

// SnapshotCleared reports if the "snapshot" edge to the Snapshot entity was cleared.
func (m *SnapshotFXRateMutation) SnapshotCleared() bool {
	return m.clearedsnapshot
}

// SnapshotID returns the "snapshot" edge ID in the mutation.
func (m *SnapshotFXRateMutation) SnapshotID() (id int, exists bool) {
	if m.snapshot != nil {
		return *m.snapshot, true
	}
	return
}

// SnapshotIDs returns the "snapshot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SnapshotID instead. It exists only for internal usage by the builders.
func (m *SnapshotFXRateMutation) SnapshotIDs() (ids []int) {
	if id := m.snapshot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSnapshot resets all changes to the "snapshot" edge.
func (m *SnapshotFXRateMutation) ResetSnapshot() {
	m.snapshot = nil
	m.clearedsnapshot = false
}

// Where appends a list predicates to the SnapshotFXRateMutation builder.
func (m *SnapshotFXRateMutation) Where(ps ...predicate.SnapshotFXRate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SnapshotFXRateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SnapshotFXRateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SnapshotFXRate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SnapshotFXRateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SnapshotFXRateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SnapshotFXRate).
func (m *SnapshotFXRateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SnapshotFXRateMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, snapshotfxrate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, snapshotfxrate.FieldUpdateTime)
	}
	if m.from_currency != nil {
		fields = append(fields, snapshotfxrate.FieldFromCurrency)
	}
	if m.to_currency != nil {
		fields = append(fields, snapshotfxrate.FieldToCurrency)
	}
	if m.fx_rate != nil {
		fields = append(fields, snapshotfxrate.FieldFxRate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SnapshotFXRateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case snapshotfxrate.FieldCreateTime:
		return m.CreateTime()
	case snapshotfxrate.FieldUpdateTime:
		return m.UpdateTime()
	case snapshotfxrate.FieldFromCurrency:
		return m.FromCurrency()
	case snapshotfxrate.FieldToCurrency:
		return m.ToCurrency()
	case snapshotfxrate.FieldFxRate:
		return m.FxRate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SnapshotFXRateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case snapshotfxrate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case snapshotfxrate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case snapshotfxrate.FieldFromCurrency:
		return m.OldFromCurrency(ctx)
	case snapshotfxrate.FieldToCurrency:
		return m.OldToCurrency(ctx)
	case snapshotfxrate.FieldFxRate:
		return m.OldFxRate(ctx)
	}
	return nil, fmt.Errorf("unknown SnapshotFXRate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotFXRateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case snapshotfxrate.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case snapshotfxrate.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case snapshotfxrate.FieldFromCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromCurrency(v)
		return nil
	case snapshotfxrate.FieldToCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToCurrency(v)
		return nil
	case snapshotfxrate.FieldFxRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFxRate(v)
		return nil
	}
	return fmt.Errorf("unknown SnapshotFXRate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SnapshotFXRateMutation) AddedFields() []string {
	var fields []string
	if m.addfx_rate != nil {
		fields = append(fields, snapshotfxrate.FieldFxRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SnapshotFXRateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case snapshotfxrate.FieldFxRate:
		return m.AddedFxRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotFXRateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case snapshotfxrate.FieldFxRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFxRate(v)
		return nil
	}
	return fmt.Errorf("unknown SnapshotFXRate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SnapshotFXRateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SnapshotFXRateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SnapshotFXRateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SnapshotFXRate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SnapshotFXRateMutation) ResetField(name string) error {
	switch name {
	case snapshotfxrate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case snapshotfxrate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case snapshotfxrate.FieldFromCurrency:
		m.ResetFromCurrency()
		return nil
	case snapshotfxrate.FieldToCurrency:
		m.ResetToCurrency()
		return nil
	case snapshotfxrate.FieldFxRate:
		m.ResetFxRate()
		return nil
	}
	return fmt.Errorf("unknown SnapshotFXRate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SnapshotFXRateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.snapshot != nil {
		edges = append(edges, snapshotfxrate.EdgeSnapshot)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SnapshotFXRateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case snapshotfxrate.EdgeSnapshot:
		if id := m.snapshot; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SnapshotFXRateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SnapshotFXRateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SnapshotFXRateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsnapshot {
		edges = append(edges, snapshotfxrate.EdgeSnapshot)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SnapshotFXRateMutation) EdgeCleared(name string) bool {
	switch name {
	case snapshotfxrate.EdgeSnapshot:
		return m.clearedsnapshot
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SnapshotFXRateMutation) ClearEdge(name string) error {
	switch name {
	case snapshotfxrate.EdgeSnapshot:
		m.ClearSnapshot()
		return nil
	}
	return fmt.Errorf("unknown SnapshotFXRate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SnapshotFXRateMutation) ResetEdge(name string) error {
	switch name {
	case snapshotfxrate.EdgeSnapshot:
		m.ResetSnapshot()
		return nil
	}
	return fmt.Errorf("unknown SnapshotFXRate edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	update_time                *time.Time
	note                       *string
	clearedFields              map[string]struct{}
	profile                    *int
	clearedprofile             bool
	category                   *int
	clearedcategory            bool
	transaction_entries        map[int]struct{}
	removedtransaction_entries map[int]struct{}
	clearedtransaction_entries bool
	done                       bool
	oldValue                   func(context.Context) (*Transaction, error)
	predicates                 []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransactionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransactionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransactionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransactionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransactionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransactionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNote sets the "note" field.
func (m *TransactionMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *TransactionMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *TransactionMutation) ClearNote() {
	m.note = nil
	m.clearedFields[transaction.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *TransactionMutation) NoteCleared() bool {
	_, ok := m.clearedFields[transaction.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *TransactionMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, transaction.FieldNote)
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *TransactionMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *TransactionMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *TransactionMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *TransactionMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *TransactionMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// SetCategoryID sets the "category" edge to the Category entity by id.
func (m *TransactionMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *TransactionMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *TransactionMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *TransactionMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *TransactionMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddTransactionEntryIDs adds the "transaction_entries" edge to the TransactionEntry entity by ids.
func (m *TransactionMutation) AddTransactionEntryIDs(ids ...int) {
	if m.transaction_entries == nil {
		m.transaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_entries[ids[i]] = struct{}{}
	}
}

// ClearTransactionEntries clears the "transaction_entries" edge to the TransactionEntry entity.
func (m *TransactionMutation) ClearTransactionEntries() {
	m.clearedtransaction_entries = true
}

// TransactionEntriesCleared reports if the "transaction_entries" edge to the TransactionEntry entity was cleared.
func (m *TransactionMutation) TransactionEntriesCleared() bool {
	return m.clearedtransaction_entries
}

// RemoveTransactionEntryIDs removes the "transaction_entries" edge to the TransactionEntry entity by IDs.
func (m *TransactionMutation) RemoveTransactionEntryIDs(ids ...int) {
	if m.removedtransaction_entries == nil {
		m.removedtransaction_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_entries, ids[i])
		m.removedtransaction_entries[ids[i]] = struct{}{}
	}
}

// RemovedTransactionEntries returns the removed IDs of the "transaction_entries" edge to the TransactionEntry entity.
func (m *TransactionMutation) RemovedTransactionEntriesIDs() (ids []int) {
	for id := range m.removedtransaction_entries {
		ids = append(ids, id)
	}
	return
}

// TransactionEntriesIDs returns the "transaction_entries" edge IDs in the mutation.
func (m *TransactionMutation) TransactionEntriesIDs() (ids []int) {
	for id := range m.transaction_entries {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionEntries resets all changes to the "transaction_entries" edge.
func (m *TransactionMutation) ResetTransactionEntries() {
	m.transaction_entries = nil
	m.clearedtransaction_entries = false
	m.removedtransaction_entries = nil
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, transaction.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transaction.FieldUpdateTime)
	}
	if m.note != nil {
		fields = append(fields, transaction.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldCreateTime:
		return m.CreateTime()
	case transaction.FieldUpdateTime:
		return m.UpdateTime()
	case transaction.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transaction.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transaction.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transaction.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transaction.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldNote) {
		fields = append(fields, transaction.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transaction.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transaction.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.profile != nil {
		edges = append(edges, transaction.EdgeProfile)
	}
	if m.category != nil {
		edges = append(edges, transaction.EdgeCategory)
	}
	if m.transaction_entries != nil {
		edges = append(edges, transaction.EdgeTransactionEntries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.transaction_entries))
		for id := range m.transaction_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtransaction_entries != nil {
		edges = append(edges, transaction.EdgeTransactionEntries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeTransactionEntries:
		ids := make([]ent.Value, 0, len(m.removedtransaction_entries))
		for id := range m.removedtransaction_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprofile {
		edges = append(edges, transaction.EdgeProfile)
	}
	if m.clearedcategory {
		edges = append(edges, transaction.EdgeCategory)
	}
	if m.clearedtransaction_entries {
		edges = append(edges, transaction.EdgeTransactionEntries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeProfile:
		return m.clearedprofile
	case transaction.EdgeCategory:
		return m.clearedcategory
	case transaction.EdgeTransactionEntries:
		return m.clearedtransaction_entries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeProfile:
		m.ClearProfile()
		return nil
	case transaction.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeProfile:
		m.ResetProfile()
		return nil
	case transaction.EdgeCategory:
		m.ResetCategory()
		return nil
	case transaction.EdgeTransactionEntries:
		m.ResetTransactionEntries()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// TransactionEntryMutation represents an operation that mutates the TransactionEntry nodes in the graph.
type TransactionEntryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	note               *string
	amount             *decimal.Decimal
	addamount          *decimal.Decimal
	value              *decimal.Decimal
	addvalue           *decimal.Decimal
	balance            *decimal.Decimal
	addbalance         *decimal.Decimal
	clearedFields      map[string]struct{}
	account            *int
	clearedaccount     bool
	transaction        *int
	clearedtransaction bool
	done               bool
	oldValue           func(context.Context) (*TransactionEntry, error)
	predicates         []predicate.TransactionEntry
}

var _ ent.Mutation = (*TransactionEntryMutation)(nil)

// transactionentryOption allows management of the mutation configuration using functional options.
type transactionentryOption func(*TransactionEntryMutation)

// newTransactionEntryMutation creates new mutation for the TransactionEntry entity.
func newTransactionEntryMutation(c config, op Op, opts ...transactionentryOption) *TransactionEntryMutation {
	m := &TransactionEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionEntryID sets the ID field of the mutation.
func withTransactionEntryID(id int) transactionentryOption {
	return func(m *TransactionEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionEntry
		)
		m.oldValue = func(ctx context.Context) (*TransactionEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionEntry sets the old TransactionEntry of the mutation.
func withTransactionEntry(node *TransactionEntry) transactionentryOption {
	return func(m *TransactionEntryMutation) {
		m.oldValue = func(context.Context) (*TransactionEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransactionEntryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransactionEntryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransactionEntryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransactionEntryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransactionEntryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransactionEntryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNote sets the "note" field.
func (m *TransactionEntryMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *TransactionEntryMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *TransactionEntryMutation) ClearNote() {
	m.note = nil
	m.clearedFields[transactionentry.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *TransactionEntryMutation) NoteCleared() bool {
	_, ok := m.clearedFields[transactionentry.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *TransactionEntryMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, transactionentry.FieldNote)
}

// SetAmount sets the "amount" field.
func (m *TransactionEntryMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionEntryMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *TransactionEntryMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionEntryMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionEntryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetValue sets the "value" field.
func (m *TransactionEntryMutation) SetValue(d decimal.Decimal) {
	m.value = &d
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *TransactionEntryMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds d to the "value" field.
func (m *TransactionEntryMutation) AddValue(d decimal.Decimal) {
	if m.addvalue != nil {
		*m.addvalue = m.addvalue.Add(d)
	} else {
		m.addvalue = &d
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *TransactionEntryMutation) AddedValue() (r decimal.Decimal, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *TransactionEntryMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetBalance sets the "balance" field.
func (m *TransactionEntryMutation) SetBalance(d decimal.Decimal) {
	m.balance = &d
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *TransactionEntryMutation) Balance() (r decimal.Decimal, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the TransactionEntry entity.
// If the TransactionEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionEntryMutation) OldBalance(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds d to the "balance" field.
func (m *TransactionEntryMutation) AddBalance(d decimal.Decimal) {
	if m.addbalance != nil {
		*m.addbalance = m.addbalance.Add(d)
	} else {
		m.addbalance = &d
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *TransactionEntryMutation) AddedBalance() (r decimal.Decimal, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *TransactionEntryMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *TransactionEntryMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *TransactionEntryMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *TransactionEntryMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *TransactionEntryMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *TransactionEntryMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *TransactionEntryMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetTransactionID sets the "transaction" edge to the Transaction entity by id.
func (m *TransactionEntryMutation) SetTransactionID(id int) {
	m.transaction = &id
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *TransactionEntryMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *TransactionEntryMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the "transaction" edge ID in the mutation.
func (m *TransactionEntryMutation) TransactionID() (id int, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *TransactionEntryMutation) TransactionIDs() (ids []int) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *TransactionEntryMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// Where appends a list predicates to the TransactionEntryMutation builder.
func (m *TransactionEntryMutation) Where(ps ...predicate.TransactionEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransactionEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransactionEntry).
func (m *TransactionEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionEntryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, transactionentry.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transactionentry.FieldUpdateTime)
	}
	if m.note != nil {
		fields = append(fields, transactionentry.FieldNote)
	}
	if m.amount != nil {
		fields = append(fields, transactionentry.FieldAmount)
	}
	if m.value != nil {
		fields = append(fields, transactionentry.FieldValue)
	}
	if m.balance != nil {
		fields = append(fields, transactionentry.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionentry.FieldCreateTime:
		return m.CreateTime()
	case transactionentry.FieldUpdateTime:
		return m.UpdateTime()
	case transactionentry.FieldNote:
		return m.Note()
	case transactionentry.FieldAmount:
		return m.Amount()
	case transactionentry.FieldValue:
		return m.Value()
	case transactionentry.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionentry.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transactionentry.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transactionentry.FieldNote:
		return m.OldNote(ctx)
	case transactionentry.FieldAmount:
		return m.OldAmount(ctx)
	case transactionentry.FieldValue:
		return m.OldValue(ctx)
	case transactionentry.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionentry.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transactionentry.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transactionentry.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case transactionentry.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transactionentry.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case transactionentry.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionEntryMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transactionentry.FieldAmount)
	}
	if m.addvalue != nil {
		fields = append(fields, transactionentry.FieldValue)
	}
	if m.addbalance != nil {
		fields = append(fields, transactionentry.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transactionentry.FieldAmount:
		return m.AddedAmount()
	case transactionentry.FieldValue:
		return m.AddedValue()
	case transactionentry.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transactionentry.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case transactionentry.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case transactionentry.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactionentry.FieldNote) {
		fields = append(fields, transactionentry.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionEntryMutation) ClearField(name string) error {
	switch name {
	case transactionentry.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionEntryMutation) ResetField(name string) error {
	switch name {
	case transactionentry.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transactionentry.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transactionentry.FieldNote:
		m.ResetNote()
		return nil
	case transactionentry.FieldAmount:
		m.ResetAmount()
		return nil
	case transactionentry.FieldValue:
		m.ResetValue()
		return nil
	case transactionentry.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, transactionentry.EdgeAccount)
	}
	if m.transaction != nil {
		edges = append(edges, transactionentry.EdgeTransaction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactionentry.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case transactionentry.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, transactionentry.EdgeAccount)
	}
	if m.clearedtransaction {
		edges = append(edges, transactionentry.EdgeTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case transactionentry.EdgeAccount:
		return m.clearedaccount
	case transactionentry.EdgeTransaction:
		return m.clearedtransaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionEntryMutation) ClearEdge(name string) error {
	switch name {
	case transactionentry.EdgeAccount:
		m.ClearAccount()
		return nil
	case transactionentry.EdgeTransaction:
		m.ClearTransaction()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionEntryMutation) ResetEdge(name string) error {
	switch name {
	case transactionentry.EdgeAccount:
		m.ResetAccount()
		return nil
	case transactionentry.EdgeTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown TransactionEntry edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	email            *string
	clearedFields    map[string]struct{}
	user_keys        map[int]struct{}
	removeduser_keys map[int]struct{}
	cleareduser_keys bool
	profiles         map[int]struct{}
	removedprofiles  map[int]struct{}
	clearedprofiles  bool
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddUserKeyIDs adds the "user_keys" edge to the UserKey entity by ids.
func (m *UserMutation) AddUserKeyIDs(ids ...int) {
	if m.user_keys == nil {
		m.user_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.user_keys[ids[i]] = struct{}{}
	}
}

// ClearUserKeys clears the "user_keys" edge to the UserKey entity.
func (m *UserMutation) ClearUserKeys() {
	m.cleareduser_keys = true
}

// UserKeysCleared reports if the "user_keys" edge to the UserKey entity was cleared.
func (m *UserMutation) UserKeysCleared() bool {
	return m.cleareduser_keys
}

// RemoveUserKeyIDs removes the "user_keys" edge to the UserKey entity by IDs.
func (m *UserMutation) RemoveUserKeyIDs(ids ...int) {
	if m.removeduser_keys == nil {
		m.removeduser_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_keys, ids[i])
		m.removeduser_keys[ids[i]] = struct{}{}
	}
}

// RemovedUserKeys returns the removed IDs of the "user_keys" edge to the UserKey entity.
func (m *UserMutation) RemovedUserKeysIDs() (ids []int) {
	for id := range m.removeduser_keys {
		ids = append(ids, id)
	}
	return
}

// UserKeysIDs returns the "user_keys" edge IDs in the mutation.
func (m *UserMutation) UserKeysIDs() (ids []int) {
	for id := range m.user_keys {
		ids = append(ids, id)
	}
	return
}

// ResetUserKeys resets all changes to the "user_keys" edge.
func (m *UserMutation) ResetUserKeys() {
	m.user_keys = nil
	m.cleareduser_keys = false
	m.removeduser_keys = nil
}

// AddProfileIDs adds the "profiles" edge to the Profile entity by ids.
func (m *UserMutation) AddProfileIDs(ids ...int) {
	if m.profiles == nil {
		m.profiles = make(map[int]struct{})
	}
	for i := range ids {
		m.profiles[ids[i]] = struct{}{}
	}
}

// ClearProfiles clears the "profiles" edge to the Profile entity.
func (m *UserMutation) ClearProfiles() {
	m.clearedprofiles = true
}

// ProfilesCleared reports if the "profiles" edge to the Profile entity was cleared.
func (m *UserMutation) ProfilesCleared() bool {
	return m.clearedprofiles
}

// RemoveProfileIDs removes the "profiles" edge to the Profile entity by IDs.
func (m *UserMutation) RemoveProfileIDs(ids ...int) {
	if m.removedprofiles == nil {
		m.removedprofiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.profiles, ids[i])
		m.removedprofiles[ids[i]] = struct{}{}
	}
}

// RemovedProfiles returns the removed IDs of the "profiles" edge to the Profile entity.
func (m *UserMutation) RemovedProfilesIDs() (ids []int) {
	for id := range m.removedprofiles {
		ids = append(ids, id)
	}
	return
}

// ProfilesIDs returns the "profiles" edge IDs in the mutation.
func (m *UserMutation) ProfilesIDs() (ids []int) {
	for id := range m.profiles {
		ids = append(ids, id)
	}
	return
}

// ResetProfiles resets all changes to the "profiles" edge.
func (m *UserMutation) ResetProfiles() {
	m.profiles = nil
	m.clearedprofiles = false
	m.removedprofiles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_keys != nil {
		edges = append(edges, user.EdgeUserKeys)
	}
	if m.profiles != nil {
		edges = append(edges, user.EdgeProfiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserKeys:
		ids := make([]ent.Value, 0, len(m.user_keys))
		for id := range m.user_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.profiles))
		for id := range m.profiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_keys != nil {
		edges = append(edges, user.EdgeUserKeys)
	}
	if m.removedprofiles != nil {
		edges = append(edges, user.EdgeProfiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserKeys:
		ids := make([]ent.Value, 0, len(m.removeduser_keys))
		for id := range m.removeduser_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.removedprofiles))
		for id := range m.removedprofiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_keys {
		edges = append(edges, user.EdgeUserKeys)
	}
	if m.clearedprofiles {
		edges = append(edges, user.EdgeProfiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserKeys:
		return m.cleareduser_keys
	case user.EdgeProfiles:
		return m.clearedprofiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserKeys:
		m.ResetUserKeys()
		return nil
	case user.EdgeProfiles:
		m.ResetProfiles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserKeyMutation represents an operation that mutates the UserKey nodes in the graph.
type UserKeyMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	key             *string
	hashed_password *string
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*UserKey, error)
	predicates      []predicate.UserKey
}

var _ ent.Mutation = (*UserKeyMutation)(nil)

// userkeyOption allows management of the mutation configuration using functional options.
type userkeyOption func(*UserKeyMutation)

// newUserKeyMutation creates new mutation for the UserKey entity.
func newUserKeyMutation(c config, op Op, opts ...userkeyOption) *UserKeyMutation {
	m := &UserKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeUserKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserKeyID sets the ID field of the mutation.
func withUserKeyID(id int) userkeyOption {
	return func(m *UserKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *UserKey
		)
		m.oldValue = func(ctx context.Context) (*UserKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserKey sets the old UserKey of the mutation.
func withUserKey(node *UserKey) userkeyOption {
	return func(m *UserKeyMutation) {
		m.oldValue = func(context.Context) (*UserKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserKeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserKeyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserKeyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserKeyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserKeyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserKeyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserKeyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetKey sets the "key" field.
func (m *UserKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UserKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UserKeyMutation) ResetKey() {
	m.key = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *UserKeyMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *UserKeyMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the UserKey entity.
// If the UserKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserKeyMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ClearHashedPassword clears the value of the "hashed_password" field.
func (m *UserKeyMutation) ClearHashedPassword() {
	m.hashed_password = nil
	m.clearedFields[userkey.FieldHashedPassword] = struct{}{}
}

// HashedPasswordCleared returns if the "hashed_password" field was cleared in this mutation.
func (m *UserKeyMutation) HashedPasswordCleared() bool {
	_, ok := m.clearedFields[userkey.FieldHashedPassword]
	return ok
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *UserKeyMutation) ResetHashedPassword() {
	m.hashed_password = nil
	delete(m.clearedFields, userkey.FieldHashedPassword)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserKeyMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserKeyMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserKeyMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserKeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserKeyMutation builder.
func (m *UserKeyMutation) Where(ps ...predicate.UserKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserKey).
func (m *UserKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserKeyMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, userkey.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userkey.FieldUpdateTime)
	}
	if m.key != nil {
		fields = append(fields, userkey.FieldKey)
	}
	if m.hashed_password != nil {
		fields = append(fields, userkey.FieldHashedPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userkey.FieldCreateTime:
		return m.CreateTime()
	case userkey.FieldUpdateTime:
		return m.UpdateTime()
	case userkey.FieldKey:
		return m.Key()
	case userkey.FieldHashedPassword:
		return m.HashedPassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userkey.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userkey.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userkey.FieldKey:
		return m.OldKey(ctx)
	case userkey.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	}
	return nil, fmt.Errorf("unknown UserKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userkey.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userkey.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userkey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case userkey.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	}
	return fmt.Errorf("unknown UserKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userkey.FieldHashedPassword) {
		fields = append(fields, userkey.FieldHashedPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserKeyMutation) ClearField(name string) error {
	switch name {
	case userkey.FieldHashedPassword:
		m.ClearHashedPassword()
		return nil
	}
	return fmt.Errorf("unknown UserKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserKeyMutation) ResetField(name string) error {
	switch name {
	case userkey.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userkey.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userkey.FieldKey:
		m.ResetKey()
		return nil
	case userkey.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	}
	return fmt.Errorf("unknown UserKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userkey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userkey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userkey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case userkey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserKeyMutation) ClearEdge(name string) error {
	switch name {
	case userkey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserKeyMutation) ResetEdge(name string) error {
	switch name {
	case userkey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserKey edge %s", name)
}

// UserProfileMutation represents an operation that mutates the UserProfile nodes in the graph.
type UserProfileMutation struct {
	config
	op             Op
	typ            string
	permission     *userprofile.Permission
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	profile        *int
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*UserProfile, error)
	predicates     []predicate.UserProfile
}

var _ ent.Mutation = (*UserProfileMutation)(nil)

// userprofileOption allows management of the mutation configuration using functional options.
type userprofileOption func(*UserProfileMutation)

// newUserProfileMutation creates new mutation for the UserProfile entity.
func newUserProfileMutation(c config, op Op, opts ...userprofileOption) *UserProfileMutation {
	m := &UserProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetPermission sets the "permission" field.
func (m *UserProfileMutation) SetPermission(u userprofile.Permission) {
	m.permission = &u
}

// Permission returns the value of the "permission" field in the mutation.
func (m *UserProfileMutation) Permission() (r userprofile.Permission, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// ResetPermission resets all changes to the "permission" field.
func (m *UserProfileMutation) ResetPermission() {
	m.permission = nil
}

// SetUserID sets the "user_id" field.
func (m *UserProfileMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProfileMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProfileMutation) ResetUserID() {
	m.user = nil
}

// SetProfileID sets the "profile_id" field.
func (m *UserProfileMutation) SetProfileID(i int) {
	m.profile = &i
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *UserProfileMutation) ProfileID() (r int, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *UserProfileMutation) ResetProfileID() {
	m.profile = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProfileMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userprofile.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *UserProfileMutation) ClearProfile() {
	m.clearedprofile = true
	m.clearedFields[userprofile.FieldProfileID] = struct{}{}
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *UserProfileMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserProfileMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the UserProfileMutation builder.
func (m *UserProfileMutation) Where(ps ...predicate.UserProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProfile).
func (m *UserProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProfileMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.permission != nil {
		fields = append(fields, userprofile.FieldPermission)
	}
	if m.user != nil {
		fields = append(fields, userprofile.FieldUserID)
	}
	if m.profile != nil {
		fields = append(fields, userprofile.FieldProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldPermission:
		return m.Permission()
	case userprofile.FieldUserID:
		return m.UserID()
	case userprofile.FieldProfileID:
		return m.ProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserProfile does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldPermission:
		v, ok := value.(userprofile.Permission)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case userprofile.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userprofile.FieldProfileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProfileMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProfileMutation) ResetField(name string) error {
	switch name {
	case userprofile.FieldPermission:
		m.ResetPermission()
		return nil
	case userprofile.FieldUserID:
		m.ResetUserID()
		return nil
	case userprofile.FieldProfileID:
		m.ResetProfileID()
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userprofile.EdgeUser)
	}
	if m.profile != nil {
		edges = append(edges, userprofile.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userprofile.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userprofile.EdgeUser)
	}
	if m.clearedprofile {
		edges = append(edges, userprofile.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userprofile.EdgeUser:
		return m.cleareduser
	case userprofile.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProfileMutation) ClearEdge(name string) error {
	switch name {
	case userprofile.EdgeUser:
		m.ClearUser()
		return nil
	case userprofile.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown UserProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProfileMutation) ResetEdge(name string) error {
	switch name {
	case userprofile.EdgeUser:
		m.ResetUser()
		return nil
	case userprofile.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown UserProfile edge %s", name)
}
