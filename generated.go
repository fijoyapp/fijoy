// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package beavermoney

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"beavermoney.app/ent"
	"beavermoney.app/ent/account"
	"beavermoney.app/ent/investment"
	"beavermoney.app/ent/transactioncategory"
	"beavermoney.app/ent/userhousehold"
	"beavermoney.app/ent/userkey"
	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Account() AccountResolver
	FinancialReport() FinancialReportResolver
	Investment() InvestmentResolver
	InvestmentLot() InvestmentLotResolver
	Mutation() MutationResolver
	Query() QueryResolver
	TransactionEntry() TransactionEntryResolver
	AccountWhereInput() AccountWhereInputResolver
	CreateAccountInput() CreateAccountInputResolver
	CreateInvestmentInput() CreateInvestmentInputResolver
	CreateInvestmentLotInput() CreateInvestmentLotInputResolver
	CreateTransactionEntryInput() CreateTransactionEntryInputResolver
	InvestmentLotWhereInput() InvestmentLotWhereInputResolver
	InvestmentWhereInput() InvestmentWhereInputResolver
	TransactionEntryWhereInput() TransactionEntryWhereInputResolver
	UpdateInvestmentInput() UpdateInvestmentInputResolver
	UpdateInvestmentLotInput() UpdateInvestmentLotInputResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Account struct {
		Balance                    func(childComplexity int) int
		BalanceInHouseholdCurrency func(childComplexity int) int
		CreateTime                 func(childComplexity int) int
		Currency                   func(childComplexity int) int
		CurrencyID                 func(childComplexity int) int
		FxRate                     func(childComplexity int) int
		Household                  func(childComplexity int) int
		HouseholdID                func(childComplexity int) int
		ID                         func(childComplexity int) int
		Icon                       func(childComplexity int) int
		Investments                func(childComplexity int) int
		Name                       func(childComplexity int) int
		TransactionEntries         func(childComplexity int) int
		Type                       func(childComplexity int) int
		UpdateTime                 func(childComplexity int) int
		User                       func(childComplexity int) int
		UserID                     func(childComplexity int) int
		Value                      func(childComplexity int) int
		ValueInHouseholdCurrency   func(childComplexity int) int
	}

	AccountConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AccountEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	CategoryAggregate struct {
		Category         func(childComplexity int) int
		Total            func(childComplexity int) int
		TransactionCount func(childComplexity int) int
	}

	CategoryTypeAggregate struct {
		Categories       func(childComplexity int) int
		CategoryType     func(childComplexity int) int
		Total            func(childComplexity int) int
		TransactionCount func(childComplexity int) int
	}

	CryptoQuoteResult struct {
		Currency     func(childComplexity int) int
		CurrentPrice func(childComplexity int) int
		Exchange     func(childComplexity int) int
		Name         func(childComplexity int) int
		Symbol       func(childComplexity int) int
	}

	Currency struct {
		Accounts           func(childComplexity int) int
		Code               func(childComplexity int) int
		Households         func(childComplexity int) int
		ID                 func(childComplexity int) int
		Investments        func(childComplexity int) int
		TransactionEntries func(childComplexity int) int
	}

	FinancialReport struct {
		EndDate                func(childComplexity int) int
		ExpensesByCategoryType func(childComplexity int) int
		IncomeByCategoryType   func(childComplexity int) int
		StartDate              func(childComplexity int) int
		TotalExpenses          func(childComplexity int) int
		TotalIncome            func(childComplexity int) int
		TransactionCount       func(childComplexity int) int
	}

	Household struct {
		Accounts              func(childComplexity int) int
		CreateTime            func(childComplexity int) int
		Currency              func(childComplexity int) int
		CurrencyID            func(childComplexity int) int
		ID                    func(childComplexity int) int
		InvestmentLots        func(childComplexity int) int
		Investments           func(childComplexity int) int
		Locale                func(childComplexity int) int
		Name                  func(childComplexity int) int
		TransactionCategories func(childComplexity int) int
		TransactionEntries    func(childComplexity int) int
		Transactions          func(childComplexity int) int
		UpdateTime            func(childComplexity int) int
		UserHouseholds        func(childComplexity int) int
		Users                 func(childComplexity int) int
	}

	Investment struct {
		Account                  func(childComplexity int) int
		AccountID                func(childComplexity int) int
		Amount                   func(childComplexity int) int
		CreateTime               func(childComplexity int) int
		Currency                 func(childComplexity int) int
		CurrencyID               func(childComplexity int) int
		Household                func(childComplexity int) int
		HouseholdID              func(childComplexity int) int
		ID                       func(childComplexity int) int
		InvestmentLots           func(childComplexity int) int
		Name                     func(childComplexity int) int
		Quote                    func(childComplexity int) int
		Symbol                   func(childComplexity int) int
		Type                     func(childComplexity int) int
		UpdateTime               func(childComplexity int) int
		Value                    func(childComplexity int) int
		ValueInHouseholdCurrency func(childComplexity int) int
	}

	InvestmentConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	InvestmentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	InvestmentLot struct {
		Amount        func(childComplexity int) int
		CreateTime    func(childComplexity int) int
		Household     func(childComplexity int) int
		HouseholdID   func(childComplexity int) int
		ID            func(childComplexity int) int
		Investment    func(childComplexity int) int
		InvestmentID  func(childComplexity int) int
		Price         func(childComplexity int) int
		Transaction   func(childComplexity int) int
		TransactionID func(childComplexity int) int
		UpdateTime    func(childComplexity int) int
	}

	InvestmentLotConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	InvestmentLotEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		BuyInvestment             func(childComplexity int, input BuyInvestmentInputCustom) int
		CreateAccount             func(childComplexity int, input ent.CreateAccountInput) int
		CreateExpense             func(childComplexity int, input CreateExpenseInputCustom) int
		CreateIncome              func(childComplexity int, input CreateIncomeInputCustom) int
		CreateInvestment          func(childComplexity int, input CreateInvestmentInputCustom) int
		CreateTransactionCategory func(childComplexity int, input ent.CreateTransactionCategoryInput) int
		CreateTransfer            func(childComplexity int, input CreateTransferInputCustom) int
		MoveInvestment            func(childComplexity int, input MoveInvestmentInputCustom) int
		SellInvestment            func(childComplexity int, input SellInvestmentInputCustom) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Accounts              func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *ent.AccountWhereInput) int
		CryptoQuote           func(childComplexity int, symbol string) int
		Currencies            func(childComplexity int) int
		FinancialReport       func(childComplexity int, period TimePeriodInput) int
		FxRate                func(childComplexity int, from string, to string, datetime time.Time) int
		Households            func(childComplexity int) int
		InvestmentLots        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *ent.InvestmentLotWhereInput) int
		Investments           func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *ent.InvestmentWhereInput) int
		Node                  func(childComplexity int, id int) int
		Nodes                 func(childComplexity int, ids []int) int
		StockQuote            func(childComplexity int, symbol string) int
		TransactionCategories func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *ent.TransactionCategoryWhereInput) int
		TransactionEntries    func(childComplexity int) int
		Transactions          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		UserHouseholds        func(childComplexity int) int
	}

	StockQuoteResult struct {
		Currency     func(childComplexity int) int
		CurrentPrice func(childComplexity int) int
		Exchange     func(childComplexity int) int
		Name         func(childComplexity int) int
		Symbol       func(childComplexity int) int
	}

	Transaction struct {
		Category           func(childComplexity int) int
		CategoryID         func(childComplexity int) int
		CreateTime         func(childComplexity int) int
		Datetime           func(childComplexity int) int
		Description        func(childComplexity int) int
		Household          func(childComplexity int) int
		HouseholdID        func(childComplexity int) int
		ID                 func(childComplexity int) int
		InvestmentLots     func(childComplexity int) int
		TransactionEntries func(childComplexity int) int
		UpdateTime         func(childComplexity int) int
		User               func(childComplexity int) int
		UserID             func(childComplexity int) int
	}

	TransactionCategory struct {
		CreateTime   func(childComplexity int) int
		Household    func(childComplexity int) int
		HouseholdID  func(childComplexity int) int
		ID           func(childComplexity int) int
		Icon         func(childComplexity int) int
		IsImmutable  func(childComplexity int) int
		Name         func(childComplexity int) int
		Transactions func(childComplexity int) int
		Type         func(childComplexity int) int
		UpdateTime   func(childComplexity int) int
	}

	TransactionCategoryConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TransactionCategoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TransactionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TransactionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TransactionEntry struct {
		Account       func(childComplexity int) int
		AccountID     func(childComplexity int) int
		Amount        func(childComplexity int) int
		CreateTime    func(childComplexity int) int
		Currency      func(childComplexity int) int
		CurrencyID    func(childComplexity int) int
		Household     func(childComplexity int) int
		HouseholdID   func(childComplexity int) int
		ID            func(childComplexity int) int
		Transaction   func(childComplexity int) int
		TransactionID func(childComplexity int) int
		UpdateTime    func(childComplexity int) int
	}

	User struct {
		Accounts       func(childComplexity int) int
		CreateTime     func(childComplexity int) int
		Email          func(childComplexity int) int
		Households     func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
		Transactions   func(childComplexity int) int
		UpdateTime     func(childComplexity int) int
		UserHouseholds func(childComplexity int) int
		UserKeys       func(childComplexity int) int
	}

	UserHousehold struct {
		CreateTime  func(childComplexity int) int
		Household   func(childComplexity int) int
		HouseholdID func(childComplexity int) int
		ID          func(childComplexity int) int
		Role        func(childComplexity int) int
		UpdateTime  func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	UserKey struct {
		CreateTime func(childComplexity int) int
		ID         func(childComplexity int) int
		Key        func(childComplexity int) int
		Provider   func(childComplexity int) int
		UpdateTime func(childComplexity int) int
		User       func(childComplexity int) int
		UserID     func(childComplexity int) int
	}
}

type AccountResolver interface {
	Balance(ctx context.Context, obj *ent.Account) (string, error)

	Value(ctx context.Context, obj *ent.Account) (string, error)
	FxRate(ctx context.Context, obj *ent.Account) (string, error)

	BalanceInHouseholdCurrency(ctx context.Context, obj *ent.Account) (string, error)
	ValueInHouseholdCurrency(ctx context.Context, obj *ent.Account) (string, error)
}
type FinancialReportResolver interface {
	TotalIncome(ctx context.Context, obj *FinancialReport) (string, error)
	TotalExpenses(ctx context.Context, obj *FinancialReport) (string, error)
	IncomeByCategoryType(ctx context.Context, obj *FinancialReport) ([]*CategoryTypeAggregate, error)
	ExpensesByCategoryType(ctx context.Context, obj *FinancialReport) ([]*CategoryTypeAggregate, error)
	TransactionCount(ctx context.Context, obj *FinancialReport) (int, error)
}
type InvestmentResolver interface {
	Amount(ctx context.Context, obj *ent.Investment) (string, error)
	Quote(ctx context.Context, obj *ent.Investment) (string, error)
	Value(ctx context.Context, obj *ent.Investment) (string, error)

	ValueInHouseholdCurrency(ctx context.Context, obj *ent.Investment) (string, error)
}
type InvestmentLotResolver interface {
	Amount(ctx context.Context, obj *ent.InvestmentLot) (string, error)
	Price(ctx context.Context, obj *ent.InvestmentLot) (string, error)
}
type MutationResolver interface {
	CreateAccount(ctx context.Context, input ent.CreateAccountInput) (*ent.AccountEdge, error)
	CreateInvestment(ctx context.Context, input CreateInvestmentInputCustom) (*ent.InvestmentEdge, error)
	CreateTransactionCategory(ctx context.Context, input ent.CreateTransactionCategoryInput) (*ent.TransactionCategoryEdge, error)
	CreateExpense(ctx context.Context, input CreateExpenseInputCustom) (*ent.TransactionEdge, error)
	CreateIncome(ctx context.Context, input CreateIncomeInputCustom) (*ent.TransactionEdge, error)
	CreateTransfer(ctx context.Context, input CreateTransferInputCustom) (*ent.TransactionEdge, error)
	BuyInvestment(ctx context.Context, input BuyInvestmentInputCustom) (*ent.TransactionEdge, error)
	SellInvestment(ctx context.Context, input SellInvestmentInputCustom) (*ent.TransactionEdge, error)
	MoveInvestment(ctx context.Context, input MoveInvestmentInputCustom) (*ent.TransactionEdge, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id int) (ent.Noder, error)
	Nodes(ctx context.Context, ids []int) ([]ent.Noder, error)
	Accounts(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *ent.AccountWhereInput) (*ent.AccountConnection, error)
	Currencies(ctx context.Context) ([]*ent.Currency, error)
	Households(ctx context.Context) ([]*ent.Household, error)
	Investments(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *ent.InvestmentWhereInput) (*ent.InvestmentConnection, error)
	InvestmentLots(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *ent.InvestmentLotWhereInput) (*ent.InvestmentLotConnection, error)
	Transactions(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) (*ent.TransactionConnection, error)
	TransactionCategories(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *ent.TransactionCategoryWhereInput) (*ent.TransactionCategoryConnection, error)
	TransactionEntries(ctx context.Context) ([]*ent.TransactionEntry, error)
	UserHouseholds(ctx context.Context) ([]*ent.UserHousehold, error)
	FxRate(ctx context.Context, from string, to string, datetime time.Time) (string, error)
	StockQuote(ctx context.Context, symbol string) (*StockQuoteResult, error)
	CryptoQuote(ctx context.Context, symbol string) (*CryptoQuoteResult, error)
	FinancialReport(ctx context.Context, period TimePeriodInput) (*FinancialReport, error)
}
type TransactionEntryResolver interface {
	Amount(ctx context.Context, obj *ent.TransactionEntry) (string, error)
}

type AccountWhereInputResolver interface {
	Balance(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	BalanceNeq(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	BalanceIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	BalanceNotIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	BalanceGt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	BalanceGte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	BalanceLt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	BalanceLte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error

	Value(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	ValueNeq(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	ValueIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	ValueNotIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	ValueGt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	ValueGte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	ValueLt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	ValueLte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRate(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRateNeq(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRateIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	FxRateNotIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	FxRateGt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRateGte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRateLt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRateLte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
}
type CreateAccountInputResolver interface {
	Balance(ctx context.Context, obj *ent.CreateAccountInput, data *string) error
}
type CreateInvestmentInputResolver interface {
	Amount(ctx context.Context, obj *ent.CreateInvestmentInput, data *string) error
}
type CreateInvestmentLotInputResolver interface {
	Amount(ctx context.Context, obj *ent.CreateInvestmentLotInput, data string) error
	Price(ctx context.Context, obj *ent.CreateInvestmentLotInput, data string) error
}
type CreateTransactionEntryInputResolver interface {
	Amount(ctx context.Context, obj *ent.CreateTransactionEntryInput, data string) error
}
type InvestmentLotWhereInputResolver interface {
	Amount(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	AmountNeq(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	AmountIn(ctx context.Context, obj *ent.InvestmentLotWhereInput, data []string) error
	AmountNotIn(ctx context.Context, obj *ent.InvestmentLotWhereInput, data []string) error
	AmountGt(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	AmountGte(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	AmountLt(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	AmountLte(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	Price(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	PriceNeq(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	PriceIn(ctx context.Context, obj *ent.InvestmentLotWhereInput, data []string) error
	PriceNotIn(ctx context.Context, obj *ent.InvestmentLotWhereInput, data []string) error
	PriceGt(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	PriceGte(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	PriceLt(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
	PriceLte(ctx context.Context, obj *ent.InvestmentLotWhereInput, data *string) error
}
type InvestmentWhereInputResolver interface {
	Amount(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	AmountNeq(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	AmountIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	AmountNotIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	AmountGt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	AmountGte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	AmountLt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	AmountLte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	Quote(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	QuoteNeq(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	QuoteIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	QuoteNotIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	QuoteGt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	QuoteGte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	QuoteLt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	QuoteLte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	Value(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	ValueNeq(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	ValueIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	ValueNotIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	ValueGt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	ValueGte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	ValueLt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	ValueLte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
}
type TransactionEntryWhereInputResolver interface {
	Amount(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
	AmountNeq(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
	AmountIn(ctx context.Context, obj *ent.TransactionEntryWhereInput, data []string) error
	AmountNotIn(ctx context.Context, obj *ent.TransactionEntryWhereInput, data []string) error
	AmountGt(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
	AmountGte(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
	AmountLt(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
	AmountLte(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
}
type UpdateInvestmentInputResolver interface {
	Amount(ctx context.Context, obj *ent.UpdateInvestmentInput, data *string) error
}
type UpdateInvestmentLotInputResolver interface {
	Amount(ctx context.Context, obj *ent.UpdateInvestmentLotInput, data *string) error
	Price(ctx context.Context, obj *ent.UpdateInvestmentLotInput, data *string) error
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Account.balance":
		if e.complexity.Account.Balance == nil {
			break
		}

		return e.complexity.Account.Balance(childComplexity), true
	case "Account.balanceInHouseholdCurrency":
		if e.complexity.Account.BalanceInHouseholdCurrency == nil {
			break
		}

		return e.complexity.Account.BalanceInHouseholdCurrency(childComplexity), true
	case "Account.createTime":
		if e.complexity.Account.CreateTime == nil {
			break
		}

		return e.complexity.Account.CreateTime(childComplexity), true
	case "Account.currency":
		if e.complexity.Account.Currency == nil {
			break
		}

		return e.complexity.Account.Currency(childComplexity), true
	case "Account.currencyID":
		if e.complexity.Account.CurrencyID == nil {
			break
		}

		return e.complexity.Account.CurrencyID(childComplexity), true
	case "Account.fxRate":
		if e.complexity.Account.FxRate == nil {
			break
		}

		return e.complexity.Account.FxRate(childComplexity), true
	case "Account.household":
		if e.complexity.Account.Household == nil {
			break
		}

		return e.complexity.Account.Household(childComplexity), true
	case "Account.householdID":
		if e.complexity.Account.HouseholdID == nil {
			break
		}

		return e.complexity.Account.HouseholdID(childComplexity), true
	case "Account.id":
		if e.complexity.Account.ID == nil {
			break
		}

		return e.complexity.Account.ID(childComplexity), true
	case "Account.icon":
		if e.complexity.Account.Icon == nil {
			break
		}

		return e.complexity.Account.Icon(childComplexity), true
	case "Account.investments":
		if e.complexity.Account.Investments == nil {
			break
		}

		return e.complexity.Account.Investments(childComplexity), true
	case "Account.name":
		if e.complexity.Account.Name == nil {
			break
		}

		return e.complexity.Account.Name(childComplexity), true
	case "Account.transactionEntries":
		if e.complexity.Account.TransactionEntries == nil {
			break
		}

		return e.complexity.Account.TransactionEntries(childComplexity), true
	case "Account.type":
		if e.complexity.Account.Type == nil {
			break
		}

		return e.complexity.Account.Type(childComplexity), true
	case "Account.updateTime":
		if e.complexity.Account.UpdateTime == nil {
			break
		}

		return e.complexity.Account.UpdateTime(childComplexity), true
	case "Account.user":
		if e.complexity.Account.User == nil {
			break
		}

		return e.complexity.Account.User(childComplexity), true
	case "Account.userID":
		if e.complexity.Account.UserID == nil {
			break
		}

		return e.complexity.Account.UserID(childComplexity), true
	case "Account.value":
		if e.complexity.Account.Value == nil {
			break
		}

		return e.complexity.Account.Value(childComplexity), true
	case "Account.valueInHouseholdCurrency":
		if e.complexity.Account.ValueInHouseholdCurrency == nil {
			break
		}

		return e.complexity.Account.ValueInHouseholdCurrency(childComplexity), true

	case "AccountConnection.edges":
		if e.complexity.AccountConnection.Edges == nil {
			break
		}

		return e.complexity.AccountConnection.Edges(childComplexity), true
	case "AccountConnection.pageInfo":
		if e.complexity.AccountConnection.PageInfo == nil {
			break
		}

		return e.complexity.AccountConnection.PageInfo(childComplexity), true
	case "AccountConnection.totalCount":
		if e.complexity.AccountConnection.TotalCount == nil {
			break
		}

		return e.complexity.AccountConnection.TotalCount(childComplexity), true

	case "AccountEdge.cursor":
		if e.complexity.AccountEdge.Cursor == nil {
			break
		}

		return e.complexity.AccountEdge.Cursor(childComplexity), true
	case "AccountEdge.node":
		if e.complexity.AccountEdge.Node == nil {
			break
		}

		return e.complexity.AccountEdge.Node(childComplexity), true

	case "CategoryAggregate.category":
		if e.complexity.CategoryAggregate.Category == nil {
			break
		}

		return e.complexity.CategoryAggregate.Category(childComplexity), true
	case "CategoryAggregate.total":
		if e.complexity.CategoryAggregate.Total == nil {
			break
		}

		return e.complexity.CategoryAggregate.Total(childComplexity), true
	case "CategoryAggregate.transactionCount":
		if e.complexity.CategoryAggregate.TransactionCount == nil {
			break
		}

		return e.complexity.CategoryAggregate.TransactionCount(childComplexity), true

	case "CategoryTypeAggregate.categories":
		if e.complexity.CategoryTypeAggregate.Categories == nil {
			break
		}

		return e.complexity.CategoryTypeAggregate.Categories(childComplexity), true
	case "CategoryTypeAggregate.categoryType":
		if e.complexity.CategoryTypeAggregate.CategoryType == nil {
			break
		}

		return e.complexity.CategoryTypeAggregate.CategoryType(childComplexity), true
	case "CategoryTypeAggregate.total":
		if e.complexity.CategoryTypeAggregate.Total == nil {
			break
		}

		return e.complexity.CategoryTypeAggregate.Total(childComplexity), true
	case "CategoryTypeAggregate.transactionCount":
		if e.complexity.CategoryTypeAggregate.TransactionCount == nil {
			break
		}

		return e.complexity.CategoryTypeAggregate.TransactionCount(childComplexity), true

	case "CryptoQuoteResult.currency":
		if e.complexity.CryptoQuoteResult.Currency == nil {
			break
		}

		return e.complexity.CryptoQuoteResult.Currency(childComplexity), true
	case "CryptoQuoteResult.currentPrice":
		if e.complexity.CryptoQuoteResult.CurrentPrice == nil {
			break
		}

		return e.complexity.CryptoQuoteResult.CurrentPrice(childComplexity), true
	case "CryptoQuoteResult.exchange":
		if e.complexity.CryptoQuoteResult.Exchange == nil {
			break
		}

		return e.complexity.CryptoQuoteResult.Exchange(childComplexity), true
	case "CryptoQuoteResult.name":
		if e.complexity.CryptoQuoteResult.Name == nil {
			break
		}

		return e.complexity.CryptoQuoteResult.Name(childComplexity), true
	case "CryptoQuoteResult.symbol":
		if e.complexity.CryptoQuoteResult.Symbol == nil {
			break
		}

		return e.complexity.CryptoQuoteResult.Symbol(childComplexity), true

	case "Currency.accounts":
		if e.complexity.Currency.Accounts == nil {
			break
		}

		return e.complexity.Currency.Accounts(childComplexity), true
	case "Currency.code":
		if e.complexity.Currency.Code == nil {
			break
		}

		return e.complexity.Currency.Code(childComplexity), true
	case "Currency.households":
		if e.complexity.Currency.Households == nil {
			break
		}

		return e.complexity.Currency.Households(childComplexity), true
	case "Currency.id":
		if e.complexity.Currency.ID == nil {
			break
		}

		return e.complexity.Currency.ID(childComplexity), true
	case "Currency.investments":
		if e.complexity.Currency.Investments == nil {
			break
		}

		return e.complexity.Currency.Investments(childComplexity), true
	case "Currency.transactionEntries":
		if e.complexity.Currency.TransactionEntries == nil {
			break
		}

		return e.complexity.Currency.TransactionEntries(childComplexity), true

	case "FinancialReport.endDate":
		if e.complexity.FinancialReport.EndDate == nil {
			break
		}

		return e.complexity.FinancialReport.EndDate(childComplexity), true
	case "FinancialReport.expensesByCategoryType":
		if e.complexity.FinancialReport.ExpensesByCategoryType == nil {
			break
		}

		return e.complexity.FinancialReport.ExpensesByCategoryType(childComplexity), true
	case "FinancialReport.incomeByCategoryType":
		if e.complexity.FinancialReport.IncomeByCategoryType == nil {
			break
		}

		return e.complexity.FinancialReport.IncomeByCategoryType(childComplexity), true
	case "FinancialReport.startDate":
		if e.complexity.FinancialReport.StartDate == nil {
			break
		}

		return e.complexity.FinancialReport.StartDate(childComplexity), true
	case "FinancialReport.totalExpenses":
		if e.complexity.FinancialReport.TotalExpenses == nil {
			break
		}

		return e.complexity.FinancialReport.TotalExpenses(childComplexity), true
	case "FinancialReport.totalIncome":
		if e.complexity.FinancialReport.TotalIncome == nil {
			break
		}

		return e.complexity.FinancialReport.TotalIncome(childComplexity), true
	case "FinancialReport.transactionCount":
		if e.complexity.FinancialReport.TransactionCount == nil {
			break
		}

		return e.complexity.FinancialReport.TransactionCount(childComplexity), true

	case "Household.accounts":
		if e.complexity.Household.Accounts == nil {
			break
		}

		return e.complexity.Household.Accounts(childComplexity), true
	case "Household.createTime":
		if e.complexity.Household.CreateTime == nil {
			break
		}

		return e.complexity.Household.CreateTime(childComplexity), true
	case "Household.currency":
		if e.complexity.Household.Currency == nil {
			break
		}

		return e.complexity.Household.Currency(childComplexity), true
	case "Household.currencyID":
		if e.complexity.Household.CurrencyID == nil {
			break
		}

		return e.complexity.Household.CurrencyID(childComplexity), true
	case "Household.id":
		if e.complexity.Household.ID == nil {
			break
		}

		return e.complexity.Household.ID(childComplexity), true
	case "Household.investmentLots":
		if e.complexity.Household.InvestmentLots == nil {
			break
		}

		return e.complexity.Household.InvestmentLots(childComplexity), true
	case "Household.investments":
		if e.complexity.Household.Investments == nil {
			break
		}

		return e.complexity.Household.Investments(childComplexity), true
	case "Household.locale":
		if e.complexity.Household.Locale == nil {
			break
		}

		return e.complexity.Household.Locale(childComplexity), true
	case "Household.name":
		if e.complexity.Household.Name == nil {
			break
		}

		return e.complexity.Household.Name(childComplexity), true
	case "Household.transactionCategories":
		if e.complexity.Household.TransactionCategories == nil {
			break
		}

		return e.complexity.Household.TransactionCategories(childComplexity), true
	case "Household.transactionEntries":
		if e.complexity.Household.TransactionEntries == nil {
			break
		}

		return e.complexity.Household.TransactionEntries(childComplexity), true
	case "Household.transactions":
		if e.complexity.Household.Transactions == nil {
			break
		}

		return e.complexity.Household.Transactions(childComplexity), true
	case "Household.updateTime":
		if e.complexity.Household.UpdateTime == nil {
			break
		}

		return e.complexity.Household.UpdateTime(childComplexity), true
	case "Household.userHouseholds":
		if e.complexity.Household.UserHouseholds == nil {
			break
		}

		return e.complexity.Household.UserHouseholds(childComplexity), true
	case "Household.users":
		if e.complexity.Household.Users == nil {
			break
		}

		return e.complexity.Household.Users(childComplexity), true

	case "Investment.account":
		if e.complexity.Investment.Account == nil {
			break
		}

		return e.complexity.Investment.Account(childComplexity), true
	case "Investment.accountID":
		if e.complexity.Investment.AccountID == nil {
			break
		}

		return e.complexity.Investment.AccountID(childComplexity), true
	case "Investment.amount":
		if e.complexity.Investment.Amount == nil {
			break
		}

		return e.complexity.Investment.Amount(childComplexity), true
	case "Investment.createTime":
		if e.complexity.Investment.CreateTime == nil {
			break
		}

		return e.complexity.Investment.CreateTime(childComplexity), true
	case "Investment.currency":
		if e.complexity.Investment.Currency == nil {
			break
		}

		return e.complexity.Investment.Currency(childComplexity), true
	case "Investment.currencyID":
		if e.complexity.Investment.CurrencyID == nil {
			break
		}

		return e.complexity.Investment.CurrencyID(childComplexity), true
	case "Investment.household":
		if e.complexity.Investment.Household == nil {
			break
		}

		return e.complexity.Investment.Household(childComplexity), true
	case "Investment.householdID":
		if e.complexity.Investment.HouseholdID == nil {
			break
		}

		return e.complexity.Investment.HouseholdID(childComplexity), true
	case "Investment.id":
		if e.complexity.Investment.ID == nil {
			break
		}

		return e.complexity.Investment.ID(childComplexity), true
	case "Investment.investmentLots":
		if e.complexity.Investment.InvestmentLots == nil {
			break
		}

		return e.complexity.Investment.InvestmentLots(childComplexity), true
	case "Investment.name":
		if e.complexity.Investment.Name == nil {
			break
		}

		return e.complexity.Investment.Name(childComplexity), true
	case "Investment.quote":
		if e.complexity.Investment.Quote == nil {
			break
		}

		return e.complexity.Investment.Quote(childComplexity), true
	case "Investment.symbol":
		if e.complexity.Investment.Symbol == nil {
			break
		}

		return e.complexity.Investment.Symbol(childComplexity), true
	case "Investment.type":
		if e.complexity.Investment.Type == nil {
			break
		}

		return e.complexity.Investment.Type(childComplexity), true
	case "Investment.updateTime":
		if e.complexity.Investment.UpdateTime == nil {
			break
		}

		return e.complexity.Investment.UpdateTime(childComplexity), true
	case "Investment.value":
		if e.complexity.Investment.Value == nil {
			break
		}

		return e.complexity.Investment.Value(childComplexity), true
	case "Investment.valueInHouseholdCurrency":
		if e.complexity.Investment.ValueInHouseholdCurrency == nil {
			break
		}

		return e.complexity.Investment.ValueInHouseholdCurrency(childComplexity), true

	case "InvestmentConnection.edges":
		if e.complexity.InvestmentConnection.Edges == nil {
			break
		}

		return e.complexity.InvestmentConnection.Edges(childComplexity), true
	case "InvestmentConnection.pageInfo":
		if e.complexity.InvestmentConnection.PageInfo == nil {
			break
		}

		return e.complexity.InvestmentConnection.PageInfo(childComplexity), true
	case "InvestmentConnection.totalCount":
		if e.complexity.InvestmentConnection.TotalCount == nil {
			break
		}

		return e.complexity.InvestmentConnection.TotalCount(childComplexity), true

	case "InvestmentEdge.cursor":
		if e.complexity.InvestmentEdge.Cursor == nil {
			break
		}

		return e.complexity.InvestmentEdge.Cursor(childComplexity), true
	case "InvestmentEdge.node":
		if e.complexity.InvestmentEdge.Node == nil {
			break
		}

		return e.complexity.InvestmentEdge.Node(childComplexity), true

	case "InvestmentLot.amount":
		if e.complexity.InvestmentLot.Amount == nil {
			break
		}

		return e.complexity.InvestmentLot.Amount(childComplexity), true
	case "InvestmentLot.createTime":
		if e.complexity.InvestmentLot.CreateTime == nil {
			break
		}

		return e.complexity.InvestmentLot.CreateTime(childComplexity), true
	case "InvestmentLot.household":
		if e.complexity.InvestmentLot.Household == nil {
			break
		}

		return e.complexity.InvestmentLot.Household(childComplexity), true
	case "InvestmentLot.householdID":
		if e.complexity.InvestmentLot.HouseholdID == nil {
			break
		}

		return e.complexity.InvestmentLot.HouseholdID(childComplexity), true
	case "InvestmentLot.id":
		if e.complexity.InvestmentLot.ID == nil {
			break
		}

		return e.complexity.InvestmentLot.ID(childComplexity), true
	case "InvestmentLot.investment":
		if e.complexity.InvestmentLot.Investment == nil {
			break
		}

		return e.complexity.InvestmentLot.Investment(childComplexity), true
	case "InvestmentLot.investmentID":
		if e.complexity.InvestmentLot.InvestmentID == nil {
			break
		}

		return e.complexity.InvestmentLot.InvestmentID(childComplexity), true
	case "InvestmentLot.price":
		if e.complexity.InvestmentLot.Price == nil {
			break
		}

		return e.complexity.InvestmentLot.Price(childComplexity), true
	case "InvestmentLot.transaction":
		if e.complexity.InvestmentLot.Transaction == nil {
			break
		}

		return e.complexity.InvestmentLot.Transaction(childComplexity), true
	case "InvestmentLot.transactionID":
		if e.complexity.InvestmentLot.TransactionID == nil {
			break
		}

		return e.complexity.InvestmentLot.TransactionID(childComplexity), true
	case "InvestmentLot.updateTime":
		if e.complexity.InvestmentLot.UpdateTime == nil {
			break
		}

		return e.complexity.InvestmentLot.UpdateTime(childComplexity), true

	case "InvestmentLotConnection.edges":
		if e.complexity.InvestmentLotConnection.Edges == nil {
			break
		}

		return e.complexity.InvestmentLotConnection.Edges(childComplexity), true
	case "InvestmentLotConnection.pageInfo":
		if e.complexity.InvestmentLotConnection.PageInfo == nil {
			break
		}

		return e.complexity.InvestmentLotConnection.PageInfo(childComplexity), true
	case "InvestmentLotConnection.totalCount":
		if e.complexity.InvestmentLotConnection.TotalCount == nil {
			break
		}

		return e.complexity.InvestmentLotConnection.TotalCount(childComplexity), true

	case "InvestmentLotEdge.cursor":
		if e.complexity.InvestmentLotEdge.Cursor == nil {
			break
		}

		return e.complexity.InvestmentLotEdge.Cursor(childComplexity), true
	case "InvestmentLotEdge.node":
		if e.complexity.InvestmentLotEdge.Node == nil {
			break
		}

		return e.complexity.InvestmentLotEdge.Node(childComplexity), true

	case "Mutation.buyInvestment":
		if e.complexity.Mutation.BuyInvestment == nil {
			break
		}

		args, err := ec.field_Mutation_buyInvestment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BuyInvestment(childComplexity, args["input"].(BuyInvestmentInputCustom)), true
	case "Mutation.createAccount":
		if e.complexity.Mutation.CreateAccount == nil {
			break
		}

		args, err := ec.field_Mutation_createAccount_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAccount(childComplexity, args["input"].(ent.CreateAccountInput)), true
	case "Mutation.createExpense":
		if e.complexity.Mutation.CreateExpense == nil {
			break
		}

		args, err := ec.field_Mutation_createExpense_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateExpense(childComplexity, args["input"].(CreateExpenseInputCustom)), true
	case "Mutation.createIncome":
		if e.complexity.Mutation.CreateIncome == nil {
			break
		}

		args, err := ec.field_Mutation_createIncome_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateIncome(childComplexity, args["input"].(CreateIncomeInputCustom)), true
	case "Mutation.createInvestment":
		if e.complexity.Mutation.CreateInvestment == nil {
			break
		}

		args, err := ec.field_Mutation_createInvestment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateInvestment(childComplexity, args["input"].(CreateInvestmentInputCustom)), true
	case "Mutation.createTransactionCategory":
		if e.complexity.Mutation.CreateTransactionCategory == nil {
			break
		}

		args, err := ec.field_Mutation_createTransactionCategory_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTransactionCategory(childComplexity, args["input"].(ent.CreateTransactionCategoryInput)), true
	case "Mutation.createTransfer":
		if e.complexity.Mutation.CreateTransfer == nil {
			break
		}

		args, err := ec.field_Mutation_createTransfer_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTransfer(childComplexity, args["input"].(CreateTransferInputCustom)), true
	case "Mutation.moveInvestment":
		if e.complexity.Mutation.MoveInvestment == nil {
			break
		}

		args, err := ec.field_Mutation_moveInvestment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MoveInvestment(childComplexity, args["input"].(MoveInvestmentInputCustom)), true
	case "Mutation.sellInvestment":
		if e.complexity.Mutation.SellInvestment == nil {
			break
		}

		args, err := ec.field_Mutation_sellInvestment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SellInvestment(childComplexity, args["input"].(SellInvestmentInputCustom)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true
	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true
	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true
	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.accounts":
		if e.complexity.Query.Accounts == nil {
			break
		}

		args, err := ec.field_Query_accounts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Accounts(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["where"].(*ent.AccountWhereInput)), true
	case "Query.cryptoQuote":
		if e.complexity.Query.CryptoQuote == nil {
			break
		}

		args, err := ec.field_Query_cryptoQuote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CryptoQuote(childComplexity, args["symbol"].(string)), true
	case "Query.currencies":
		if e.complexity.Query.Currencies == nil {
			break
		}

		return e.complexity.Query.Currencies(childComplexity), true
	case "Query.financialReport":
		if e.complexity.Query.FinancialReport == nil {
			break
		}

		args, err := ec.field_Query_financialReport_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FinancialReport(childComplexity, args["period"].(TimePeriodInput)), true
	case "Query.fxRate":
		if e.complexity.Query.FxRate == nil {
			break
		}

		args, err := ec.field_Query_fxRate_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FxRate(childComplexity, args["from"].(string), args["to"].(string), args["datetime"].(time.Time)), true
	case "Query.households":
		if e.complexity.Query.Households == nil {
			break
		}

		return e.complexity.Query.Households(childComplexity), true
	case "Query.investmentLots":
		if e.complexity.Query.InvestmentLots == nil {
			break
		}

		args, err := ec.field_Query_investmentLots_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InvestmentLots(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["where"].(*ent.InvestmentLotWhereInput)), true
	case "Query.investments":
		if e.complexity.Query.Investments == nil {
			break
		}

		args, err := ec.field_Query_investments_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Investments(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["where"].(*ent.InvestmentWhereInput)), true
	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true
	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true
	case "Query.stockQuote":
		if e.complexity.Query.StockQuote == nil {
			break
		}

		args, err := ec.field_Query_stockQuote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.StockQuote(childComplexity, args["symbol"].(string)), true
	case "Query.transactionCategories":
		if e.complexity.Query.TransactionCategories == nil {
			break
		}

		args, err := ec.field_Query_transactionCategories_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TransactionCategories(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["where"].(*ent.TransactionCategoryWhereInput)), true
	case "Query.transactionEntries":
		if e.complexity.Query.TransactionEntries == nil {
			break
		}

		return e.complexity.Query.TransactionEntries(childComplexity), true
	case "Query.transactions":
		if e.complexity.Query.Transactions == nil {
			break
		}

		args, err := ec.field_Query_transactions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transactions(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true
	case "Query.userHouseholds":
		if e.complexity.Query.UserHouseholds == nil {
			break
		}

		return e.complexity.Query.UserHouseholds(childComplexity), true

	case "StockQuoteResult.currency":
		if e.complexity.StockQuoteResult.Currency == nil {
			break
		}

		return e.complexity.StockQuoteResult.Currency(childComplexity), true
	case "StockQuoteResult.currentPrice":
		if e.complexity.StockQuoteResult.CurrentPrice == nil {
			break
		}

		return e.complexity.StockQuoteResult.CurrentPrice(childComplexity), true
	case "StockQuoteResult.exchange":
		if e.complexity.StockQuoteResult.Exchange == nil {
			break
		}

		return e.complexity.StockQuoteResult.Exchange(childComplexity), true
	case "StockQuoteResult.name":
		if e.complexity.StockQuoteResult.Name == nil {
			break
		}

		return e.complexity.StockQuoteResult.Name(childComplexity), true
	case "StockQuoteResult.symbol":
		if e.complexity.StockQuoteResult.Symbol == nil {
			break
		}

		return e.complexity.StockQuoteResult.Symbol(childComplexity), true

	case "Transaction.category":
		if e.complexity.Transaction.Category == nil {
			break
		}

		return e.complexity.Transaction.Category(childComplexity), true
	case "Transaction.categoryID":
		if e.complexity.Transaction.CategoryID == nil {
			break
		}

		return e.complexity.Transaction.CategoryID(childComplexity), true
	case "Transaction.createTime":
		if e.complexity.Transaction.CreateTime == nil {
			break
		}

		return e.complexity.Transaction.CreateTime(childComplexity), true
	case "Transaction.datetime":
		if e.complexity.Transaction.Datetime == nil {
			break
		}

		return e.complexity.Transaction.Datetime(childComplexity), true
	case "Transaction.description":
		if e.complexity.Transaction.Description == nil {
			break
		}

		return e.complexity.Transaction.Description(childComplexity), true
	case "Transaction.household":
		if e.complexity.Transaction.Household == nil {
			break
		}

		return e.complexity.Transaction.Household(childComplexity), true
	case "Transaction.householdID":
		if e.complexity.Transaction.HouseholdID == nil {
			break
		}

		return e.complexity.Transaction.HouseholdID(childComplexity), true
	case "Transaction.id":
		if e.complexity.Transaction.ID == nil {
			break
		}

		return e.complexity.Transaction.ID(childComplexity), true
	case "Transaction.investmentLots":
		if e.complexity.Transaction.InvestmentLots == nil {
			break
		}

		return e.complexity.Transaction.InvestmentLots(childComplexity), true
	case "Transaction.transactionEntries":
		if e.complexity.Transaction.TransactionEntries == nil {
			break
		}

		return e.complexity.Transaction.TransactionEntries(childComplexity), true
	case "Transaction.updateTime":
		if e.complexity.Transaction.UpdateTime == nil {
			break
		}

		return e.complexity.Transaction.UpdateTime(childComplexity), true
	case "Transaction.user":
		if e.complexity.Transaction.User == nil {
			break
		}

		return e.complexity.Transaction.User(childComplexity), true
	case "Transaction.userID":
		if e.complexity.Transaction.UserID == nil {
			break
		}

		return e.complexity.Transaction.UserID(childComplexity), true

	case "TransactionCategory.createTime":
		if e.complexity.TransactionCategory.CreateTime == nil {
			break
		}

		return e.complexity.TransactionCategory.CreateTime(childComplexity), true
	case "TransactionCategory.household":
		if e.complexity.TransactionCategory.Household == nil {
			break
		}

		return e.complexity.TransactionCategory.Household(childComplexity), true
	case "TransactionCategory.householdID":
		if e.complexity.TransactionCategory.HouseholdID == nil {
			break
		}

		return e.complexity.TransactionCategory.HouseholdID(childComplexity), true
	case "TransactionCategory.id":
		if e.complexity.TransactionCategory.ID == nil {
			break
		}

		return e.complexity.TransactionCategory.ID(childComplexity), true
	case "TransactionCategory.icon":
		if e.complexity.TransactionCategory.Icon == nil {
			break
		}

		return e.complexity.TransactionCategory.Icon(childComplexity), true
	case "TransactionCategory.isImmutable":
		if e.complexity.TransactionCategory.IsImmutable == nil {
			break
		}

		return e.complexity.TransactionCategory.IsImmutable(childComplexity), true
	case "TransactionCategory.name":
		if e.complexity.TransactionCategory.Name == nil {
			break
		}

		return e.complexity.TransactionCategory.Name(childComplexity), true
	case "TransactionCategory.transactions":
		if e.complexity.TransactionCategory.Transactions == nil {
			break
		}

		return e.complexity.TransactionCategory.Transactions(childComplexity), true
	case "TransactionCategory.type":
		if e.complexity.TransactionCategory.Type == nil {
			break
		}

		return e.complexity.TransactionCategory.Type(childComplexity), true
	case "TransactionCategory.updateTime":
		if e.complexity.TransactionCategory.UpdateTime == nil {
			break
		}

		return e.complexity.TransactionCategory.UpdateTime(childComplexity), true

	case "TransactionCategoryConnection.edges":
		if e.complexity.TransactionCategoryConnection.Edges == nil {
			break
		}

		return e.complexity.TransactionCategoryConnection.Edges(childComplexity), true
	case "TransactionCategoryConnection.pageInfo":
		if e.complexity.TransactionCategoryConnection.PageInfo == nil {
			break
		}

		return e.complexity.TransactionCategoryConnection.PageInfo(childComplexity), true
	case "TransactionCategoryConnection.totalCount":
		if e.complexity.TransactionCategoryConnection.TotalCount == nil {
			break
		}

		return e.complexity.TransactionCategoryConnection.TotalCount(childComplexity), true

	case "TransactionCategoryEdge.cursor":
		if e.complexity.TransactionCategoryEdge.Cursor == nil {
			break
		}

		return e.complexity.TransactionCategoryEdge.Cursor(childComplexity), true
	case "TransactionCategoryEdge.node":
		if e.complexity.TransactionCategoryEdge.Node == nil {
			break
		}

		return e.complexity.TransactionCategoryEdge.Node(childComplexity), true

	case "TransactionConnection.edges":
		if e.complexity.TransactionConnection.Edges == nil {
			break
		}

		return e.complexity.TransactionConnection.Edges(childComplexity), true
	case "TransactionConnection.pageInfo":
		if e.complexity.TransactionConnection.PageInfo == nil {
			break
		}

		return e.complexity.TransactionConnection.PageInfo(childComplexity), true
	case "TransactionConnection.totalCount":
		if e.complexity.TransactionConnection.TotalCount == nil {
			break
		}

		return e.complexity.TransactionConnection.TotalCount(childComplexity), true

	case "TransactionEdge.cursor":
		if e.complexity.TransactionEdge.Cursor == nil {
			break
		}

		return e.complexity.TransactionEdge.Cursor(childComplexity), true
	case "TransactionEdge.node":
		if e.complexity.TransactionEdge.Node == nil {
			break
		}

		return e.complexity.TransactionEdge.Node(childComplexity), true

	case "TransactionEntry.account":
		if e.complexity.TransactionEntry.Account == nil {
			break
		}

		return e.complexity.TransactionEntry.Account(childComplexity), true
	case "TransactionEntry.accountID":
		if e.complexity.TransactionEntry.AccountID == nil {
			break
		}

		return e.complexity.TransactionEntry.AccountID(childComplexity), true
	case "TransactionEntry.amount":
		if e.complexity.TransactionEntry.Amount == nil {
			break
		}

		return e.complexity.TransactionEntry.Amount(childComplexity), true
	case "TransactionEntry.createTime":
		if e.complexity.TransactionEntry.CreateTime == nil {
			break
		}

		return e.complexity.TransactionEntry.CreateTime(childComplexity), true
	case "TransactionEntry.currency":
		if e.complexity.TransactionEntry.Currency == nil {
			break
		}

		return e.complexity.TransactionEntry.Currency(childComplexity), true
	case "TransactionEntry.currencyID":
		if e.complexity.TransactionEntry.CurrencyID == nil {
			break
		}

		return e.complexity.TransactionEntry.CurrencyID(childComplexity), true
	case "TransactionEntry.household":
		if e.complexity.TransactionEntry.Household == nil {
			break
		}

		return e.complexity.TransactionEntry.Household(childComplexity), true
	case "TransactionEntry.householdID":
		if e.complexity.TransactionEntry.HouseholdID == nil {
			break
		}

		return e.complexity.TransactionEntry.HouseholdID(childComplexity), true
	case "TransactionEntry.id":
		if e.complexity.TransactionEntry.ID == nil {
			break
		}

		return e.complexity.TransactionEntry.ID(childComplexity), true
	case "TransactionEntry.transaction":
		if e.complexity.TransactionEntry.Transaction == nil {
			break
		}

		return e.complexity.TransactionEntry.Transaction(childComplexity), true
	case "TransactionEntry.transactionID":
		if e.complexity.TransactionEntry.TransactionID == nil {
			break
		}

		return e.complexity.TransactionEntry.TransactionID(childComplexity), true
	case "TransactionEntry.updateTime":
		if e.complexity.TransactionEntry.UpdateTime == nil {
			break
		}

		return e.complexity.TransactionEntry.UpdateTime(childComplexity), true

	case "User.accounts":
		if e.complexity.User.Accounts == nil {
			break
		}

		return e.complexity.User.Accounts(childComplexity), true
	case "User.createTime":
		if e.complexity.User.CreateTime == nil {
			break
		}

		return e.complexity.User.CreateTime(childComplexity), true
	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true
	case "User.households":
		if e.complexity.User.Households == nil {
			break
		}

		return e.complexity.User.Households(childComplexity), true
	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true
	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true
	case "User.transactions":
		if e.complexity.User.Transactions == nil {
			break
		}

		return e.complexity.User.Transactions(childComplexity), true
	case "User.updateTime":
		if e.complexity.User.UpdateTime == nil {
			break
		}

		return e.complexity.User.UpdateTime(childComplexity), true
	case "User.userHouseholds":
		if e.complexity.User.UserHouseholds == nil {
			break
		}

		return e.complexity.User.UserHouseholds(childComplexity), true
	case "User.userKeys":
		if e.complexity.User.UserKeys == nil {
			break
		}

		return e.complexity.User.UserKeys(childComplexity), true

	case "UserHousehold.createTime":
		if e.complexity.UserHousehold.CreateTime == nil {
			break
		}

		return e.complexity.UserHousehold.CreateTime(childComplexity), true
	case "UserHousehold.household":
		if e.complexity.UserHousehold.Household == nil {
			break
		}

		return e.complexity.UserHousehold.Household(childComplexity), true
	case "UserHousehold.householdID":
		if e.complexity.UserHousehold.HouseholdID == nil {
			break
		}

		return e.complexity.UserHousehold.HouseholdID(childComplexity), true
	case "UserHousehold.id":
		if e.complexity.UserHousehold.ID == nil {
			break
		}

		return e.complexity.UserHousehold.ID(childComplexity), true
	case "UserHousehold.role":
		if e.complexity.UserHousehold.Role == nil {
			break
		}

		return e.complexity.UserHousehold.Role(childComplexity), true
	case "UserHousehold.updateTime":
		if e.complexity.UserHousehold.UpdateTime == nil {
			break
		}

		return e.complexity.UserHousehold.UpdateTime(childComplexity), true
	case "UserHousehold.user":
		if e.complexity.UserHousehold.User == nil {
			break
		}

		return e.complexity.UserHousehold.User(childComplexity), true
	case "UserHousehold.userID":
		if e.complexity.UserHousehold.UserID == nil {
			break
		}

		return e.complexity.UserHousehold.UserID(childComplexity), true

	case "UserKey.createTime":
		if e.complexity.UserKey.CreateTime == nil {
			break
		}

		return e.complexity.UserKey.CreateTime(childComplexity), true
	case "UserKey.id":
		if e.complexity.UserKey.ID == nil {
			break
		}

		return e.complexity.UserKey.ID(childComplexity), true
	case "UserKey.key":
		if e.complexity.UserKey.Key == nil {
			break
		}

		return e.complexity.UserKey.Key(childComplexity), true
	case "UserKey.provider":
		if e.complexity.UserKey.Provider == nil {
			break
		}

		return e.complexity.UserKey.Provider(childComplexity), true
	case "UserKey.updateTime":
		if e.complexity.UserKey.UpdateTime == nil {
			break
		}

		return e.complexity.UserKey.UpdateTime(childComplexity), true
	case "UserKey.user":
		if e.complexity.UserKey.User == nil {
			break
		}

		return e.complexity.UserKey.User(childComplexity), true
	case "UserKey.userID":
		if e.complexity.UserKey.UserID == nil {
			break
		}

		return e.complexity.UserKey.UserID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAccountWhereInput,
		ec.unmarshalInputBuyInvestmentInputCustom,
		ec.unmarshalInputCreateAccountInput,
		ec.unmarshalInputCreateExpenseInputCustom,
		ec.unmarshalInputCreateIncomeInputCustom,
		ec.unmarshalInputCreateInvestmentInput,
		ec.unmarshalInputCreateInvestmentInputCustom,
		ec.unmarshalInputCreateInvestmentLotInput,
		ec.unmarshalInputCreateTransactionCategoryInput,
		ec.unmarshalInputCreateTransactionEntryInput,
		ec.unmarshalInputCreateTransactionInput,
		ec.unmarshalInputCreateTransferInputCustom,
		ec.unmarshalInputCurrencyWhereInput,
		ec.unmarshalInputHouseholdWhereInput,
		ec.unmarshalInputInvestmentLotWhereInput,
		ec.unmarshalInputInvestmentWhereInput,
		ec.unmarshalInputMoveInvestmentInputCustom,
		ec.unmarshalInputSellInvestmentInputCustom,
		ec.unmarshalInputTimePeriodInput,
		ec.unmarshalInputTransactionCategoryWhereInput,
		ec.unmarshalInputTransactionEntryWhereInput,
		ec.unmarshalInputTransactionOrder,
		ec.unmarshalInputTransactionWhereInput,
		ec.unmarshalInputUpdateAccountInput,
		ec.unmarshalInputUpdateInvestmentInput,
		ec.unmarshalInputUpdateInvestmentLotInput,
		ec.unmarshalInputUserHouseholdWhereInput,
		ec.unmarshalInputUserKeyWhereInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "ent.graphql" "beavermoney.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "ent.graphql", Input: sourceData("ent.graphql"), BuiltIn: false},
	{Name: "beavermoney.graphql", Input: sourceData("beavermoney.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_buyInvestment_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBuyInvestmentInputCustom2beavermoneyappBuyInvestmentInputCustom)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createAccount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateAccountInput2beavermoneyappentCreateAccountInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createExpense_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateExpenseInputCustom2beavermoneyappCreateExpenseInputCustom)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createIncome_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateIncomeInputCustom2beavermoneyappCreateIncomeInputCustom)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createInvestment_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateInvestmentInputCustom2beavermoneyappCreateInvestmentInputCustom)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createTransactionCategory_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateTransactionCategoryInput2beavermoneyappentCreateTransactionCategoryInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createTransfer_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateTransferInputCustom2beavermoneyappCreateTransferInputCustom)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_moveInvestment_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNMoveInvestmentInputCustom2beavermoneyappMoveInvestmentInputCustom)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_sellInvestment_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNSellInvestmentInputCustom2beavermoneyappSellInvestmentInputCustom)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_accounts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2entgoiocontribentgqlCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2entgoiocontribentgqlCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["last"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput)
	if err != nil {
		return nil, err
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_cryptoQuote_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "symbol", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["symbol"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_financialReport_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "period", ec.unmarshalNTimePeriodInput2beavermoneyappTimePeriodInput)
	if err != nil {
		return nil, err
	}
	args["period"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fxRate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "from", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["from"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "to", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["to"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "datetime", ec.unmarshalNTime2timeTime)
	if err != nil {
		return nil, err
	}
	args["datetime"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_investmentLots_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2entgoiocontribentgqlCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2entgoiocontribentgqlCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["last"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput)
	if err != nil {
		return nil, err
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_investments_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2entgoiocontribentgqlCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2entgoiocontribentgqlCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["last"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOInvestmentWhereInput2beavermoneyappentInvestmentWhereInput)
	if err != nil {
		return nil, err
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2int)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2int)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_stockQuote_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "symbol", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["symbol"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_transactionCategories_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2entgoiocontribentgqlCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2entgoiocontribentgqlCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["last"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOTransactionCategoryWhereInput2beavermoneyappentTransactionCategoryWhereInput)
	if err != nil {
		return nil, err
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_transactions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2entgoiocontribentgqlCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2entgoiocontribentgqlCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["last"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "orderBy", ec.unmarshalOTransactionOrder2beavermoneyappentTransactionOrder)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	arg5, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput)
	if err != nil {
		return nil, err
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Account_id(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_name(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_type(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNAccountType2beavermoneyappentaccountType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AccountType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_balance(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_balance,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Account().Balance(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_balance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_icon(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_icon,
		func(ctx context.Context) (any, error) {
			return obj.Icon, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Account_icon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_value(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_value,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Account().Value(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_fxRate(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_fxRate,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Account().FxRate(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_fxRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_currencyID(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_currencyID,
		func(ctx context.Context) (any, error) {
			return obj.CurrencyID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_currencyID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_userID(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_userID,
		func(ctx context.Context) (any, error) {
			return obj.UserID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_household(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2beavermoneyappentHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currencyID":
				return ec.fieldContext_Household_currencyID(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Household_investmentLots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_currency(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_currency,
		func(ctx context.Context) (any, error) {
			return obj.Currency(ctx)
		},
		nil,
		ec.marshalNCurrency2beavermoneyappentCurrency,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "code":
				return ec.fieldContext_Currency_code(ctx, field)
			case "accounts":
				return ec.fieldContext_Currency_accounts(ctx, field)
			case "investments":
				return ec.fieldContext_Currency_investments(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Currency_transactionEntries(ctx, field)
			case "households":
				return ec.fieldContext_Currency_households(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_user(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_user,
		func(ctx context.Context) (any, error) {
			return obj.User(ctx)
		},
		nil,
		ec.marshalNUser2beavermoneyappentUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "households":
				return ec.fieldContext_User_households(ctx, field)
			case "accounts":
				return ec.fieldContext_User_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_User_transactions(ctx, field)
			case "userKeys":
				return ec.fieldContext_User_userKeys(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_User_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_transactionEntries(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_transactionEntries,
		func(ctx context.Context) (any, error) {
			return obj.TransactionEntries(ctx)
		},
		nil,
		ec.marshalOTransactionEntry2beavermoneyappentTransactionEntry,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Account_transactionEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionEntry_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionEntry_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionEntry_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionEntry_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_TransactionEntry_amount(ctx, field)
			case "accountID":
				return ec.fieldContext_TransactionEntry_accountID(ctx, field)
			case "currencyID":
				return ec.fieldContext_TransactionEntry_currencyID(ctx, field)
			case "transactionID":
				return ec.fieldContext_TransactionEntry_transactionID(ctx, field)
			case "household":
				return ec.fieldContext_TransactionEntry_household(ctx, field)
			case "account":
				return ec.fieldContext_TransactionEntry_account(ctx, field)
			case "currency":
				return ec.fieldContext_TransactionEntry_currency(ctx, field)
			case "transaction":
				return ec.fieldContext_TransactionEntry_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_investments(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_investments,
		func(ctx context.Context) (any, error) {
			return obj.Investments(ctx)
		},
		nil,
		ec.marshalOInvestment2beavermoneyappentInvestment,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Account_investments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Investment_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Investment_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Investment_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Investment_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Investment_name(ctx, field)
			case "type":
				return ec.fieldContext_Investment_type(ctx, field)
			case "symbol":
				return ec.fieldContext_Investment_symbol(ctx, field)
			case "amount":
				return ec.fieldContext_Investment_amount(ctx, field)
			case "quote":
				return ec.fieldContext_Investment_quote(ctx, field)
			case "value":
				return ec.fieldContext_Investment_value(ctx, field)
			case "accountID":
				return ec.fieldContext_Investment_accountID(ctx, field)
			case "currencyID":
				return ec.fieldContext_Investment_currencyID(ctx, field)
			case "account":
				return ec.fieldContext_Investment_account(ctx, field)
			case "household":
				return ec.fieldContext_Investment_household(ctx, field)
			case "currency":
				return ec.fieldContext_Investment_currency(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Investment_investmentLots(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Investment_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Investment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_balanceInHouseholdCurrency(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_balanceInHouseholdCurrency,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Account().BalanceInHouseholdCurrency(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_balanceInHouseholdCurrency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_valueInHouseholdCurrency(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_valueInHouseholdCurrency,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Account().ValueInHouseholdCurrency(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_valueInHouseholdCurrency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.AccountConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AccountConnection_edges,
		func(ctx context.Context) (any, error) {
			return obj.Edges, nil
		},
		nil,
		ec.marshalOAccountEdge2beavermoneyappentAccountEdge,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AccountConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_AccountEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_AccountEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccountEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.AccountConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AccountConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNPageInfo2entgoiocontribentgqlPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AccountConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.AccountConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AccountConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AccountConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.AccountEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AccountEdge_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalOAccount2beavermoneyappentAccount,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AccountEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "icon":
				return ec.fieldContext_Account_icon(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "currencyID":
				return ec.fieldContext_Account_currencyID(ctx, field)
			case "userID":
				return ec.fieldContext_Account_userID(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.AccountEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AccountEdge_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalNCursor2entgoiocontribentgqlCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AccountEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryAggregate_category(ctx context.Context, field graphql.CollectedField, obj *CategoryAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CategoryAggregate_category,
		func(ctx context.Context) (any, error) {
			return obj.Category, nil
		},
		nil,
		ec.marshalNTransactionCategory2beavermoneyappentTransactionCategory,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CategoryAggregate_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionCategory_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionCategory_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionCategory_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionCategory_householdID(ctx, field)
			case "name":
				return ec.fieldContext_TransactionCategory_name(ctx, field)
			case "type":
				return ec.fieldContext_TransactionCategory_type(ctx, field)
			case "icon":
				return ec.fieldContext_TransactionCategory_icon(ctx, field)
			case "isImmutable":
				return ec.fieldContext_TransactionCategory_isImmutable(ctx, field)
			case "household":
				return ec.fieldContext_TransactionCategory_household(ctx, field)
			case "transactions":
				return ec.fieldContext_TransactionCategory_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryAggregate_total(ctx context.Context, field graphql.CollectedField, obj *CategoryAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CategoryAggregate_total,
		func(ctx context.Context) (any, error) {
			return obj.Total, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CategoryAggregate_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryAggregate_transactionCount(ctx context.Context, field graphql.CollectedField, obj *CategoryAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CategoryAggregate_transactionCount,
		func(ctx context.Context) (any, error) {
			return obj.TransactionCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CategoryAggregate_transactionCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryTypeAggregate_categoryType(ctx context.Context, field graphql.CollectedField, obj *CategoryTypeAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CategoryTypeAggregate_categoryType,
		func(ctx context.Context) (any, error) {
			return obj.CategoryType, nil
		},
		nil,
		ec.marshalNTransactionCategoryType2beavermoneyappenttransactioncategoryType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CategoryTypeAggregate_categoryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryTypeAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TransactionCategoryType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryTypeAggregate_total(ctx context.Context, field graphql.CollectedField, obj *CategoryTypeAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CategoryTypeAggregate_total,
		func(ctx context.Context) (any, error) {
			return obj.Total, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CategoryTypeAggregate_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryTypeAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryTypeAggregate_transactionCount(ctx context.Context, field graphql.CollectedField, obj *CategoryTypeAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CategoryTypeAggregate_transactionCount,
		func(ctx context.Context) (any, error) {
			return obj.TransactionCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CategoryTypeAggregate_transactionCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryTypeAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryTypeAggregate_categories(ctx context.Context, field graphql.CollectedField, obj *CategoryTypeAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CategoryTypeAggregate_categories,
		func(ctx context.Context) (any, error) {
			return obj.Categories, nil
		},
		nil,
		ec.marshalNCategoryAggregate2beavermoneyappCategoryAggregate,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CategoryTypeAggregate_categories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryTypeAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "category":
				return ec.fieldContext_CategoryAggregate_category(ctx, field)
			case "total":
				return ec.fieldContext_CategoryAggregate_total(ctx, field)
			case "transactionCount":
				return ec.fieldContext_CategoryAggregate_transactionCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CategoryAggregate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CryptoQuoteResult_symbol(ctx context.Context, field graphql.CollectedField, obj *CryptoQuoteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CryptoQuoteResult_symbol,
		func(ctx context.Context) (any, error) {
			return obj.Symbol, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CryptoQuoteResult_symbol(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CryptoQuoteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CryptoQuoteResult_name(ctx context.Context, field graphql.CollectedField, obj *CryptoQuoteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CryptoQuoteResult_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CryptoQuoteResult_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CryptoQuoteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CryptoQuoteResult_exchange(ctx context.Context, field graphql.CollectedField, obj *CryptoQuoteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CryptoQuoteResult_exchange,
		func(ctx context.Context) (any, error) {
			return obj.Exchange, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CryptoQuoteResult_exchange(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CryptoQuoteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CryptoQuoteResult_currency(ctx context.Context, field graphql.CollectedField, obj *CryptoQuoteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CryptoQuoteResult_currency,
		func(ctx context.Context) (any, error) {
			return obj.Currency, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CryptoQuoteResult_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CryptoQuoteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CryptoQuoteResult_currentPrice(ctx context.Context, field graphql.CollectedField, obj *CryptoQuoteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CryptoQuoteResult_currentPrice,
		func(ctx context.Context) (any, error) {
			return obj.CurrentPrice, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CryptoQuoteResult_currentPrice(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CryptoQuoteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_id(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Currency_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_code(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_code,
		func(ctx context.Context) (any, error) {
			return obj.Code, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Currency_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_accounts(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_accounts,
		func(ctx context.Context) (any, error) {
			return obj.Accounts(ctx)
		},
		nil,
		ec.marshalOAccount2beavermoneyappentAccount,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Currency_accounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "icon":
				return ec.fieldContext_Account_icon(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "currencyID":
				return ec.fieldContext_Account_currencyID(ctx, field)
			case "userID":
				return ec.fieldContext_Account_userID(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_investments(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_investments,
		func(ctx context.Context) (any, error) {
			return obj.Investments(ctx)
		},
		nil,
		ec.marshalOInvestment2beavermoneyappentInvestment,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Currency_investments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Investment_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Investment_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Investment_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Investment_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Investment_name(ctx, field)
			case "type":
				return ec.fieldContext_Investment_type(ctx, field)
			case "symbol":
				return ec.fieldContext_Investment_symbol(ctx, field)
			case "amount":
				return ec.fieldContext_Investment_amount(ctx, field)
			case "quote":
				return ec.fieldContext_Investment_quote(ctx, field)
			case "value":
				return ec.fieldContext_Investment_value(ctx, field)
			case "accountID":
				return ec.fieldContext_Investment_accountID(ctx, field)
			case "currencyID":
				return ec.fieldContext_Investment_currencyID(ctx, field)
			case "account":
				return ec.fieldContext_Investment_account(ctx, field)
			case "household":
				return ec.fieldContext_Investment_household(ctx, field)
			case "currency":
				return ec.fieldContext_Investment_currency(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Investment_investmentLots(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Investment_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Investment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_transactionEntries(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_transactionEntries,
		func(ctx context.Context) (any, error) {
			return obj.TransactionEntries(ctx)
		},
		nil,
		ec.marshalOTransactionEntry2beavermoneyappentTransactionEntry,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Currency_transactionEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionEntry_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionEntry_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionEntry_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionEntry_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_TransactionEntry_amount(ctx, field)
			case "accountID":
				return ec.fieldContext_TransactionEntry_accountID(ctx, field)
			case "currencyID":
				return ec.fieldContext_TransactionEntry_currencyID(ctx, field)
			case "transactionID":
				return ec.fieldContext_TransactionEntry_transactionID(ctx, field)
			case "household":
				return ec.fieldContext_TransactionEntry_household(ctx, field)
			case "account":
				return ec.fieldContext_TransactionEntry_account(ctx, field)
			case "currency":
				return ec.fieldContext_TransactionEntry_currency(ctx, field)
			case "transaction":
				return ec.fieldContext_TransactionEntry_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_households(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_households,
		func(ctx context.Context) (any, error) {
			return obj.Households(ctx)
		},
		nil,
		ec.marshalOHousehold2beavermoneyappentHousehold,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Currency_households(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currencyID":
				return ec.fieldContext_Household_currencyID(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Household_investmentLots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinancialReport_totalIncome(ctx context.Context, field graphql.CollectedField, obj *FinancialReport) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FinancialReport_totalIncome,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FinancialReport().TotalIncome(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FinancialReport_totalIncome(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinancialReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinancialReport_totalExpenses(ctx context.Context, field graphql.CollectedField, obj *FinancialReport) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FinancialReport_totalExpenses,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FinancialReport().TotalExpenses(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FinancialReport_totalExpenses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinancialReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinancialReport_incomeByCategoryType(ctx context.Context, field graphql.CollectedField, obj *FinancialReport) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FinancialReport_incomeByCategoryType,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FinancialReport().IncomeByCategoryType(ctx, obj)
		},
		nil,
		ec.marshalNCategoryTypeAggregate2beavermoneyappCategoryTypeAggregate,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FinancialReport_incomeByCategoryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinancialReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "categoryType":
				return ec.fieldContext_CategoryTypeAggregate_categoryType(ctx, field)
			case "total":
				return ec.fieldContext_CategoryTypeAggregate_total(ctx, field)
			case "transactionCount":
				return ec.fieldContext_CategoryTypeAggregate_transactionCount(ctx, field)
			case "categories":
				return ec.fieldContext_CategoryTypeAggregate_categories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CategoryTypeAggregate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinancialReport_expensesByCategoryType(ctx context.Context, field graphql.CollectedField, obj *FinancialReport) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FinancialReport_expensesByCategoryType,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FinancialReport().ExpensesByCategoryType(ctx, obj)
		},
		nil,
		ec.marshalNCategoryTypeAggregate2beavermoneyappCategoryTypeAggregate,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FinancialReport_expensesByCategoryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinancialReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "categoryType":
				return ec.fieldContext_CategoryTypeAggregate_categoryType(ctx, field)
			case "total":
				return ec.fieldContext_CategoryTypeAggregate_total(ctx, field)
			case "transactionCount":
				return ec.fieldContext_CategoryTypeAggregate_transactionCount(ctx, field)
			case "categories":
				return ec.fieldContext_CategoryTypeAggregate_categories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CategoryTypeAggregate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinancialReport_transactionCount(ctx context.Context, field graphql.CollectedField, obj *FinancialReport) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FinancialReport_transactionCount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FinancialReport().TransactionCount(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FinancialReport_transactionCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinancialReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinancialReport_startDate(ctx context.Context, field graphql.CollectedField, obj *FinancialReport) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FinancialReport_startDate,
		func(ctx context.Context) (any, error) {
			return obj.StartDate, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FinancialReport_startDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinancialReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinancialReport_endDate(ctx context.Context, field graphql.CollectedField, obj *FinancialReport) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FinancialReport_endDate,
		func(ctx context.Context) (any, error) {
			return obj.EndDate, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FinancialReport_endDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinancialReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_id(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_name(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_locale(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_locale,
		func(ctx context.Context) (any, error) {
			return obj.Locale, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_locale(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_currencyID(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_currencyID,
		func(ctx context.Context) (any, error) {
			return obj.CurrencyID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_currencyID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_currency(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_currency,
		func(ctx context.Context) (any, error) {
			return obj.Currency(ctx)
		},
		nil,
		ec.marshalNCurrency2beavermoneyappentCurrency,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "code":
				return ec.fieldContext_Currency_code(ctx, field)
			case "accounts":
				return ec.fieldContext_Currency_accounts(ctx, field)
			case "investments":
				return ec.fieldContext_Currency_investments(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Currency_transactionEntries(ctx, field)
			case "households":
				return ec.fieldContext_Currency_households(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_users(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_users,
		func(ctx context.Context) (any, error) {
			return obj.Users(ctx)
		},
		nil,
		ec.marshalOUser2beavermoneyappentUser,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "households":
				return ec.fieldContext_User_households(ctx, field)
			case "accounts":
				return ec.fieldContext_User_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_User_transactions(ctx, field)
			case "userKeys":
				return ec.fieldContext_User_userKeys(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_User_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_accounts(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_accounts,
		func(ctx context.Context) (any, error) {
			return obj.Accounts(ctx)
		},
		nil,
		ec.marshalOAccount2beavermoneyappentAccount,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_accounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "icon":
				return ec.fieldContext_Account_icon(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "currencyID":
				return ec.fieldContext_Account_currencyID(ctx, field)
			case "userID":
				return ec.fieldContext_Account_userID(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_transactions(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_transactions,
		func(ctx context.Context) (any, error) {
			return obj.Transactions(ctx)
		},
		nil,
		ec.marshalOTransaction2beavermoneyappentTransaction,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_transactions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "userID":
				return ec.fieldContext_Transaction_userID(ctx, field)
			case "categoryID":
				return ec.fieldContext_Transaction_categoryID(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Transaction_investmentLots(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_investments(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_investments,
		func(ctx context.Context) (any, error) {
			return obj.Investments(ctx)
		},
		nil,
		ec.marshalOInvestment2beavermoneyappentInvestment,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_investments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Investment_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Investment_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Investment_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Investment_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Investment_name(ctx, field)
			case "type":
				return ec.fieldContext_Investment_type(ctx, field)
			case "symbol":
				return ec.fieldContext_Investment_symbol(ctx, field)
			case "amount":
				return ec.fieldContext_Investment_amount(ctx, field)
			case "quote":
				return ec.fieldContext_Investment_quote(ctx, field)
			case "value":
				return ec.fieldContext_Investment_value(ctx, field)
			case "accountID":
				return ec.fieldContext_Investment_accountID(ctx, field)
			case "currencyID":
				return ec.fieldContext_Investment_currencyID(ctx, field)
			case "account":
				return ec.fieldContext_Investment_account(ctx, field)
			case "household":
				return ec.fieldContext_Investment_household(ctx, field)
			case "currency":
				return ec.fieldContext_Investment_currency(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Investment_investmentLots(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Investment_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Investment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_investmentLots(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_investmentLots,
		func(ctx context.Context) (any, error) {
			return obj.InvestmentLots(ctx)
		},
		nil,
		ec.marshalOInvestmentLot2beavermoneyappentInvestmentLot,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_investmentLots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InvestmentLot_id(ctx, field)
			case "createTime":
				return ec.fieldContext_InvestmentLot_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_InvestmentLot_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_InvestmentLot_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_InvestmentLot_amount(ctx, field)
			case "price":
				return ec.fieldContext_InvestmentLot_price(ctx, field)
			case "investmentID":
				return ec.fieldContext_InvestmentLot_investmentID(ctx, field)
			case "transactionID":
				return ec.fieldContext_InvestmentLot_transactionID(ctx, field)
			case "household":
				return ec.fieldContext_InvestmentLot_household(ctx, field)
			case "investment":
				return ec.fieldContext_InvestmentLot_investment(ctx, field)
			case "transaction":
				return ec.fieldContext_InvestmentLot_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvestmentLot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_transactionCategories(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_transactionCategories,
		func(ctx context.Context) (any, error) {
			return obj.TransactionCategories(ctx)
		},
		nil,
		ec.marshalOTransactionCategory2beavermoneyappentTransactionCategory,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_transactionCategories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionCategory_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionCategory_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionCategory_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionCategory_householdID(ctx, field)
			case "name":
				return ec.fieldContext_TransactionCategory_name(ctx, field)
			case "type":
				return ec.fieldContext_TransactionCategory_type(ctx, field)
			case "icon":
				return ec.fieldContext_TransactionCategory_icon(ctx, field)
			case "isImmutable":
				return ec.fieldContext_TransactionCategory_isImmutable(ctx, field)
			case "household":
				return ec.fieldContext_TransactionCategory_household(ctx, field)
			case "transactions":
				return ec.fieldContext_TransactionCategory_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_transactionEntries(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_transactionEntries,
		func(ctx context.Context) (any, error) {
			return obj.TransactionEntries(ctx)
		},
		nil,
		ec.marshalOTransactionEntry2beavermoneyappentTransactionEntry,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_transactionEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionEntry_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionEntry_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionEntry_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionEntry_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_TransactionEntry_amount(ctx, field)
			case "accountID":
				return ec.fieldContext_TransactionEntry_accountID(ctx, field)
			case "currencyID":
				return ec.fieldContext_TransactionEntry_currencyID(ctx, field)
			case "transactionID":
				return ec.fieldContext_TransactionEntry_transactionID(ctx, field)
			case "household":
				return ec.fieldContext_TransactionEntry_household(ctx, field)
			case "account":
				return ec.fieldContext_TransactionEntry_account(ctx, field)
			case "currency":
				return ec.fieldContext_TransactionEntry_currency(ctx, field)
			case "transaction":
				return ec.fieldContext_TransactionEntry_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_userHouseholds(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_userHouseholds,
		func(ctx context.Context) (any, error) {
			return obj.UserHouseholds(ctx)
		},
		nil,
		ec.marshalOUserHousehold2beavermoneyappentUserHousehold,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_userHouseholds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserHousehold_id(ctx, field)
			case "createTime":
				return ec.fieldContext_UserHousehold_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_UserHousehold_updateTime(ctx, field)
			case "userID":
				return ec.fieldContext_UserHousehold_userID(ctx, field)
			case "householdID":
				return ec.fieldContext_UserHousehold_householdID(ctx, field)
			case "role":
				return ec.fieldContext_UserHousehold_role(ctx, field)
			case "user":
				return ec.fieldContext_UserHousehold_user(ctx, field)
			case "household":
				return ec.fieldContext_UserHousehold_household(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserHousehold", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_id(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_name(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_type(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNInvestmentType2beavermoneyappentinvestmentType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type InvestmentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_symbol(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_symbol,
		func(ctx context.Context) (any, error) {
			return obj.Symbol, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_symbol(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_amount(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_amount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Investment().Amount(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_quote(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_quote,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Investment().Quote(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_quote(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_value(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_value,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Investment().Value(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_accountID(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_accountID,
		func(ctx context.Context) (any, error) {
			return obj.AccountID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_accountID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_currencyID(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_currencyID,
		func(ctx context.Context) (any, error) {
			return obj.CurrencyID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_currencyID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_account(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_account,
		func(ctx context.Context) (any, error) {
			return obj.Account(ctx)
		},
		nil,
		ec.marshalNAccount2beavermoneyappentAccount,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "icon":
				return ec.fieldContext_Account_icon(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "currencyID":
				return ec.fieldContext_Account_currencyID(ctx, field)
			case "userID":
				return ec.fieldContext_Account_userID(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_household(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2beavermoneyappentHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currencyID":
				return ec.fieldContext_Household_currencyID(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Household_investmentLots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_currency(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_currency,
		func(ctx context.Context) (any, error) {
			return obj.Currency(ctx)
		},
		nil,
		ec.marshalNCurrency2beavermoneyappentCurrency,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "code":
				return ec.fieldContext_Currency_code(ctx, field)
			case "accounts":
				return ec.fieldContext_Currency_accounts(ctx, field)
			case "investments":
				return ec.fieldContext_Currency_investments(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Currency_transactionEntries(ctx, field)
			case "households":
				return ec.fieldContext_Currency_households(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_investmentLots(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_investmentLots,
		func(ctx context.Context) (any, error) {
			return obj.InvestmentLots(ctx)
		},
		nil,
		ec.marshalOInvestmentLot2beavermoneyappentInvestmentLot,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Investment_investmentLots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InvestmentLot_id(ctx, field)
			case "createTime":
				return ec.fieldContext_InvestmentLot_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_InvestmentLot_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_InvestmentLot_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_InvestmentLot_amount(ctx, field)
			case "price":
				return ec.fieldContext_InvestmentLot_price(ctx, field)
			case "investmentID":
				return ec.fieldContext_InvestmentLot_investmentID(ctx, field)
			case "transactionID":
				return ec.fieldContext_InvestmentLot_transactionID(ctx, field)
			case "household":
				return ec.fieldContext_InvestmentLot_household(ctx, field)
			case "investment":
				return ec.fieldContext_InvestmentLot_investment(ctx, field)
			case "transaction":
				return ec.fieldContext_InvestmentLot_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvestmentLot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_valueInHouseholdCurrency(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_valueInHouseholdCurrency,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Investment().ValueInHouseholdCurrency(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_valueInHouseholdCurrency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentConnection_edges,
		func(ctx context.Context) (any, error) {
			return obj.Edges, nil
		},
		nil,
		ec.marshalOInvestmentEdge2beavermoneyappentInvestmentEdge,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_InvestmentConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_InvestmentEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_InvestmentEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvestmentEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNPageInfo2entgoiocontribentgqlPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentEdge_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalOInvestment2beavermoneyappentInvestment,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_InvestmentEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Investment_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Investment_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Investment_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Investment_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Investment_name(ctx, field)
			case "type":
				return ec.fieldContext_Investment_type(ctx, field)
			case "symbol":
				return ec.fieldContext_Investment_symbol(ctx, field)
			case "amount":
				return ec.fieldContext_Investment_amount(ctx, field)
			case "quote":
				return ec.fieldContext_Investment_quote(ctx, field)
			case "value":
				return ec.fieldContext_Investment_value(ctx, field)
			case "accountID":
				return ec.fieldContext_Investment_accountID(ctx, field)
			case "currencyID":
				return ec.fieldContext_Investment_currencyID(ctx, field)
			case "account":
				return ec.fieldContext_Investment_account(ctx, field)
			case "household":
				return ec.fieldContext_Investment_household(ctx, field)
			case "currency":
				return ec.fieldContext_Investment_currency(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Investment_investmentLots(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Investment_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Investment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentEdge_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalNCursor2entgoiocontribentgqlCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_id(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_amount(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_amount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.InvestmentLot().Amount(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_price(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_price,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.InvestmentLot().Price(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_price(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_investmentID(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_investmentID,
		func(ctx context.Context) (any, error) {
			return obj.InvestmentID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_investmentID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_transactionID(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_transactionID,
		func(ctx context.Context) (any, error) {
			return obj.TransactionID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_transactionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_household(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2beavermoneyappentHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currencyID":
				return ec.fieldContext_Household_currencyID(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Household_investmentLots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_investment(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_investment,
		func(ctx context.Context) (any, error) {
			return obj.Investment(ctx)
		},
		nil,
		ec.marshalNInvestment2beavermoneyappentInvestment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_investment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Investment_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Investment_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Investment_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Investment_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Investment_name(ctx, field)
			case "type":
				return ec.fieldContext_Investment_type(ctx, field)
			case "symbol":
				return ec.fieldContext_Investment_symbol(ctx, field)
			case "amount":
				return ec.fieldContext_Investment_amount(ctx, field)
			case "quote":
				return ec.fieldContext_Investment_quote(ctx, field)
			case "value":
				return ec.fieldContext_Investment_value(ctx, field)
			case "accountID":
				return ec.fieldContext_Investment_accountID(ctx, field)
			case "currencyID":
				return ec.fieldContext_Investment_currencyID(ctx, field)
			case "account":
				return ec.fieldContext_Investment_account(ctx, field)
			case "household":
				return ec.fieldContext_Investment_household(ctx, field)
			case "currency":
				return ec.fieldContext_Investment_currency(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Investment_investmentLots(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Investment_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Investment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLot_transaction(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLot_transaction,
		func(ctx context.Context) (any, error) {
			return obj.Transaction(ctx)
		},
		nil,
		ec.marshalNTransaction2beavermoneyappentTransaction,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLot_transaction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLot",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "userID":
				return ec.fieldContext_Transaction_userID(ctx, field)
			case "categoryID":
				return ec.fieldContext_Transaction_categoryID(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Transaction_investmentLots(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLotConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLotConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLotConnection_edges,
		func(ctx context.Context) (any, error) {
			return obj.Edges, nil
		},
		nil,
		ec.marshalOInvestmentLotEdge2beavermoneyappentInvestmentLotEdge,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_InvestmentLotConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLotConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_InvestmentLotEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_InvestmentLotEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvestmentLotEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLotConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLotConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLotConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNPageInfo2entgoiocontribentgqlPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLotConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLotConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLotConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLotConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLotConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLotConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLotConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLotEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLotEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLotEdge_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalOInvestmentLot2beavermoneyappentInvestmentLot,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_InvestmentLotEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLotEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InvestmentLot_id(ctx, field)
			case "createTime":
				return ec.fieldContext_InvestmentLot_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_InvestmentLot_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_InvestmentLot_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_InvestmentLot_amount(ctx, field)
			case "price":
				return ec.fieldContext_InvestmentLot_price(ctx, field)
			case "investmentID":
				return ec.fieldContext_InvestmentLot_investmentID(ctx, field)
			case "transactionID":
				return ec.fieldContext_InvestmentLot_transactionID(ctx, field)
			case "household":
				return ec.fieldContext_InvestmentLot_household(ctx, field)
			case "investment":
				return ec.fieldContext_InvestmentLot_investment(ctx, field)
			case "transaction":
				return ec.fieldContext_InvestmentLot_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvestmentLot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvestmentLotEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.InvestmentLotEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InvestmentLotEdge_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalNCursor2entgoiocontribentgqlCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InvestmentLotEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvestmentLotEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createAccount,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateAccount(ctx, fc.Args["input"].(ent.CreateAccountInput))
		},
		nil,
		ec.marshalNAccountEdge2beavermoneyappentAccountEdge,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_AccountEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_AccountEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccountEdge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createInvestment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createInvestment,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateInvestment(ctx, fc.Args["input"].(CreateInvestmentInputCustom))
		},
		nil,
		ec.marshalNInvestmentEdge2beavermoneyappentInvestmentEdge,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createInvestment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_InvestmentEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_InvestmentEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvestmentEdge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createInvestment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTransactionCategory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createTransactionCategory,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateTransactionCategory(ctx, fc.Args["input"].(ent.CreateTransactionCategoryInput))
		},
		nil,
		ec.marshalNTransactionCategoryEdge2beavermoneyappentTransactionCategoryEdge,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createTransactionCategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionCategoryEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionCategoryEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionCategoryEdge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTransactionCategory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createExpense(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createExpense,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateExpense(ctx, fc.Args["input"].(CreateExpenseInputCustom))
		},
		nil,
		ec.marshalNTransactionEdge2beavermoneyappentTransactionEdge,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createExpense(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEdge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createExpense_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createIncome(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createIncome,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateIncome(ctx, fc.Args["input"].(CreateIncomeInputCustom))
		},
		nil,
		ec.marshalNTransactionEdge2beavermoneyappentTransactionEdge,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createIncome(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEdge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createIncome_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTransfer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createTransfer,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateTransfer(ctx, fc.Args["input"].(CreateTransferInputCustom))
		},
		nil,
		ec.marshalNTransactionEdge2beavermoneyappentTransactionEdge,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createTransfer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEdge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTransfer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_buyInvestment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_buyInvestment,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BuyInvestment(ctx, fc.Args["input"].(BuyInvestmentInputCustom))
		},
		nil,
		ec.marshalNTransactionEdge2beavermoneyappentTransactionEdge,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_buyInvestment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEdge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_buyInvestment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sellInvestment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_sellInvestment,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SellInvestment(ctx, fc.Args["input"].(SellInvestmentInputCustom))
		},
		nil,
		ec.marshalNTransactionEdge2beavermoneyappentTransactionEdge,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_sellInvestment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEdge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sellInvestment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_moveInvestment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_moveInvestment,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().MoveInvestment(ctx, fc.Args["input"].(MoveInvestmentInputCustom))
		},
		nil,
		ec.marshalNTransactionEdge2beavermoneyappentTransactionEdge,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_moveInvestment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEdge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_moveInvestment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PageInfo_hasNextPage,
		func(ctx context.Context) (any, error) {
			return obj.HasNextPage, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PageInfo_hasPreviousPage,
		func(ctx context.Context) (any, error) {
			return obj.HasPreviousPage, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PageInfo_startCursor,
		func(ctx context.Context) (any, error) {
			return obj.StartCursor, nil
		},
		nil,
		ec.marshalOCursor2entgoiocontribentgqlCursor,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PageInfo_endCursor,
		func(ctx context.Context) (any, error) {
			return obj.EndCursor, nil
		},
		nil,
		ec.marshalOCursor2entgoiocontribentgqlCursor,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_node,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Node(ctx, fc.Args["id"].(int))
		},
		nil,
		ec.marshalONode2beavermoneyappentNoder,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_nodes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Nodes(ctx, fc.Args["ids"].([]int))
		},
		nil,
		ec.marshalNNode2beavermoneyappentNoder,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_accounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_accounts,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Accounts(ctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["where"].(*ent.AccountWhereInput))
		},
		nil,
		ec.marshalNAccountConnection2beavermoneyappentAccountConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_accounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_AccountConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_AccountConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_AccountConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccountConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_accounts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_currencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_currencies,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Currencies(ctx)
		},
		nil,
		ec.marshalNCurrency2beavermoneyappentCurrency,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_currencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "code":
				return ec.fieldContext_Currency_code(ctx, field)
			case "accounts":
				return ec.fieldContext_Currency_accounts(ctx, field)
			case "investments":
				return ec.fieldContext_Currency_investments(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Currency_transactionEntries(ctx, field)
			case "households":
				return ec.fieldContext_Currency_households(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_households(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_households,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Households(ctx)
		},
		nil,
		ec.marshalNHousehold2beavermoneyappentHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_households(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currencyID":
				return ec.fieldContext_Household_currencyID(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Household_investmentLots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_investments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_investments,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Investments(ctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["where"].(*ent.InvestmentWhereInput))
		},
		nil,
		ec.marshalNInvestmentConnection2beavermoneyappentInvestmentConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_investments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_InvestmentConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_InvestmentConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_InvestmentConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvestmentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_investments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_investmentLots(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_investmentLots,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().InvestmentLots(ctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["where"].(*ent.InvestmentLotWhereInput))
		},
		nil,
		ec.marshalNInvestmentLotConnection2beavermoneyappentInvestmentLotConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_investmentLots(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_InvestmentLotConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_InvestmentLotConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_InvestmentLotConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvestmentLotConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_investmentLots_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_transactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_transactions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Transactions(ctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.TransactionOrder), fc.Args["where"].(*ent.TransactionWhereInput))
		},
		nil,
		ec.marshalNTransactionConnection2beavermoneyappentTransactionConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TransactionConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TransactionConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TransactionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_transactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_transactionCategories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_transactionCategories,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().TransactionCategories(ctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["where"].(*ent.TransactionCategoryWhereInput))
		},
		nil,
		ec.marshalNTransactionCategoryConnection2beavermoneyappentTransactionCategoryConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_transactionCategories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TransactionCategoryConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TransactionCategoryConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TransactionCategoryConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionCategoryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_transactionCategories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_transactionEntries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_transactionEntries,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().TransactionEntries(ctx)
		},
		nil,
		ec.marshalNTransactionEntry2beavermoneyappentTransactionEntry,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_transactionEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionEntry_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionEntry_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionEntry_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionEntry_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_TransactionEntry_amount(ctx, field)
			case "accountID":
				return ec.fieldContext_TransactionEntry_accountID(ctx, field)
			case "currencyID":
				return ec.fieldContext_TransactionEntry_currencyID(ctx, field)
			case "transactionID":
				return ec.fieldContext_TransactionEntry_transactionID(ctx, field)
			case "household":
				return ec.fieldContext_TransactionEntry_household(ctx, field)
			case "account":
				return ec.fieldContext_TransactionEntry_account(ctx, field)
			case "currency":
				return ec.fieldContext_TransactionEntry_currency(ctx, field)
			case "transaction":
				return ec.fieldContext_TransactionEntry_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_userHouseholds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_userHouseholds,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().UserHouseholds(ctx)
		},
		nil,
		ec.marshalNUserHousehold2beavermoneyappentUserHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_userHouseholds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserHousehold_id(ctx, field)
			case "createTime":
				return ec.fieldContext_UserHousehold_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_UserHousehold_updateTime(ctx, field)
			case "userID":
				return ec.fieldContext_UserHousehold_userID(ctx, field)
			case "householdID":
				return ec.fieldContext_UserHousehold_householdID(ctx, field)
			case "role":
				return ec.fieldContext_UserHousehold_role(ctx, field)
			case "user":
				return ec.fieldContext_UserHousehold_user(ctx, field)
			case "household":
				return ec.fieldContext_UserHousehold_household(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserHousehold", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_fxRate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fxRate,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FxRate(ctx, fc.Args["from"].(string), fc.Args["to"].(string), fc.Args["datetime"].(time.Time))
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_fxRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fxRate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_stockQuote(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_stockQuote,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().StockQuote(ctx, fc.Args["symbol"].(string))
		},
		nil,
		ec.marshalOStockQuoteResult2beavermoneyappStockQuoteResult,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_stockQuote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "symbol":
				return ec.fieldContext_StockQuoteResult_symbol(ctx, field)
			case "name":
				return ec.fieldContext_StockQuoteResult_name(ctx, field)
			case "exchange":
				return ec.fieldContext_StockQuoteResult_exchange(ctx, field)
			case "currency":
				return ec.fieldContext_StockQuoteResult_currency(ctx, field)
			case "currentPrice":
				return ec.fieldContext_StockQuoteResult_currentPrice(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StockQuoteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_stockQuote_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_cryptoQuote(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_cryptoQuote,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().CryptoQuote(ctx, fc.Args["symbol"].(string))
		},
		nil,
		ec.marshalOCryptoQuoteResult2beavermoneyappCryptoQuoteResult,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_cryptoQuote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "symbol":
				return ec.fieldContext_CryptoQuoteResult_symbol(ctx, field)
			case "name":
				return ec.fieldContext_CryptoQuoteResult_name(ctx, field)
			case "exchange":
				return ec.fieldContext_CryptoQuoteResult_exchange(ctx, field)
			case "currency":
				return ec.fieldContext_CryptoQuoteResult_currency(ctx, field)
			case "currentPrice":
				return ec.fieldContext_CryptoQuoteResult_currentPrice(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CryptoQuoteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cryptoQuote_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_financialReport(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_financialReport,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FinancialReport(ctx, fc.Args["period"].(TimePeriodInput))
		},
		nil,
		ec.marshalNFinancialReport2beavermoneyappFinancialReport,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_financialReport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalIncome":
				return ec.fieldContext_FinancialReport_totalIncome(ctx, field)
			case "totalExpenses":
				return ec.fieldContext_FinancialReport_totalExpenses(ctx, field)
			case "incomeByCategoryType":
				return ec.fieldContext_FinancialReport_incomeByCategoryType(ctx, field)
			case "expensesByCategoryType":
				return ec.fieldContext_FinancialReport_expensesByCategoryType(ctx, field)
			case "transactionCount":
				return ec.fieldContext_FinancialReport_transactionCount(ctx, field)
			case "startDate":
				return ec.fieldContext_FinancialReport_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FinancialReport_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FinancialReport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_financialReport_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StockQuoteResult_symbol(ctx context.Context, field graphql.CollectedField, obj *StockQuoteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StockQuoteResult_symbol,
		func(ctx context.Context) (any, error) {
			return obj.Symbol, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StockQuoteResult_symbol(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StockQuoteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StockQuoteResult_name(ctx context.Context, field graphql.CollectedField, obj *StockQuoteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StockQuoteResult_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StockQuoteResult_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StockQuoteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StockQuoteResult_exchange(ctx context.Context, field graphql.CollectedField, obj *StockQuoteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StockQuoteResult_exchange,
		func(ctx context.Context) (any, error) {
			return obj.Exchange, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StockQuoteResult_exchange(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StockQuoteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StockQuoteResult_currency(ctx context.Context, field graphql.CollectedField, obj *StockQuoteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StockQuoteResult_currency,
		func(ctx context.Context) (any, error) {
			return obj.Currency, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StockQuoteResult_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StockQuoteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StockQuoteResult_currentPrice(ctx context.Context, field graphql.CollectedField, obj *StockQuoteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StockQuoteResult_currentPrice,
		func(ctx context.Context) (any, error) {
			return obj.CurrentPrice, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StockQuoteResult_currentPrice(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StockQuoteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_id(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_description(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Transaction_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_datetime(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_datetime,
		func(ctx context.Context) (any, error) {
			return obj.Datetime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_datetime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_userID(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_userID,
		func(ctx context.Context) (any, error) {
			return obj.UserID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_categoryID(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_categoryID,
		func(ctx context.Context) (any, error) {
			return obj.CategoryID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_categoryID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_user(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_user,
		func(ctx context.Context) (any, error) {
			return obj.User(ctx)
		},
		nil,
		ec.marshalNUser2beavermoneyappentUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "households":
				return ec.fieldContext_User_households(ctx, field)
			case "accounts":
				return ec.fieldContext_User_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_User_transactions(ctx, field)
			case "userKeys":
				return ec.fieldContext_User_userKeys(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_User_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_household(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2beavermoneyappentHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currencyID":
				return ec.fieldContext_Household_currencyID(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Household_investmentLots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_category(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_category,
		func(ctx context.Context) (any, error) {
			return obj.Category(ctx)
		},
		nil,
		ec.marshalNTransactionCategory2beavermoneyappentTransactionCategory,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionCategory_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionCategory_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionCategory_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionCategory_householdID(ctx, field)
			case "name":
				return ec.fieldContext_TransactionCategory_name(ctx, field)
			case "type":
				return ec.fieldContext_TransactionCategory_type(ctx, field)
			case "icon":
				return ec.fieldContext_TransactionCategory_icon(ctx, field)
			case "isImmutable":
				return ec.fieldContext_TransactionCategory_isImmutable(ctx, field)
			case "household":
				return ec.fieldContext_TransactionCategory_household(ctx, field)
			case "transactions":
				return ec.fieldContext_TransactionCategory_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_transactionEntries(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_transactionEntries,
		func(ctx context.Context) (any, error) {
			return obj.TransactionEntries(ctx)
		},
		nil,
		ec.marshalOTransactionEntry2beavermoneyappentTransactionEntry,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Transaction_transactionEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionEntry_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionEntry_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionEntry_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionEntry_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_TransactionEntry_amount(ctx, field)
			case "accountID":
				return ec.fieldContext_TransactionEntry_accountID(ctx, field)
			case "currencyID":
				return ec.fieldContext_TransactionEntry_currencyID(ctx, field)
			case "transactionID":
				return ec.fieldContext_TransactionEntry_transactionID(ctx, field)
			case "household":
				return ec.fieldContext_TransactionEntry_household(ctx, field)
			case "account":
				return ec.fieldContext_TransactionEntry_account(ctx, field)
			case "currency":
				return ec.fieldContext_TransactionEntry_currency(ctx, field)
			case "transaction":
				return ec.fieldContext_TransactionEntry_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_investmentLots(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_investmentLots,
		func(ctx context.Context) (any, error) {
			return obj.InvestmentLots(ctx)
		},
		nil,
		ec.marshalOInvestmentLot2beavermoneyappentInvestmentLot,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Transaction_investmentLots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InvestmentLot_id(ctx, field)
			case "createTime":
				return ec.fieldContext_InvestmentLot_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_InvestmentLot_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_InvestmentLot_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_InvestmentLot_amount(ctx, field)
			case "price":
				return ec.fieldContext_InvestmentLot_price(ctx, field)
			case "investmentID":
				return ec.fieldContext_InvestmentLot_investmentID(ctx, field)
			case "transactionID":
				return ec.fieldContext_InvestmentLot_transactionID(ctx, field)
			case "household":
				return ec.fieldContext_InvestmentLot_household(ctx, field)
			case "investment":
				return ec.fieldContext_InvestmentLot_investment(ctx, field)
			case "transaction":
				return ec.fieldContext_InvestmentLot_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvestmentLot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_id(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_name(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_type(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNTransactionCategoryType2beavermoneyappenttransactioncategoryType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TransactionCategoryType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_icon(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_icon,
		func(ctx context.Context) (any, error) {
			return obj.Icon, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_icon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_isImmutable(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_isImmutable,
		func(ctx context.Context) (any, error) {
			return obj.IsImmutable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_isImmutable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_household(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2beavermoneyappentHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currencyID":
				return ec.fieldContext_Household_currencyID(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Household_investmentLots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_transactions(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_transactions,
		func(ctx context.Context) (any, error) {
			return obj.Transactions(ctx)
		},
		nil,
		ec.marshalOTransaction2beavermoneyappentTransaction,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_transactions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "userID":
				return ec.fieldContext_Transaction_userID(ctx, field)
			case "categoryID":
				return ec.fieldContext_Transaction_categoryID(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Transaction_investmentLots(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategoryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategoryConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategoryConnection_edges,
		func(ctx context.Context) (any, error) {
			return obj.Edges, nil
		},
		nil,
		ec.marshalOTransactionCategoryEdge2beavermoneyappentTransactionCategoryEdge,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionCategoryConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionCategoryEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionCategoryEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionCategoryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategoryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategoryConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategoryConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNPageInfo2entgoiocontribentgqlPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategoryConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategoryConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategoryConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategoryConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategoryConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategoryEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategoryEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategoryEdge_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalOTransactionCategory2beavermoneyappentTransactionCategory,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionCategoryEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionCategory_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionCategory_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionCategory_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionCategory_householdID(ctx, field)
			case "name":
				return ec.fieldContext_TransactionCategory_name(ctx, field)
			case "type":
				return ec.fieldContext_TransactionCategory_type(ctx, field)
			case "icon":
				return ec.fieldContext_TransactionCategory_icon(ctx, field)
			case "isImmutable":
				return ec.fieldContext_TransactionCategory_isImmutable(ctx, field)
			case "household":
				return ec.fieldContext_TransactionCategory_household(ctx, field)
			case "transactions":
				return ec.fieldContext_TransactionCategory_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategoryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategoryEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategoryEdge_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalNCursor2entgoiocontribentgqlCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategoryEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionConnection_edges,
		func(ctx context.Context) (any, error) {
			return obj.Edges, nil
		},
		nil,
		ec.marshalOTransactionEdge2beavermoneyappentTransactionEdge,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNPageInfo2entgoiocontribentgqlPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEdge_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalOTransaction2beavermoneyappentTransaction,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "userID":
				return ec.fieldContext_Transaction_userID(ctx, field)
			case "categoryID":
				return ec.fieldContext_Transaction_categoryID(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Transaction_investmentLots(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEdge_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalNCursor2entgoiocontribentgqlCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_id(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_amount(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_amount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionEntry().Amount(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_accountID(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_accountID,
		func(ctx context.Context) (any, error) {
			return obj.AccountID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_accountID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_currencyID(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_currencyID,
		func(ctx context.Context) (any, error) {
			return obj.CurrencyID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_currencyID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_transactionID(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_transactionID,
		func(ctx context.Context) (any, error) {
			return obj.TransactionID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_transactionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_household(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2beavermoneyappentHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currencyID":
				return ec.fieldContext_Household_currencyID(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Household_investmentLots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_account(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_account,
		func(ctx context.Context) (any, error) {
			return obj.Account(ctx)
		},
		nil,
		ec.marshalNAccount2beavermoneyappentAccount,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "icon":
				return ec.fieldContext_Account_icon(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "currencyID":
				return ec.fieldContext_Account_currencyID(ctx, field)
			case "userID":
				return ec.fieldContext_Account_userID(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_currency(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_currency,
		func(ctx context.Context) (any, error) {
			return obj.Currency(ctx)
		},
		nil,
		ec.marshalNCurrency2beavermoneyappentCurrency,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "code":
				return ec.fieldContext_Currency_code(ctx, field)
			case "accounts":
				return ec.fieldContext_Currency_accounts(ctx, field)
			case "investments":
				return ec.fieldContext_Currency_investments(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Currency_transactionEntries(ctx, field)
			case "households":
				return ec.fieldContext_Currency_households(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_transaction(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_transaction,
		func(ctx context.Context) (any, error) {
			return obj.Transaction(ctx)
		},
		nil,
		ec.marshalNTransaction2beavermoneyappentTransaction,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_transaction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "userID":
				return ec.fieldContext_Transaction_userID(ctx, field)
			case "categoryID":
				return ec.fieldContext_Transaction_categoryID(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Transaction_investmentLots(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_email,
		func(ctx context.Context) (any, error) {
			return obj.Email, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_households(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_households,
		func(ctx context.Context) (any, error) {
			return obj.Households(ctx)
		},
		nil,
		ec.marshalOHousehold2beavermoneyappentHousehold,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_households(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currencyID":
				return ec.fieldContext_Household_currencyID(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Household_investmentLots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_accounts(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_accounts,
		func(ctx context.Context) (any, error) {
			return obj.Accounts(ctx)
		},
		nil,
		ec.marshalOAccount2beavermoneyappentAccount,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_accounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "icon":
				return ec.fieldContext_Account_icon(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "currencyID":
				return ec.fieldContext_Account_currencyID(ctx, field)
			case "userID":
				return ec.fieldContext_Account_userID(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_transactions(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_transactions,
		func(ctx context.Context) (any, error) {
			return obj.Transactions(ctx)
		},
		nil,
		ec.marshalOTransaction2beavermoneyappentTransaction,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_transactions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "userID":
				return ec.fieldContext_Transaction_userID(ctx, field)
			case "categoryID":
				return ec.fieldContext_Transaction_categoryID(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Transaction_investmentLots(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userKeys(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_userKeys,
		func(ctx context.Context) (any, error) {
			return obj.UserKeys(ctx)
		},
		nil,
		ec.marshalOUserKey2beavermoneyappentUserKey,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_userKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserKey_id(ctx, field)
			case "createTime":
				return ec.fieldContext_UserKey_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_UserKey_updateTime(ctx, field)
			case "provider":
				return ec.fieldContext_UserKey_provider(ctx, field)
			case "key":
				return ec.fieldContext_UserKey_key(ctx, field)
			case "userID":
				return ec.fieldContext_UserKey_userID(ctx, field)
			case "user":
				return ec.fieldContext_UserKey_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userHouseholds(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_userHouseholds,
		func(ctx context.Context) (any, error) {
			return obj.UserHouseholds(ctx)
		},
		nil,
		ec.marshalOUserHousehold2beavermoneyappentUserHousehold,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_userHouseholds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserHousehold_id(ctx, field)
			case "createTime":
				return ec.fieldContext_UserHousehold_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_UserHousehold_updateTime(ctx, field)
			case "userID":
				return ec.fieldContext_UserHousehold_userID(ctx, field)
			case "householdID":
				return ec.fieldContext_UserHousehold_householdID(ctx, field)
			case "role":
				return ec.fieldContext_UserHousehold_role(ctx, field)
			case "user":
				return ec.fieldContext_UserHousehold_user(ctx, field)
			case "household":
				return ec.fieldContext_UserHousehold_household(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserHousehold", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_id(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_userID(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_userID,
		func(ctx context.Context) (any, error) {
			return obj.UserID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_role(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_role,
		func(ctx context.Context) (any, error) {
			return obj.Role, nil
		},
		nil,
		ec.marshalNUserHouseholdRole2beavermoneyappentuserhouseholdRole,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserHouseholdRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_user(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_user,
		func(ctx context.Context) (any, error) {
			return obj.User(ctx)
		},
		nil,
		ec.marshalNUser2beavermoneyappentUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "households":
				return ec.fieldContext_User_households(ctx, field)
			case "accounts":
				return ec.fieldContext_User_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_User_transactions(ctx, field)
			case "userKeys":
				return ec.fieldContext_User_userKeys(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_User_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_household(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2beavermoneyappentHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currencyID":
				return ec.fieldContext_Household_currencyID(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "investmentLots":
				return ec.fieldContext_Household_investmentLots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_id(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_provider(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_provider,
		func(ctx context.Context) (any, error) {
			return obj.Provider, nil
		},
		nil,
		ec.marshalNUserKeyProvider2beavermoneyappentuserkeyProvider,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserKeyProvider does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_key(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_userID(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_userID,
		func(ctx context.Context) (any, error) {
			return obj.UserID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_user(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_user,
		func(ctx context.Context) (any, error) {
			return obj.User(ctx)
		},
		nil,
		ec.marshalNUser2beavermoneyappentUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "households":
				return ec.fieldContext_User_households(ctx, field)
			case "accounts":
				return ec.fieldContext_User_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_User_transactions(ctx, field)
			case "userKeys":
				return ec.fieldContext_User_userKeys(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_User_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAccountWhereInput(ctx context.Context, obj any) (ent.AccountWhereInput, error) {
	var it ent.AccountWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "balance", "balanceNEQ", "balanceIn", "balanceNotIn", "balanceGT", "balanceGTE", "balanceLT", "balanceLTE", "icon", "iconNEQ", "iconIn", "iconNotIn", "iconGT", "iconGTE", "iconLT", "iconLTE", "iconContains", "iconHasPrefix", "iconHasSuffix", "iconIsNil", "iconNotNil", "iconEqualFold", "iconContainsFold", "value", "valueNEQ", "valueIn", "valueNotIn", "valueGT", "valueGTE", "valueLT", "valueLTE", "fxRate", "fxRateNEQ", "fxRateIn", "fxRateNotIn", "fxRateGT", "fxRateGTE", "fxRateLT", "fxRateLTE", "currencyID", "currencyIDNEQ", "currencyIDIn", "currencyIDNotIn", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "hasHousehold", "hasHouseholdWith", "hasCurrency", "hasCurrencyWith", "hasUser", "hasUserWith", "hasTransactionEntries", "hasTransactionEntriesWith", "hasInvestments", "hasInvestmentsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOAccountType2beavermoneyappentaccountType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOAccountType2beavermoneyappentaccountType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOAccountType2beavermoneyappentaccountType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOAccountType2beavermoneyappentaccountType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "balance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balance"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().Balance(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "iconNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconNEQ = data
		case "iconIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconIn = data
		case "iconNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconNotIn = data
		case "iconGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconGT = data
		case "iconGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconGTE = data
		case "iconLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconLT = data
		case "iconLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconLTE = data
		case "iconContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconContains = data
		case "iconHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconHasPrefix = data
		case "iconHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconHasSuffix = data
		case "iconIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconIsNil = data
		case "iconNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconNotNil = data
		case "iconEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconEqualFold = data
		case "iconContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconContainsFold = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().Value(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRate(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "currencyID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyID = data
		case "currencyIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDNEQ = data
		case "currencyIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDIn = data
		case "currencyIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDNotIn = data
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "userIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNEQ = data
		case "userIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDIn = data
		case "userIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNotIn = data
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasCurrency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrency"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrency = data
		case "hasCurrencyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyWith"))
			data, err := ec.unmarshalOCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrencyWith = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2beavermoneyappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		case "hasTransactionEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntries"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntries = data
		case "hasTransactionEntriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntriesWith"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntriesWith = data
		case "hasInvestments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestments"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestments = data
		case "hasInvestmentsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentsWith"))
			data, err := ec.unmarshalOInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuyInvestmentInputCustom(ctx context.Context, obj any) (BuyInvestmentInputCustom, error) {
	var it BuyInvestmentInputCustom
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["fees"]; !present {
		asMap["fees"] = []any{}
	}

	fieldsInOrder := [...]string{"transaction", "transactionEntry", "investmentLot", "fees"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "transaction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transaction"))
			data, err := ec.unmarshalNCreateTransactionInput2beavermoneyappentCreateTransactionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Transaction = data
		case "transactionEntry":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionEntry"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionEntry = data
		case "investmentLot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("investmentLot"))
			data, err := ec.unmarshalNCreateInvestmentLotInput2beavermoneyappentCreateInvestmentLotInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.InvestmentLot = data
		case "fees":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fees"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fees = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateAccountInput(ctx context.Context, obj any) (ent.CreateAccountInput, error) {
	var it ent.CreateAccountInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "type", "balance", "icon", "currencyID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNAccountType2beavermoneyappentaccountType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "balance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balance"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CreateAccountInput().Balance(ctx, &it, data); err != nil {
				return it, err
			}
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "currencyID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateExpenseInputCustom(ctx context.Context, obj any) (CreateExpenseInputCustom, error) {
	var it CreateExpenseInputCustom
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["fees"]; !present {
		asMap["fees"] = []any{}
	}

	fieldsInOrder := [...]string{"transaction", "transactionEntry", "fees"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "transaction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transaction"))
			data, err := ec.unmarshalNCreateTransactionInput2beavermoneyappentCreateTransactionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Transaction = data
		case "transactionEntry":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionEntry"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionEntry = data
		case "fees":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fees"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fees = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateIncomeInputCustom(ctx context.Context, obj any) (CreateIncomeInputCustom, error) {
	var it CreateIncomeInputCustom
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["fees"]; !present {
		asMap["fees"] = []any{}
	}

	fieldsInOrder := [...]string{"transaction", "transactionEntry", "fees"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "transaction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transaction"))
			data, err := ec.unmarshalNCreateTransactionInput2beavermoneyappentCreateTransactionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Transaction = data
		case "transactionEntry":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionEntry"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionEntry = data
		case "fees":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fees"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fees = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateInvestmentInput(ctx context.Context, obj any) (ent.CreateInvestmentInput, error) {
	var it ent.CreateInvestmentInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "type", "symbol", "amount", "accountID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNInvestmentType2beavermoneyappentinvestmentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "symbol":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbol"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Symbol = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CreateInvestmentInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		case "accountID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateInvestmentInputCustom(ctx context.Context, obj any) (CreateInvestmentInputCustom, error) {
	var it CreateInvestmentInputCustom
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"input", "costBasis"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "input":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
			data, err := ec.unmarshalNCreateInvestmentInput2beavermoneyappentCreateInvestmentInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Input = data
		case "costBasis":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costBasis"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CostBasis = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateInvestmentLotInput(ctx context.Context, obj any) (ent.CreateInvestmentLotInput, error) {
	var it ent.CreateInvestmentLotInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"amount", "price", "investmentID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CreateInvestmentLotInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		case "price":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("price"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CreateInvestmentLotInput().Price(ctx, &it, data); err != nil {
				return it, err
			}
		case "investmentID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("investmentID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.InvestmentID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTransactionCategoryInput(ctx context.Context, obj any) (ent.CreateTransactionCategoryInput, error) {
	var it ent.CreateTransactionCategoryInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "type", "icon", "isImmutable"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "isImmutable":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isImmutable"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsImmutable = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTransactionEntryInput(ctx context.Context, obj any) (ent.CreateTransactionEntryInput, error) {
	var it ent.CreateTransactionEntryInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"amount", "accountID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CreateTransactionEntryInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		case "accountID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTransactionInput(ctx context.Context, obj any) (ent.CreateTransactionInput, error) {
	var it ent.CreateTransactionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "datetime", "categoryID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "datetime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetime"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Datetime = data
		case "categoryID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CategoryID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTransferInputCustom(ctx context.Context, obj any) (CreateTransferInputCustom, error) {
	var it CreateTransferInputCustom
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["fees"]; !present {
		asMap["fees"] = []any{}
	}

	fieldsInOrder := [...]string{"transaction", "transactionEntries", "fees"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "transaction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transaction"))
			data, err := ec.unmarshalNCreateTransactionInput2beavermoneyappentCreateTransactionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Transaction = data
		case "transactionEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionEntries"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionEntries = data
		case "fees":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fees"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fees = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCurrencyWhereInput(ctx context.Context, obj any) (ent.CurrencyWhereInput, error) {
	var it ent.CurrencyWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "code", "codeNEQ", "codeIn", "codeNotIn", "codeGT", "codeGTE", "codeLT", "codeLTE", "codeContains", "codeHasPrefix", "codeHasSuffix", "codeEqualFold", "codeContainsFold", "hasAccounts", "hasAccountsWith", "hasInvestments", "hasInvestmentsWith", "hasTransactionEntries", "hasTransactionEntriesWith", "hasHouseholds", "hasHouseholdsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Code = data
		case "codeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeNEQ = data
		case "codeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeIn = data
		case "codeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeNotIn = data
		case "codeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeGT = data
		case "codeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeGTE = data
		case "codeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeLT = data
		case "codeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeLTE = data
		case "codeContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeContains = data
		case "codeHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeHasPrefix = data
		case "codeHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeHasSuffix = data
		case "codeEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeEqualFold = data
		case "codeContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeContainsFold = data
		case "hasAccounts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccounts"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccounts = data
		case "hasAccountsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountsWith"))
			data, err := ec.unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccountsWith = data
		case "hasInvestments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestments"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestments = data
		case "hasInvestmentsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentsWith"))
			data, err := ec.unmarshalOInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentsWith = data
		case "hasTransactionEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntries"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntries = data
		case "hasTransactionEntriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntriesWith"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntriesWith = data
		case "hasHouseholds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholds"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholds = data
		case "hasHouseholdsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdsWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHouseholdWhereInput(ctx context.Context, obj any) (ent.HouseholdWhereInput, error) {
	var it ent.HouseholdWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "locale", "localeNEQ", "localeIn", "localeNotIn", "localeGT", "localeGTE", "localeLT", "localeLTE", "localeContains", "localeHasPrefix", "localeHasSuffix", "localeEqualFold", "localeContainsFold", "currencyID", "currencyIDNEQ", "currencyIDIn", "currencyIDNotIn", "hasCurrency", "hasCurrencyWith", "hasUsers", "hasUsersWith", "hasAccounts", "hasAccountsWith", "hasTransactions", "hasTransactionsWith", "hasInvestments", "hasInvestmentsWith", "hasInvestmentLots", "hasInvestmentLotsWith", "hasTransactionCategories", "hasTransactionCategoriesWith", "hasTransactionEntries", "hasTransactionEntriesWith", "hasUserHouseholds", "hasUserHouseholdsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "locale":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locale"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locale = data
		case "localeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleNEQ = data
		case "localeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleIn = data
		case "localeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleNotIn = data
		case "localeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleGT = data
		case "localeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleGTE = data
		case "localeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleLT = data
		case "localeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleLTE = data
		case "localeContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleContains = data
		case "localeHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleHasPrefix = data
		case "localeHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleHasSuffix = data
		case "localeEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleEqualFold = data
		case "localeContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleContainsFold = data
		case "currencyID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyID = data
		case "currencyIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDNEQ = data
		case "currencyIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDIn = data
		case "currencyIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDNotIn = data
		case "hasCurrency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrency"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrency = data
		case "hasCurrencyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyWith"))
			data, err := ec.unmarshalOCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrencyWith = data
		case "hasUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsers"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsers = data
		case "hasUsersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsersWith"))
			data, err := ec.unmarshalOUserWhereInput2beavermoneyappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsersWith = data
		case "hasAccounts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccounts"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccounts = data
		case "hasAccountsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountsWith"))
			data, err := ec.unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccountsWith = data
		case "hasTransactions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactions = data
		case "hasTransactionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionsWith"))
			data, err := ec.unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionsWith = data
		case "hasInvestments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestments"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestments = data
		case "hasInvestmentsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentsWith"))
			data, err := ec.unmarshalOInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentsWith = data
		case "hasInvestmentLots":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentLots"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentLots = data
		case "hasInvestmentLotsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentLotsWith"))
			data, err := ec.unmarshalOInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentLotsWith = data
		case "hasTransactionCategories":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionCategories"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionCategories = data
		case "hasTransactionCategoriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionCategoriesWith"))
			data, err := ec.unmarshalOTransactionCategoryWhereInput2beavermoneyappentTransactionCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionCategoriesWith = data
		case "hasTransactionEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntries"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntries = data
		case "hasTransactionEntriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntriesWith"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntriesWith = data
		case "hasUserHouseholds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserHouseholds"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserHouseholds = data
		case "hasUserHouseholdsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserHouseholdsWith"))
			data, err := ec.unmarshalOUserHouseholdWhereInput2beavermoneyappentUserHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserHouseholdsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInvestmentLotWhereInput(ctx context.Context, obj any) (ent.InvestmentLotWhereInput, error) {
	var it ent.InvestmentLotWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "amount", "amountNEQ", "amountIn", "amountNotIn", "amountGT", "amountGTE", "amountLT", "amountLTE", "price", "priceNEQ", "priceIn", "priceNotIn", "priceGT", "priceGTE", "priceLT", "priceLTE", "investmentID", "investmentIDNEQ", "investmentIDIn", "investmentIDNotIn", "transactionID", "transactionIDNEQ", "transactionIDIn", "transactionIDNotIn", "hasHousehold", "hasHouseholdWith", "hasInvestment", "hasInvestmentWith", "hasTransaction", "hasTransactionWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().AmountNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().AmountIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().AmountNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().AmountGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().AmountGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().AmountLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().AmountLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "price":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("price"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().Price(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().PriceNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().PriceIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().PriceNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().PriceGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().PriceGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().PriceLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentLotWhereInput().PriceLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "investmentID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("investmentID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.InvestmentID = data
		case "investmentIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("investmentIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.InvestmentIDNEQ = data
		case "investmentIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("investmentIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.InvestmentIDIn = data
		case "investmentIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("investmentIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.InvestmentIDNotIn = data
		case "transactionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionID = data
		case "transactionIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionIDNEQ = data
		case "transactionIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionIDIn = data
		case "transactionIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionIDNotIn = data
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasInvestment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestment = data
		case "hasInvestmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentWith"))
			data, err := ec.unmarshalOInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentWith = data
		case "hasTransaction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransaction"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransaction = data
		case "hasTransactionWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionWith"))
			data, err := ec.unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInvestmentWhereInput(ctx context.Context, obj any) (ent.InvestmentWhereInput, error) {
	var it ent.InvestmentWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "symbol", "symbolNEQ", "symbolIn", "symbolNotIn", "symbolGT", "symbolGTE", "symbolLT", "symbolLTE", "symbolContains", "symbolHasPrefix", "symbolHasSuffix", "symbolEqualFold", "symbolContainsFold", "amount", "amountNEQ", "amountIn", "amountNotIn", "amountGT", "amountGTE", "amountLT", "amountLTE", "quote", "quoteNEQ", "quoteIn", "quoteNotIn", "quoteGT", "quoteGTE", "quoteLT", "quoteLTE", "value", "valueNEQ", "valueIn", "valueNotIn", "valueGT", "valueGTE", "valueLT", "valueLTE", "accountID", "accountIDNEQ", "accountIDIn", "accountIDNotIn", "currencyID", "currencyIDNEQ", "currencyIDIn", "currencyIDNotIn", "hasAccount", "hasAccountWith", "hasHousehold", "hasHouseholdWith", "hasCurrency", "hasCurrencyWith", "hasInvestmentLots", "hasInvestmentLotsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOInvestmentType2beavermoneyappentinvestmentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOInvestmentType2beavermoneyappentinvestmentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOInvestmentType2beavermoneyappentinvestmentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOInvestmentType2beavermoneyappentinvestmentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "symbol":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbol"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Symbol = data
		case "symbolNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolNEQ = data
		case "symbolIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolIn = data
		case "symbolNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolNotIn = data
		case "symbolGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolGT = data
		case "symbolGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolGTE = data
		case "symbolLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolLT = data
		case "symbolLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolLTE = data
		case "symbolContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolContains = data
		case "symbolHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolHasPrefix = data
		case "symbolHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolHasSuffix = data
		case "symbolEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolEqualFold = data
		case "symbolContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolContainsFold = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "quote":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quote"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().Quote(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().Value(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "accountID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountID = data
		case "accountIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountIDNEQ = data
		case "accountIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountIDIn = data
		case "accountIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountIDNotIn = data
		case "currencyID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyID = data
		case "currencyIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDNEQ = data
		case "currencyIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDIn = data
		case "currencyIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDNotIn = data
		case "hasAccount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccount"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccount = data
		case "hasAccountWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountWith"))
			data, err := ec.unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccountWith = data
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasCurrency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrency"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrency = data
		case "hasCurrencyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyWith"))
			data, err := ec.unmarshalOCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrencyWith = data
		case "hasInvestmentLots":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentLots"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentLots = data
		case "hasInvestmentLotsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentLotsWith"))
			data, err := ec.unmarshalOInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentLotsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMoveInvestmentInputCustom(ctx context.Context, obj any) (MoveInvestmentInputCustom, error) {
	var it MoveInvestmentInputCustom
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["fees"]; !present {
		asMap["fees"] = []any{}
	}

	fieldsInOrder := [...]string{"transaction", "investmentLots", "fees"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "transaction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transaction"))
			data, err := ec.unmarshalNCreateTransactionInput2beavermoneyappentCreateTransactionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Transaction = data
		case "investmentLots":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("investmentLots"))
			data, err := ec.unmarshalNCreateInvestmentLotInput2beavermoneyappentCreateInvestmentLotInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.InvestmentLots = data
		case "fees":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fees"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fees = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSellInvestmentInputCustom(ctx context.Context, obj any) (SellInvestmentInputCustom, error) {
	var it SellInvestmentInputCustom
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["fees"]; !present {
		asMap["fees"] = []any{}
	}

	fieldsInOrder := [...]string{"transaction", "transactionEntry", "investmentLot", "fees"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "transaction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transaction"))
			data, err := ec.unmarshalNCreateTransactionInput2beavermoneyappentCreateTransactionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Transaction = data
		case "transactionEntry":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionEntry"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionEntry = data
		case "investmentLot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("investmentLot"))
			data, err := ec.unmarshalNCreateInvestmentLotInput2beavermoneyappentCreateInvestmentLotInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.InvestmentLot = data
		case "fees":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fees"))
			data, err := ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fees = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTimePeriodInput(ctx context.Context, obj any) (TimePeriodInput, error) {
	var it TimePeriodInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"startDate", "endDate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "startDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "endDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndDate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionCategoryWhereInput(ctx context.Context, obj any) (ent.TransactionCategoryWhereInput, error) {
	var it ent.TransactionCategoryWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "icon", "iconNEQ", "iconIn", "iconNotIn", "iconGT", "iconGTE", "iconLT", "iconLTE", "iconContains", "iconHasPrefix", "iconHasSuffix", "iconEqualFold", "iconContainsFold", "isImmutable", "isImmutableNEQ", "hasHousehold", "hasHouseholdWith", "hasTransactions", "hasTransactionsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOTransactionCategoryWhereInput2beavermoneyappentTransactionCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOTransactionCategoryWhereInput2beavermoneyappentTransactionCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOTransactionCategoryWhereInput2beavermoneyappentTransactionCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "iconNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconNEQ = data
		case "iconIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconIn = data
		case "iconNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconNotIn = data
		case "iconGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconGT = data
		case "iconGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconGTE = data
		case "iconLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconLT = data
		case "iconLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconLTE = data
		case "iconContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconContains = data
		case "iconHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconHasPrefix = data
		case "iconHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconHasSuffix = data
		case "iconEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconEqualFold = data
		case "iconContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconContainsFold = data
		case "isImmutable":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isImmutable"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsImmutable = data
		case "isImmutableNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isImmutableNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsImmutableNEQ = data
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasTransactions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactions = data
		case "hasTransactionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionsWith"))
			data, err := ec.unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionEntryWhereInput(ctx context.Context, obj any) (ent.TransactionEntryWhereInput, error) {
	var it ent.TransactionEntryWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "amount", "amountNEQ", "amountIn", "amountNotIn", "amountGT", "amountGTE", "amountLT", "amountLTE", "accountID", "accountIDNEQ", "accountIDIn", "accountIDNotIn", "currencyID", "currencyIDNEQ", "currencyIDIn", "currencyIDNotIn", "transactionID", "transactionIDNEQ", "transactionIDIn", "transactionIDNotIn", "hasHousehold", "hasHouseholdWith", "hasAccount", "hasAccountWith", "hasCurrency", "hasCurrencyWith", "hasTransaction", "hasTransactionWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "accountID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountID = data
		case "accountIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountIDNEQ = data
		case "accountIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountIDIn = data
		case "accountIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountIDNotIn = data
		case "currencyID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyID = data
		case "currencyIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDNEQ = data
		case "currencyIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDIn = data
		case "currencyIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrencyIDNotIn = data
		case "transactionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionID = data
		case "transactionIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionIDNEQ = data
		case "transactionIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionIDIn = data
		case "transactionIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TransactionIDNotIn = data
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasAccount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccount"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccount = data
		case "hasAccountWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountWith"))
			data, err := ec.unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccountWith = data
		case "hasCurrency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrency"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrency = data
		case "hasCurrencyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyWith"))
			data, err := ec.unmarshalOCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrencyWith = data
		case "hasTransaction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransaction"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransaction = data
		case "hasTransactionWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionWith"))
			data, err := ec.unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionOrder(ctx context.Context, obj any) (ent.TransactionOrder, error) {
	var it ent.TransactionOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNTransactionOrderField2beavermoneyappentTransactionOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionWhereInput(ctx context.Context, obj any) (ent.TransactionWhereInput, error) {
	var it ent.TransactionWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionIsNil", "descriptionNotNil", "descriptionEqualFold", "descriptionContainsFold", "datetime", "datetimeNEQ", "datetimeIn", "datetimeNotIn", "datetimeGT", "datetimeGTE", "datetimeLT", "datetimeLTE", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "categoryID", "categoryIDNEQ", "categoryIDIn", "categoryIDNotIn", "hasUser", "hasUserWith", "hasHousehold", "hasHouseholdWith", "hasCategory", "hasCategoryWith", "hasTransactionEntries", "hasTransactionEntriesWith", "hasInvestmentLots", "hasInvestmentLotsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "descriptionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNEQ = data
		case "descriptionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIn = data
		case "descriptionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotIn = data
		case "descriptionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGT = data
		case "descriptionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGTE = data
		case "descriptionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLT = data
		case "descriptionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLTE = data
		case "descriptionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContains = data
		case "descriptionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasPrefix = data
		case "descriptionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasSuffix = data
		case "descriptionIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIsNil = data
		case "descriptionNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotNil = data
		case "descriptionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionEqualFold = data
		case "descriptionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContainsFold = data
		case "datetime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Datetime = data
		case "datetimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeNEQ = data
		case "datetimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeIn = data
		case "datetimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeNotIn = data
		case "datetimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeGT = data
		case "datetimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeGTE = data
		case "datetimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeLT = data
		case "datetimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeLTE = data
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "userIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNEQ = data
		case "userIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDIn = data
		case "userIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNotIn = data
		case "categoryID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CategoryID = data
		case "categoryIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CategoryIDNEQ = data
		case "categoryIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CategoryIDIn = data
		case "categoryIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CategoryIDNotIn = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2beavermoneyappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasCategory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCategory"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCategory = data
		case "hasCategoryWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCategoryWith"))
			data, err := ec.unmarshalOTransactionCategoryWhereInput2beavermoneyappentTransactionCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCategoryWith = data
		case "hasTransactionEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntries"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntries = data
		case "hasTransactionEntriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntriesWith"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntriesWith = data
		case "hasInvestmentLots":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentLots"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentLots = data
		case "hasInvestmentLotsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentLotsWith"))
			data, err := ec.unmarshalOInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentLotsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAccountInput(ctx context.Context, obj any) (ent.UpdateAccountInput, error) {
	var it ent.UpdateAccountInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "icon", "clearIcon"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "clearIcon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearIcon"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearIcon = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateInvestmentInput(ctx context.Context, obj any) (ent.UpdateInvestmentInput, error) {
	var it ent.UpdateInvestmentInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "type", "symbol", "amount"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOInvestmentType2beavermoneyappentinvestmentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "symbol":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbol"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Symbol = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UpdateInvestmentInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateInvestmentLotInput(ctx context.Context, obj any) (ent.UpdateInvestmentLotInput, error) {
	var it ent.UpdateInvestmentLotInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"amount", "price"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UpdateInvestmentLotInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		case "price":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("price"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UpdateInvestmentLotInput().Price(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserHouseholdWhereInput(ctx context.Context, obj any) (ent.UserHouseholdWhereInput, error) {
	var it ent.UserHouseholdWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "role", "roleNEQ", "roleIn", "roleNotIn"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserHouseholdWhereInput2beavermoneyappentUserHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserHouseholdWhereInput2beavermoneyappentUserHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserHouseholdWhereInput2beavermoneyappentUserHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "roleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleNEQ"))
			data, err := ec.unmarshalOUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleNEQ = data
		case "roleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleIn"))
			data, err := ec.unmarshalOUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleIn = data
		case "roleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleNotIn"))
			data, err := ec.unmarshalOUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleNotIn = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserKeyWhereInput(ctx context.Context, obj any) (ent.UserKeyWhereInput, error) {
	var it ent.UserKeyWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "provider", "providerNEQ", "providerIn", "providerNotIn", "key", "keyNEQ", "keyIn", "keyNotIn", "keyGT", "keyGTE", "keyLT", "keyLTE", "keyContains", "keyHasPrefix", "keyHasSuffix", "keyEqualFold", "keyContainsFold", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "hasUser", "hasUserWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserKeyWhereInput2beavermoneyappentUserKeyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserKeyWhereInput2beavermoneyappentUserKeyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserKeyWhereInput2beavermoneyappentUserKeyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "provider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalOUserKeyProvider2beavermoneyappentuserkeyProvider(ctx, v)
			if err != nil {
				return it, err
			}
			it.Provider = data
		case "providerNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerNEQ"))
			data, err := ec.unmarshalOUserKeyProvider2beavermoneyappentuserkeyProvider(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderNEQ = data
		case "providerIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerIn"))
			data, err := ec.unmarshalOUserKeyProvider2beavermoneyappentuserkeyProvider(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderIn = data
		case "providerNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerNotIn"))
			data, err := ec.unmarshalOUserKeyProvider2beavermoneyappentuserkeyProvider(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderNotIn = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "keyNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyNEQ = data
		case "keyIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyIn = data
		case "keyNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyNotIn = data
		case "keyGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyGT = data
		case "keyGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyGTE = data
		case "keyLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyLT = data
		case "keyLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyLTE = data
		case "keyContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyContains = data
		case "keyHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyHasPrefix = data
		case "keyHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyHasSuffix = data
		case "keyEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyEqualFold = data
		case "keyContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyContainsFold = data
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "userIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNEQ = data
		case "userIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDIn = data
		case "userIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNotIn = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2beavermoneyappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereInput(ctx context.Context, obj any) (ent.UserWhereInput, error) {
	var it ent.UserWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "email", "emailNEQ", "emailIn", "emailNotIn", "emailGT", "emailGTE", "emailLT", "emailLTE", "emailContains", "emailHasPrefix", "emailHasSuffix", "emailEqualFold", "emailContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasHouseholds", "hasHouseholdsWith", "hasAccounts", "hasAccountsWith", "hasTransactions", "hasTransactionsWith", "hasUserKeys", "hasUserKeysWith", "hasUserHouseholds", "hasUserHouseholdsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserWhereInput2beavermoneyappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserWhereInput2beavermoneyappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserWhereInput2beavermoneyappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "emailNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNEQ = data
		case "emailIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailIn = data
		case "emailNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNotIn = data
		case "emailGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailGT = data
		case "emailGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailGTE = data
		case "emailLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailLT = data
		case "emailLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailLTE = data
		case "emailContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailContains = data
		case "emailHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailHasPrefix = data
		case "emailHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailHasSuffix = data
		case "emailEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailEqualFold = data
		case "emailContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hasHouseholds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholds"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholds = data
		case "hasHouseholdsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdsWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdsWith = data
		case "hasAccounts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccounts"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccounts = data
		case "hasAccountsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountsWith"))
			data, err := ec.unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccountsWith = data
		case "hasTransactions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactions = data
		case "hasTransactionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionsWith"))
			data, err := ec.unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionsWith = data
		case "hasUserKeys":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserKeys"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserKeys = data
		case "hasUserKeysWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserKeysWith"))
			data, err := ec.unmarshalOUserKeyWhereInput2beavermoneyappentUserKeyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserKeysWith = data
		case "hasUserHouseholds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserHouseholds"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserHouseholds = data
		case "hasUserHouseholdsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserHouseholdsWith"))
			data, err := ec.unmarshalOUserHouseholdWhereInput2beavermoneyappentUserHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserHouseholdsWith = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.UserKey:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserKey(ctx, sel, obj)
	case *ent.UserHousehold:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserHousehold(ctx, sel, obj)
	case *ent.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case *ent.TransactionEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TransactionEntry(ctx, sel, obj)
	case *ent.TransactionCategory:
		if obj == nil {
			return graphql.Null
		}
		return ec._TransactionCategory(ctx, sel, obj)
	case *ent.Transaction:
		if obj == nil {
			return graphql.Null
		}
		return ec._Transaction(ctx, sel, obj)
	case *ent.InvestmentLot:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvestmentLot(ctx, sel, obj)
	case *ent.Investment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Investment(ctx, sel, obj)
	case *ent.Household:
		if obj == nil {
			return graphql.Null
		}
		return ec._Household(ctx, sel, obj)
	case *ent.Currency:
		if obj == nil {
			return graphql.Null
		}
		return ec._Currency(ctx, sel, obj)
	case *ent.Account:
		if obj == nil {
			return graphql.Null
		}
		return ec._Account(ctx, sel, obj)
	default:
		if obj, ok := obj.(graphql.Marshaler); ok {
			return obj
		} else {
			panic(fmt.Errorf("unexpected type %T; non-generated variants of Node must implement graphql.Marshaler", obj))
		}
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var accountImplementors = []string{"Account", "Node"}

func (ec *executionContext) _Account(ctx context.Context, sel ast.SelectionSet, obj *ent.Account) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Account")
		case "id":
			out.Values[i] = ec._Account_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Account_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._Account_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._Account_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Account_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Account_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "balance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_balance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "icon":
			out.Values[i] = ec._Account_icon(ctx, field, obj)
		case "value":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_value(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fxRate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_fxRate(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "currencyID":
			out.Values[i] = ec._Account_currencyID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			out.Values[i] = ec._Account_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "currency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_currency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionEntries":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_transactionEntries(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investments":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_investments(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "balanceInHouseholdCurrency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_balanceInHouseholdCurrency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valueInHouseholdCurrency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_valueInHouseholdCurrency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var accountConnectionImplementors = []string{"AccountConnection"}

func (ec *executionContext) _AccountConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.AccountConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccountConnection")
		case "edges":
			out.Values[i] = ec._AccountConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._AccountConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._AccountConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var accountEdgeImplementors = []string{"AccountEdge"}

func (ec *executionContext) _AccountEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.AccountEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccountEdge")
		case "node":
			out.Values[i] = ec._AccountEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._AccountEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var categoryAggregateImplementors = []string{"CategoryAggregate"}

func (ec *executionContext) _CategoryAggregate(ctx context.Context, sel ast.SelectionSet, obj *CategoryAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, categoryAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CategoryAggregate")
		case "category":
			out.Values[i] = ec._CategoryAggregate_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._CategoryAggregate_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "transactionCount":
			out.Values[i] = ec._CategoryAggregate_transactionCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var categoryTypeAggregateImplementors = []string{"CategoryTypeAggregate"}

func (ec *executionContext) _CategoryTypeAggregate(ctx context.Context, sel ast.SelectionSet, obj *CategoryTypeAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, categoryTypeAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CategoryTypeAggregate")
		case "categoryType":
			out.Values[i] = ec._CategoryTypeAggregate_categoryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._CategoryTypeAggregate_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "transactionCount":
			out.Values[i] = ec._CategoryTypeAggregate_transactionCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "categories":
			out.Values[i] = ec._CategoryTypeAggregate_categories(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cryptoQuoteResultImplementors = []string{"CryptoQuoteResult"}

func (ec *executionContext) _CryptoQuoteResult(ctx context.Context, sel ast.SelectionSet, obj *CryptoQuoteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cryptoQuoteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CryptoQuoteResult")
		case "symbol":
			out.Values[i] = ec._CryptoQuoteResult_symbol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._CryptoQuoteResult_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exchange":
			out.Values[i] = ec._CryptoQuoteResult_exchange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currency":
			out.Values[i] = ec._CryptoQuoteResult_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentPrice":
			out.Values[i] = ec._CryptoQuoteResult_currentPrice(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var currencyImplementors = []string{"Currency", "Node"}

func (ec *executionContext) _Currency(ctx context.Context, sel ast.SelectionSet, obj *ent.Currency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, currencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Currency")
		case "id":
			out.Values[i] = ec._Currency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "code":
			out.Values[i] = ec._Currency_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "accounts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Currency_accounts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investments":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Currency_investments(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionEntries":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Currency_transactionEntries(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "households":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Currency_households(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var financialReportImplementors = []string{"FinancialReport"}

func (ec *executionContext) _FinancialReport(ctx context.Context, sel ast.SelectionSet, obj *FinancialReport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, financialReportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FinancialReport")
		case "totalIncome":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FinancialReport_totalIncome(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "totalExpenses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FinancialReport_totalExpenses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "incomeByCategoryType":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FinancialReport_incomeByCategoryType(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "expensesByCategoryType":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FinancialReport_expensesByCategoryType(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FinancialReport_transactionCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startDate":
			out.Values[i] = ec._FinancialReport_startDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "endDate":
			out.Values[i] = ec._FinancialReport_endDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var householdImplementors = []string{"Household", "Node"}

func (ec *executionContext) _Household(ctx context.Context, sel ast.SelectionSet, obj *ent.Household) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, householdImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Household")
		case "id":
			out.Values[i] = ec._Household_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Household_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._Household_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Household_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "locale":
			out.Values[i] = ec._Household_locale(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "currencyID":
			out.Values[i] = ec._Household_currencyID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "currency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_currency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_users(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "accounts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_accounts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_transactions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investments":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_investments(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investmentLots":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_investmentLots(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionCategories":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_transactionCategories(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionEntries":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_transactionEntries(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userHouseholds":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_userHouseholds(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var investmentImplementors = []string{"Investment", "Node"}

func (ec *executionContext) _Investment(ctx context.Context, sel ast.SelectionSet, obj *ent.Investment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, investmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Investment")
		case "id":
			out.Values[i] = ec._Investment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Investment_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._Investment_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._Investment_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Investment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Investment_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "symbol":
			out.Values[i] = ec._Investment_symbol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "amount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_amount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "quote":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_quote(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "value":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_value(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "accountID":
			out.Values[i] = ec._Investment_accountID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "currencyID":
			out.Values[i] = ec._Investment_currencyID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "account":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_account(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "currency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_currency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investmentLots":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_investmentLots(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valueInHouseholdCurrency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_valueInHouseholdCurrency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var investmentConnectionImplementors = []string{"InvestmentConnection"}

func (ec *executionContext) _InvestmentConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.InvestmentConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, investmentConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvestmentConnection")
		case "edges":
			out.Values[i] = ec._InvestmentConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._InvestmentConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._InvestmentConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var investmentEdgeImplementors = []string{"InvestmentEdge"}

func (ec *executionContext) _InvestmentEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.InvestmentEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, investmentEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvestmentEdge")
		case "node":
			out.Values[i] = ec._InvestmentEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._InvestmentEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var investmentLotImplementors = []string{"InvestmentLot", "Node"}

func (ec *executionContext) _InvestmentLot(ctx context.Context, sel ast.SelectionSet, obj *ent.InvestmentLot) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, investmentLotImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvestmentLot")
		case "id":
			out.Values[i] = ec._InvestmentLot_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._InvestmentLot_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._InvestmentLot_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._InvestmentLot_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "amount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InvestmentLot_amount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "price":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InvestmentLot_price(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investmentID":
			out.Values[i] = ec._InvestmentLot_investmentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "transactionID":
			out.Values[i] = ec._InvestmentLot_transactionID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InvestmentLot_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InvestmentLot_investment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transaction":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InvestmentLot_transaction(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var investmentLotConnectionImplementors = []string{"InvestmentLotConnection"}

func (ec *executionContext) _InvestmentLotConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.InvestmentLotConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, investmentLotConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvestmentLotConnection")
		case "edges":
			out.Values[i] = ec._InvestmentLotConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._InvestmentLotConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._InvestmentLotConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var investmentLotEdgeImplementors = []string{"InvestmentLotEdge"}

func (ec *executionContext) _InvestmentLotEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.InvestmentLotEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, investmentLotEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvestmentLotEdge")
		case "node":
			out.Values[i] = ec._InvestmentLotEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._InvestmentLotEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createAccount":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAccount(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createInvestment":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createInvestment(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTransactionCategory":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTransactionCategory(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createExpense":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createExpense(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createIncome":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createIncome(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTransfer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTransfer(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buyInvestment":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_buyInvestment(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sellInvestment":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sellInvestment(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "moveInvestment":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_moveInvestment(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entgql.PageInfo[int]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "accounts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_accounts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "currencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currencies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "households":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_households(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "investments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_investments(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "investmentLots":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_investmentLots(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transactions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "transactionCategories":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transactionCategories(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "transactionEntries":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transactionEntries(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userHouseholds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userHouseholds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fxRate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fxRate(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "stockQuote":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_stockQuote(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cryptoQuote":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cryptoQuote(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "financialReport":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_financialReport(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stockQuoteResultImplementors = []string{"StockQuoteResult"}

func (ec *executionContext) _StockQuoteResult(ctx context.Context, sel ast.SelectionSet, obj *StockQuoteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stockQuoteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StockQuoteResult")
		case "symbol":
			out.Values[i] = ec._StockQuoteResult_symbol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._StockQuoteResult_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exchange":
			out.Values[i] = ec._StockQuoteResult_exchange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currency":
			out.Values[i] = ec._StockQuoteResult_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentPrice":
			out.Values[i] = ec._StockQuoteResult_currentPrice(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionImplementors = []string{"Transaction", "Node"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *ent.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "id":
			out.Values[i] = ec._Transaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Transaction_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._Transaction_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._Transaction_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Transaction_description(ctx, field, obj)
		case "datetime":
			out.Values[i] = ec._Transaction_datetime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			out.Values[i] = ec._Transaction_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "categoryID":
			out.Values[i] = ec._Transaction_categoryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "category":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_category(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionEntries":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_transactionEntries(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investmentLots":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_investmentLots(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionCategoryImplementors = []string{"TransactionCategory", "Node"}

func (ec *executionContext) _TransactionCategory(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionCategory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionCategoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionCategory")
		case "id":
			out.Values[i] = ec._TransactionCategory_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._TransactionCategory_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._TransactionCategory_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._TransactionCategory_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._TransactionCategory_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._TransactionCategory_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "icon":
			out.Values[i] = ec._TransactionCategory_icon(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isImmutable":
			out.Values[i] = ec._TransactionCategory_isImmutable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionCategory_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionCategory_transactions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionCategoryConnectionImplementors = []string{"TransactionCategoryConnection"}

func (ec *executionContext) _TransactionCategoryConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionCategoryConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionCategoryConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionCategoryConnection")
		case "edges":
			out.Values[i] = ec._TransactionCategoryConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._TransactionCategoryConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TransactionCategoryConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionCategoryEdgeImplementors = []string{"TransactionCategoryEdge"}

func (ec *executionContext) _TransactionCategoryEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionCategoryEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionCategoryEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionCategoryEdge")
		case "node":
			out.Values[i] = ec._TransactionCategoryEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._TransactionCategoryEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionConnectionImplementors = []string{"TransactionConnection"}

func (ec *executionContext) _TransactionConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionConnection")
		case "edges":
			out.Values[i] = ec._TransactionConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._TransactionConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TransactionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionEdgeImplementors = []string{"TransactionEdge"}

func (ec *executionContext) _TransactionEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionEdge")
		case "node":
			out.Values[i] = ec._TransactionEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._TransactionEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionEntryImplementors = []string{"TransactionEntry", "Node"}

func (ec *executionContext) _TransactionEntry(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionEntry")
		case "id":
			out.Values[i] = ec._TransactionEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._TransactionEntry_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._TransactionEntry_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._TransactionEntry_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "amount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionEntry_amount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "accountID":
			out.Values[i] = ec._TransactionEntry_accountID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "currencyID":
			out.Values[i] = ec._TransactionEntry_currencyID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "transactionID":
			out.Values[i] = ec._TransactionEntry_transactionID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionEntry_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "account":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionEntry_account(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "currency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionEntry_currency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transaction":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionEntry_transaction(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "Node"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *ent.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._User_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._User_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "households":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_households(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "accounts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_accounts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_transactions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userKeys":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_userKeys(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userHouseholds":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_userHouseholds(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userHouseholdImplementors = []string{"UserHousehold", "Node"}

func (ec *executionContext) _UserHousehold(ctx context.Context, sel ast.SelectionSet, obj *ent.UserHousehold) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userHouseholdImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserHousehold")
		case "id":
			out.Values[i] = ec._UserHousehold_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._UserHousehold_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._UserHousehold_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			out.Values[i] = ec._UserHousehold_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._UserHousehold_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "role":
			out.Values[i] = ec._UserHousehold_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserHousehold_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserHousehold_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userKeyImplementors = []string{"UserKey", "Node"}

func (ec *executionContext) _UserKey(ctx context.Context, sel ast.SelectionSet, obj *ent.UserKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserKey")
		case "id":
			out.Values[i] = ec._UserKey_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._UserKey_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._UserKey_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "provider":
			out.Values[i] = ec._UserKey_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "key":
			out.Values[i] = ec._UserKey_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			out.Values[i] = ec._UserKey_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserKey_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAccount2beavermoneyappentAccount(ctx context.Context, sel ast.SelectionSet, v *ent.Account) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Account(ctx, sel, v)
}

func (ec *executionContext) marshalNAccountConnection2beavermoneyappentAccountConnection(ctx context.Context, sel ast.SelectionSet, v ent.AccountConnection) graphql.Marshaler {
	return ec._AccountConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNAccountConnection2beavermoneyappentAccountConnection(ctx context.Context, sel ast.SelectionSet, v *ent.AccountConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AccountConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNAccountEdge2beavermoneyappentAccountEdge(ctx context.Context, sel ast.SelectionSet, v ent.AccountEdge) graphql.Marshaler {
	return ec._AccountEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNAccountEdge2beavermoneyappentAccountEdge(ctx context.Context, sel ast.SelectionSet, v *ent.AccountEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AccountEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAccountType2beavermoneyappentaccountType(ctx context.Context, v any) (account.Type, error) {
	var res account.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAccountType2beavermoneyappentaccountType(ctx context.Context, sel ast.SelectionSet, v account.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAccountWhereInput2beavermoneyappentAccountWhereInput(ctx context.Context, v any) (*ent.AccountWhereInput, error) {
	res, err := ec.unmarshalInputAccountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBuyInvestmentInputCustom2beavermoneyappBuyInvestmentInputCustom(ctx context.Context, v any) (BuyInvestmentInputCustom, error) {
	res, err := ec.unmarshalInputBuyInvestmentInputCustom(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCategoryAggregate2beavermoneyappCategoryAggregate(ctx context.Context, sel ast.SelectionSet, v []*CategoryAggregate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCategoryAggregate2beavermoneyappCategoryAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCategoryAggregate2beavermoneyappCategoryAggregate(ctx context.Context, sel ast.SelectionSet, v *CategoryAggregate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CategoryAggregate(ctx, sel, v)
}

func (ec *executionContext) marshalNCategoryTypeAggregate2beavermoneyappCategoryTypeAggregate(ctx context.Context, sel ast.SelectionSet, v []*CategoryTypeAggregate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCategoryTypeAggregate2beavermoneyappCategoryTypeAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCategoryTypeAggregate2beavermoneyappCategoryTypeAggregate(ctx context.Context, sel ast.SelectionSet, v *CategoryTypeAggregate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CategoryTypeAggregate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateAccountInput2beavermoneyappentCreateAccountInput(ctx context.Context, v any) (ent.CreateAccountInput, error) {
	res, err := ec.unmarshalInputCreateAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateExpenseInputCustom2beavermoneyappCreateExpenseInputCustom(ctx context.Context, v any) (CreateExpenseInputCustom, error) {
	res, err := ec.unmarshalInputCreateExpenseInputCustom(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateIncomeInputCustom2beavermoneyappCreateIncomeInputCustom(ctx context.Context, v any) (CreateIncomeInputCustom, error) {
	res, err := ec.unmarshalInputCreateIncomeInputCustom(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateInvestmentInput2beavermoneyappentCreateInvestmentInput(ctx context.Context, v any) (*ent.CreateInvestmentInput, error) {
	res, err := ec.unmarshalInputCreateInvestmentInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateInvestmentInputCustom2beavermoneyappCreateInvestmentInputCustom(ctx context.Context, v any) (CreateInvestmentInputCustom, error) {
	res, err := ec.unmarshalInputCreateInvestmentInputCustom(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateInvestmentLotInput2beavermoneyappentCreateInvestmentLotInput(ctx context.Context, v any) ([]*ent.CreateInvestmentLotInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.CreateInvestmentLotInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateInvestmentLotInput2beavermoneyappentCreateInvestmentLotInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateInvestmentLotInput2beavermoneyappentCreateInvestmentLotInput(ctx context.Context, v any) (*ent.CreateInvestmentLotInput, error) {
	res, err := ec.unmarshalInputCreateInvestmentLotInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateTransactionCategoryInput2beavermoneyappentCreateTransactionCategoryInput(ctx context.Context, v any) (ent.CreateTransactionCategoryInput, error) {
	res, err := ec.unmarshalInputCreateTransactionCategoryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx context.Context, v any) ([]*ent.CreateTransactionEntryInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.CreateTransactionEntryInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateTransactionEntryInput2beavermoneyappentCreateTransactionEntryInput(ctx context.Context, v any) (*ent.CreateTransactionEntryInput, error) {
	res, err := ec.unmarshalInputCreateTransactionEntryInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateTransactionInput2beavermoneyappentCreateTransactionInput(ctx context.Context, v any) (*ent.CreateTransactionInput, error) {
	res, err := ec.unmarshalInputCreateTransactionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateTransferInputCustom2beavermoneyappCreateTransferInputCustom(ctx context.Context, v any) (CreateTransferInputCustom, error) {
	res, err := ec.unmarshalInputCreateTransferInputCustom(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCurrency2beavermoneyappentCurrency(ctx context.Context, sel ast.SelectionSet, v []*ent.Currency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCurrency2beavermoneyappentCurrency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCurrency2beavermoneyappentCurrency(ctx context.Context, sel ast.SelectionSet, v *ent.Currency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Currency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx context.Context, v any) (*ent.CurrencyWhereInput, error) {
	res, err := ec.unmarshalInputCurrencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2entgoiocontribentgqlCursor(ctx context.Context, v any) (entgql.Cursor[int], error) {
	var res entgql.Cursor[int]
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2entgoiocontribentgqlCursor(ctx context.Context, sel ast.SelectionSet, v entgql.Cursor[int]) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFinancialReport2beavermoneyappFinancialReport(ctx context.Context, sel ast.SelectionSet, v FinancialReport) graphql.Marshaler {
	return ec._FinancialReport(ctx, sel, &v)
}

func (ec *executionContext) marshalNFinancialReport2beavermoneyappFinancialReport(ctx context.Context, sel ast.SelectionSet, v *FinancialReport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FinancialReport(ctx, sel, v)
}

func (ec *executionContext) marshalNHousehold2beavermoneyappentHousehold(ctx context.Context, sel ast.SelectionSet, v []*ent.Household) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHousehold2beavermoneyappentHousehold(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHousehold2beavermoneyappentHousehold(ctx context.Context, sel ast.SelectionSet, v *ent.Household) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Household(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx context.Context, v any) (*ent.HouseholdWhereInput, error) {
	res, err := ec.unmarshalInputHouseholdWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v any) ([]int, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNInvestment2beavermoneyappentInvestment(ctx context.Context, sel ast.SelectionSet, v *ent.Investment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Investment(ctx, sel, v)
}

func (ec *executionContext) marshalNInvestmentConnection2beavermoneyappentInvestmentConnection(ctx context.Context, sel ast.SelectionSet, v ent.InvestmentConnection) graphql.Marshaler {
	return ec._InvestmentConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNInvestmentConnection2beavermoneyappentInvestmentConnection(ctx context.Context, sel ast.SelectionSet, v *ent.InvestmentConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InvestmentConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNInvestmentEdge2beavermoneyappentInvestmentEdge(ctx context.Context, sel ast.SelectionSet, v ent.InvestmentEdge) graphql.Marshaler {
	return ec._InvestmentEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNInvestmentEdge2beavermoneyappentInvestmentEdge(ctx context.Context, sel ast.SelectionSet, v *ent.InvestmentEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InvestmentEdge(ctx, sel, v)
}

func (ec *executionContext) marshalNInvestmentLot2beavermoneyappentInvestmentLot(ctx context.Context, sel ast.SelectionSet, v *ent.InvestmentLot) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InvestmentLot(ctx, sel, v)
}

func (ec *executionContext) marshalNInvestmentLotConnection2beavermoneyappentInvestmentLotConnection(ctx context.Context, sel ast.SelectionSet, v ent.InvestmentLotConnection) graphql.Marshaler {
	return ec._InvestmentLotConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNInvestmentLotConnection2beavermoneyappentInvestmentLotConnection(ctx context.Context, sel ast.SelectionSet, v *ent.InvestmentLotConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InvestmentLotConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput(ctx context.Context, v any) (*ent.InvestmentLotWhereInput, error) {
	res, err := ec.unmarshalInputInvestmentLotWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNInvestmentType2beavermoneyappentinvestmentType(ctx context.Context, v any) (investment.Type, error) {
	var res investment.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInvestmentType2beavermoneyappentinvestmentType(ctx context.Context, sel ast.SelectionSet, v investment.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx context.Context, v any) (*ent.InvestmentWhereInput, error) {
	res, err := ec.unmarshalInputInvestmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMoveInvestmentInputCustom2beavermoneyappMoveInvestmentInputCustom(ctx context.Context, v any) (MoveInvestmentInputCustom, error) {
	res, err := ec.unmarshalInputMoveInvestmentInputCustom(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNode2beavermoneyappentNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2beavermoneyappentNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx context.Context, v any) (entgql.OrderDirection, error) {
	var res entgql.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx context.Context, sel ast.SelectionSet, v entgql.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx context.Context, sel ast.SelectionSet, v entgql.PageInfo[int]) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNSellInvestmentInputCustom2beavermoneyappSellInvestmentInputCustom(ctx context.Context, v any) (SellInvestmentInputCustom, error) {
	res, err := ec.unmarshalInputSellInvestmentInputCustom(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTimePeriodInput2beavermoneyappTimePeriodInput(ctx context.Context, v any) (TimePeriodInput, error) {
	res, err := ec.unmarshalInputTimePeriodInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransaction2beavermoneyappentTransaction(ctx context.Context, sel ast.SelectionSet, v *ent.Transaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionCategory2beavermoneyappentTransactionCategory(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionCategory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionCategory(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionCategoryConnection2beavermoneyappentTransactionCategoryConnection(ctx context.Context, sel ast.SelectionSet, v ent.TransactionCategoryConnection) graphql.Marshaler {
	return ec._TransactionCategoryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactionCategoryConnection2beavermoneyappentTransactionCategoryConnection(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionCategoryConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionCategoryConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionCategoryEdge2beavermoneyappentTransactionCategoryEdge(ctx context.Context, sel ast.SelectionSet, v ent.TransactionCategoryEdge) graphql.Marshaler {
	return ec._TransactionCategoryEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactionCategoryEdge2beavermoneyappentTransactionCategoryEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionCategoryEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionCategoryEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx context.Context, v any) (transactioncategory.Type, error) {
	var res transactioncategory.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx context.Context, sel ast.SelectionSet, v transactioncategory.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTransactionCategoryWhereInput2beavermoneyappentTransactionCategoryWhereInput(ctx context.Context, v any) (*ent.TransactionCategoryWhereInput, error) {
	res, err := ec.unmarshalInputTransactionCategoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionConnection2beavermoneyappentTransactionConnection(ctx context.Context, sel ast.SelectionSet, v ent.TransactionConnection) graphql.Marshaler {
	return ec._TransactionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactionConnection2beavermoneyappentTransactionConnection(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionEdge2beavermoneyappentTransactionEdge(ctx context.Context, sel ast.SelectionSet, v ent.TransactionEdge) graphql.Marshaler {
	return ec._TransactionEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactionEdge2beavermoneyappentTransactionEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionEdge(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionEntry2beavermoneyappentTransactionEntry(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionEntry2beavermoneyappentTransactionEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTransactionEntry2beavermoneyappentTransactionEntry(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx context.Context, v any) (*ent.TransactionEntryWhereInput, error) {
	res, err := ec.unmarshalInputTransactionEntryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTransactionOrderField2beavermoneyappentTransactionOrderField(ctx context.Context, v any) (*ent.TransactionOrderField, error) {
	var res = new(ent.TransactionOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionOrderField2beavermoneyappentTransactionOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx context.Context, v any) (*ent.TransactionWhereInput, error) {
	res, err := ec.unmarshalInputTransactionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2beavermoneyappentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserHousehold2beavermoneyappentUserHousehold(ctx context.Context, sel ast.SelectionSet, v []*ent.UserHousehold) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserHousehold2beavermoneyappentUserHousehold(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserHousehold2beavermoneyappentUserHousehold(ctx context.Context, sel ast.SelectionSet, v *ent.UserHousehold) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserHousehold(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx context.Context, v any) (userhousehold.Role, error) {
	var res userhousehold.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx context.Context, sel ast.SelectionSet, v userhousehold.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserHouseholdWhereInput2beavermoneyappentUserHouseholdWhereInput(ctx context.Context, v any) (*ent.UserHouseholdWhereInput, error) {
	res, err := ec.unmarshalInputUserHouseholdWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserKey2beavermoneyappentUserKey(ctx context.Context, sel ast.SelectionSet, v *ent.UserKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserKey(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserKeyProvider2beavermoneyappentuserkeyProvider(ctx context.Context, v any) (userkey.Provider, error) {
	var res userkey.Provider
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserKeyProvider2beavermoneyappentuserkeyProvider(ctx context.Context, sel ast.SelectionSet, v userkey.Provider) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserKeyWhereInput2beavermoneyappentUserKeyWhereInput(ctx context.Context, v any) (*ent.UserKeyWhereInput, error) {
	res, err := ec.unmarshalInputUserKeyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserWhereInput2beavermoneyappentUserWhereInput(ctx context.Context, v any) (*ent.UserWhereInput, error) {
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAccount2beavermoneyappentAccount(ctx context.Context, sel ast.SelectionSet, v []*ent.Account) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccount2beavermoneyappentAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOAccount2beavermoneyappentAccount(ctx context.Context, sel ast.SelectionSet, v *ent.Account) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Account(ctx, sel, v)
}

func (ec *executionContext) marshalOAccountEdge2beavermoneyappentAccountEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.AccountEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAccountEdge2beavermoneyappentAccountEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAccountEdge2beavermoneyappentAccountEdge(ctx context.Context, sel ast.SelectionSet, v *ent.AccountEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AccountEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAccountType2beavermoneyappentaccountType(ctx context.Context, v any) ([]account.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]account.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAccountType2beavermoneyappentaccountType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAccountType2beavermoneyappentaccountType(ctx context.Context, sel ast.SelectionSet, v []account.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccountType2beavermoneyappentaccountType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAccountType2beavermoneyappentaccountType(ctx context.Context, v any) (*account.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(account.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAccountType2beavermoneyappentaccountType(ctx context.Context, sel ast.SelectionSet, v *account.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput(ctx context.Context, v any) ([]*ent.AccountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.AccountWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAccountWhereInput2beavermoneyappentAccountWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAccountWhereInput2beavermoneyappentAccountWhereInput(ctx context.Context, v any) (*ent.AccountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAccountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCryptoQuoteResult2beavermoneyappCryptoQuoteResult(ctx context.Context, sel ast.SelectionSet, v *CryptoQuoteResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CryptoQuoteResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx context.Context, v any) ([]*ent.CurrencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.CurrencyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCurrencyWhereInput2beavermoneyappentCurrencyWhereInput(ctx context.Context, v any) (*ent.CurrencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCurrencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2entgoiocontribentgqlCursor(ctx context.Context, v any) (*entgql.Cursor[int], error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entgql.Cursor[int])
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2entgoiocontribentgqlCursor(ctx context.Context, sel ast.SelectionSet, v *entgql.Cursor[int]) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOHousehold2beavermoneyappentHousehold(ctx context.Context, sel ast.SelectionSet, v []*ent.Household) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHousehold2beavermoneyappentHousehold(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx context.Context, v any) ([]*ent.HouseholdWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.HouseholdWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOHouseholdWhereInput2beavermoneyappentHouseholdWhereInput(ctx context.Context, v any) (*ent.HouseholdWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHouseholdWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v any) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalIntID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalIntID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOInvestment2beavermoneyappentInvestment(ctx context.Context, sel ast.SelectionSet, v []*ent.Investment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInvestment2beavermoneyappentInvestment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOInvestment2beavermoneyappentInvestment(ctx context.Context, sel ast.SelectionSet, v *ent.Investment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Investment(ctx, sel, v)
}

func (ec *executionContext) marshalOInvestmentEdge2beavermoneyappentInvestmentEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.InvestmentEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInvestmentEdge2beavermoneyappentInvestmentEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOInvestmentEdge2beavermoneyappentInvestmentEdge(ctx context.Context, sel ast.SelectionSet, v *ent.InvestmentEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InvestmentEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOInvestmentLot2beavermoneyappentInvestmentLot(ctx context.Context, sel ast.SelectionSet, v []*ent.InvestmentLot) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInvestmentLot2beavermoneyappentInvestmentLot(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOInvestmentLot2beavermoneyappentInvestmentLot(ctx context.Context, sel ast.SelectionSet, v *ent.InvestmentLot) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InvestmentLot(ctx, sel, v)
}

func (ec *executionContext) marshalOInvestmentLotEdge2beavermoneyappentInvestmentLotEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.InvestmentLotEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInvestmentLotEdge2beavermoneyappentInvestmentLotEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOInvestmentLotEdge2beavermoneyappentInvestmentLotEdge(ctx context.Context, sel ast.SelectionSet, v *ent.InvestmentLotEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InvestmentLotEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput(ctx context.Context, v any) ([]*ent.InvestmentLotWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.InvestmentLotWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOInvestmentLotWhereInput2beavermoneyappentInvestmentLotWhereInput(ctx context.Context, v any) (*ent.InvestmentLotWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputInvestmentLotWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInvestmentType2beavermoneyappentinvestmentType(ctx context.Context, v any) ([]investment.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]investment.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInvestmentType2beavermoneyappentinvestmentType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInvestmentType2beavermoneyappentinvestmentType(ctx context.Context, sel ast.SelectionSet, v []investment.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInvestmentType2beavermoneyappentinvestmentType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInvestmentType2beavermoneyappentinvestmentType(ctx context.Context, v any) (*investment.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(investment.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInvestmentType2beavermoneyappentinvestmentType(ctx context.Context, sel ast.SelectionSet, v *investment.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx context.Context, v any) ([]*ent.InvestmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.InvestmentWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOInvestmentWhereInput2beavermoneyappentInvestmentWhereInput(ctx context.Context, v any) (*ent.InvestmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputInvestmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2beavermoneyappentNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOStockQuoteResult2beavermoneyappStockQuoteResult(ctx context.Context, sel ast.SelectionSet, v *StockQuoteResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StockQuoteResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTransaction2beavermoneyappentTransaction(ctx context.Context, sel ast.SelectionSet, v []*ent.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2beavermoneyappentTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransaction2beavermoneyappentTransaction(ctx context.Context, sel ast.SelectionSet, v *ent.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionCategory2beavermoneyappentTransactionCategory(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionCategory2beavermoneyappentTransactionCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransactionCategory2beavermoneyappentTransactionCategory(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionCategory(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionCategoryEdge2beavermoneyappentTransactionCategoryEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionCategoryEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTransactionCategoryEdge2beavermoneyappentTransactionCategoryEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTransactionCategoryEdge2beavermoneyappentTransactionCategoryEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionCategoryEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionCategoryEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx context.Context, v any) ([]transactioncategory.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]transactioncategory.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx context.Context, sel ast.SelectionSet, v []transactioncategory.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx context.Context, v any) (*transactioncategory.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(transactioncategory.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTransactionCategoryType2beavermoneyappenttransactioncategoryType(ctx context.Context, sel ast.SelectionSet, v *transactioncategory.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTransactionCategoryWhereInput2beavermoneyappentTransactionCategoryWhereInput(ctx context.Context, v any) ([]*ent.TransactionCategoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.TransactionCategoryWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionCategoryWhereInput2beavermoneyappentTransactionCategoryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTransactionCategoryWhereInput2beavermoneyappentTransactionCategoryWhereInput(ctx context.Context, v any) (*ent.TransactionCategoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionCategoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTransactionEdge2beavermoneyappentTransactionEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTransactionEdge2beavermoneyappentTransactionEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTransactionEdge2beavermoneyappentTransactionEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionEntry2beavermoneyappentTransactionEntry(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionEntry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionEntry2beavermoneyappentTransactionEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx context.Context, v any) ([]*ent.TransactionEntryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.TransactionEntryWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTransactionEntryWhereInput2beavermoneyappentTransactionEntryWhereInput(ctx context.Context, v any) (*ent.TransactionEntryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionEntryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTransactionOrder2beavermoneyappentTransactionOrder(ctx context.Context, v any) (*ent.TransactionOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx context.Context, v any) ([]*ent.TransactionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.TransactionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTransactionWhereInput2beavermoneyappentTransactionWhereInput(ctx context.Context, v any) (*ent.TransactionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUser2beavermoneyappentUser(ctx context.Context, sel ast.SelectionSet, v []*ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2beavermoneyappentUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUserHousehold2beavermoneyappentUserHousehold(ctx context.Context, sel ast.SelectionSet, v []*ent.UserHousehold) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserHousehold2beavermoneyappentUserHousehold(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx context.Context, v any) ([]userhousehold.Role, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]userhousehold.Role, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx context.Context, sel ast.SelectionSet, v []userhousehold.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx context.Context, v any) (*userhousehold.Role, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(userhousehold.Role)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserHouseholdRole2beavermoneyappentuserhouseholdRole(ctx context.Context, sel ast.SelectionSet, v *userhousehold.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserHouseholdWhereInput2beavermoneyappentUserHouseholdWhereInput(ctx context.Context, v any) ([]*ent.UserHouseholdWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.UserHouseholdWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserHouseholdWhereInput2beavermoneyappentUserHouseholdWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserHouseholdWhereInput2beavermoneyappentUserHouseholdWhereInput(ctx context.Context, v any) (*ent.UserHouseholdWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserHouseholdWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserKey2beavermoneyappentUserKey(ctx context.Context, sel ast.SelectionSet, v []*ent.UserKey) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserKey2beavermoneyappentUserKey(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserKeyProvider2beavermoneyappentuserkeyProvider(ctx context.Context, v any) ([]userkey.Provider, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]userkey.Provider, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserKeyProvider2beavermoneyappentuserkeyProvider(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUserKeyProvider2beavermoneyappentuserkeyProvider(ctx context.Context, sel ast.SelectionSet, v []userkey.Provider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserKeyProvider2beavermoneyappentuserkeyProvider(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserKeyProvider2beavermoneyappentuserkeyProvider(ctx context.Context, v any) (*userkey.Provider, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(userkey.Provider)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserKeyProvider2beavermoneyappentuserkeyProvider(ctx context.Context, sel ast.SelectionSet, v *userkey.Provider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserKeyWhereInput2beavermoneyappentUserKeyWhereInput(ctx context.Context, v any) ([]*ent.UserKeyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.UserKeyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserKeyWhereInput2beavermoneyappentUserKeyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserKeyWhereInput2beavermoneyappentUserKeyWhereInput(ctx context.Context, v any) (*ent.UserKeyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserKeyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserWhereInput2beavermoneyappentUserWhereInput(ctx context.Context, v any) ([]*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.UserWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserWhereInput2beavermoneyappentUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserWhereInput2beavermoneyappentUserWhereInput(ctx context.Context, v any) (*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
