// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package fijoy

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"entgo.io/contrib/entgql"
	"fijoy.app/ent"
	"fijoy.app/ent/account"
	"fijoy.app/ent/investment"
	"fijoy.app/ent/transactioncategory"
	"fijoy.app/ent/userhousehold"
	"fijoy.app/ent/userkey"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Account() AccountResolver
	Investment() InvestmentResolver
	Lot() LotResolver
	Query() QueryResolver
	TransactionEntry() TransactionEntryResolver
	AccountWhereInput() AccountWhereInputResolver
	InvestmentWhereInput() InvestmentWhereInputResolver
	LotWhereInput() LotWhereInputResolver
	TransactionEntryWhereInput() TransactionEntryWhereInputResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Account struct {
		Balance                    func(childComplexity int) int
		BalanceInHouseholdCurrency func(childComplexity int) int
		CreateTime                 func(childComplexity int) int
		Currency                   func(childComplexity int) int
		FxRate                     func(childComplexity int) int
		Household                  func(childComplexity int) int
		HouseholdID                func(childComplexity int) int
		ID                         func(childComplexity int) int
		Investments                func(childComplexity int) int
		Name                       func(childComplexity int) int
		TransactionEntries         func(childComplexity int) int
		Type                       func(childComplexity int) int
		UpdateTime                 func(childComplexity int) int
		User                       func(childComplexity int) int
		Value                      func(childComplexity int) int
		ValueInHouseholdCurrency   func(childComplexity int) int
	}

	Currency struct {
		Accounts           func(childComplexity int) int
		Code               func(childComplexity int) int
		Households         func(childComplexity int) int
		ID                 func(childComplexity int) int
		Investments        func(childComplexity int) int
		TransactionEntries func(childComplexity int) int
	}

	Household struct {
		Accounts              func(childComplexity int) int
		CreateTime            func(childComplexity int) int
		Currency              func(childComplexity int) int
		ID                    func(childComplexity int) int
		Investments           func(childComplexity int) int
		Locale                func(childComplexity int) int
		Lots                  func(childComplexity int) int
		Name                  func(childComplexity int) int
		TransactionCategories func(childComplexity int) int
		TransactionEntries    func(childComplexity int) int
		Transactions          func(childComplexity int) int
		UpdateTime            func(childComplexity int) int
		UserHouseholds        func(childComplexity int) int
		Users                 func(childComplexity int) int
	}

	Investment struct {
		Account                  func(childComplexity int) int
		Amount                   func(childComplexity int) int
		CreateTime               func(childComplexity int) int
		Currency                 func(childComplexity int) int
		Household                func(childComplexity int) int
		HouseholdID              func(childComplexity int) int
		ID                       func(childComplexity int) int
		Lots                     func(childComplexity int) int
		Name                     func(childComplexity int) int
		Quote                    func(childComplexity int) int
		Symbol                   func(childComplexity int) int
		Type                     func(childComplexity int) int
		UpdateTime               func(childComplexity int) int
		Value                    func(childComplexity int) int
		ValueInHouseholdCurrency func(childComplexity int) int
	}

	Lot struct {
		Amount      func(childComplexity int) int
		CreateTime  func(childComplexity int) int
		Datetime    func(childComplexity int) int
		Household   func(childComplexity int) int
		HouseholdID func(childComplexity int) int
		ID          func(childComplexity int) int
		Investment  func(childComplexity int) int
		Price       func(childComplexity int) int
		UpdateTime  func(childComplexity int) int
	}

	LotConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LotEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Accounts              func(childComplexity int) int
		Currencies            func(childComplexity int) int
		FxRate                func(childComplexity int, from string, to string, datetime string) int
		Households            func(childComplexity int) int
		Investments           func(childComplexity int) int
		Lots                  func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *ent.LotWhereInput) int
		Node                  func(childComplexity int, id int) int
		Nodes                 func(childComplexity int, ids []int) int
		TransactionCategories func(childComplexity int) int
		TransactionEntries    func(childComplexity int) int
		Transactions          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		UserHouseholds        func(childComplexity int) int
	}

	Transaction struct {
		Category           func(childComplexity int) int
		CreateTime         func(childComplexity int) int
		Datetime           func(childComplexity int) int
		Description        func(childComplexity int) int
		Household          func(childComplexity int) int
		HouseholdID        func(childComplexity int) int
		ID                 func(childComplexity int) int
		TransactionEntries func(childComplexity int) int
		UpdateTime         func(childComplexity int) int
		User               func(childComplexity int) int
	}

	TransactionCategory struct {
		CreateTime   func(childComplexity int) int
		Household    func(childComplexity int) int
		HouseholdID  func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Transactions func(childComplexity int) int
		Type         func(childComplexity int) int
		UpdateTime   func(childComplexity int) int
	}

	TransactionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TransactionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TransactionEntry struct {
		Account     func(childComplexity int) int
		Amount      func(childComplexity int) int
		CreateTime  func(childComplexity int) int
		Currency    func(childComplexity int) int
		Household   func(childComplexity int) int
		HouseholdID func(childComplexity int) int
		ID          func(childComplexity int) int
		Transaction func(childComplexity int) int
		UpdateTime  func(childComplexity int) int
	}

	User struct {
		Accounts       func(childComplexity int) int
		CreateTime     func(childComplexity int) int
		Email          func(childComplexity int) int
		Households     func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
		Transactions   func(childComplexity int) int
		UpdateTime     func(childComplexity int) int
		UserHouseholds func(childComplexity int) int
		UserKeys       func(childComplexity int) int
	}

	UserHousehold struct {
		CreateTime  func(childComplexity int) int
		Household   func(childComplexity int) int
		HouseholdID func(childComplexity int) int
		ID          func(childComplexity int) int
		Role        func(childComplexity int) int
		UpdateTime  func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	UserKey struct {
		CreateTime func(childComplexity int) int
		ID         func(childComplexity int) int
		Key        func(childComplexity int) int
		Provider   func(childComplexity int) int
		UpdateTime func(childComplexity int) int
		User       func(childComplexity int) int
	}
}

type AccountResolver interface {
	Balance(ctx context.Context, obj *ent.Account) (string, error)
	Value(ctx context.Context, obj *ent.Account) (string, error)
	FxRate(ctx context.Context, obj *ent.Account) (string, error)

	BalanceInHouseholdCurrency(ctx context.Context, obj *ent.Account) (string, error)
	ValueInHouseholdCurrency(ctx context.Context, obj *ent.Account) (string, error)
}
type InvestmentResolver interface {
	Amount(ctx context.Context, obj *ent.Investment) (string, error)
	Quote(ctx context.Context, obj *ent.Investment) (string, error)
	Value(ctx context.Context, obj *ent.Investment) (string, error)

	ValueInHouseholdCurrency(ctx context.Context, obj *ent.Investment) (string, error)
}
type LotResolver interface {
	Amount(ctx context.Context, obj *ent.Lot) (string, error)
	Price(ctx context.Context, obj *ent.Lot) (string, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id int) (ent.Noder, error)
	Nodes(ctx context.Context, ids []int) ([]ent.Noder, error)
	Accounts(ctx context.Context) ([]*ent.Account, error)
	Currencies(ctx context.Context) ([]*ent.Currency, error)
	Households(ctx context.Context) ([]*ent.Household, error)
	Investments(ctx context.Context) ([]*ent.Investment, error)
	Lots(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *ent.LotWhereInput) (*ent.LotConnection, error)
	Transactions(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) (*ent.TransactionConnection, error)
	TransactionCategories(ctx context.Context) ([]*ent.TransactionCategory, error)
	TransactionEntries(ctx context.Context) ([]*ent.TransactionEntry, error)
	UserHouseholds(ctx context.Context) ([]*ent.UserHousehold, error)
	FxRate(ctx context.Context, from string, to string, datetime string) (string, error)
}
type TransactionEntryResolver interface {
	Amount(ctx context.Context, obj *ent.TransactionEntry) (string, error)
}

type AccountWhereInputResolver interface {
	Balance(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	BalanceNeq(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	BalanceIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	BalanceNotIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	BalanceGt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	BalanceGte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	BalanceLt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	BalanceLte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	Value(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	ValueNeq(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	ValueIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	ValueNotIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	ValueGt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	ValueGte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	ValueLt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	ValueLte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRate(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRateNeq(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRateIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	FxRateNotIn(ctx context.Context, obj *ent.AccountWhereInput, data []string) error
	FxRateGt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRateGte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRateLt(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
	FxRateLte(ctx context.Context, obj *ent.AccountWhereInput, data *string) error
}
type InvestmentWhereInputResolver interface {
	Amount(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	AmountNeq(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	AmountIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	AmountNotIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	AmountGt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	AmountGte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	AmountLt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	AmountLte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	Quote(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	QuoteNeq(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	QuoteIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	QuoteNotIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	QuoteGt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	QuoteGte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	QuoteLt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	QuoteLte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	Value(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	ValueNeq(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	ValueIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	ValueNotIn(ctx context.Context, obj *ent.InvestmentWhereInput, data []string) error
	ValueGt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	ValueGte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	ValueLt(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
	ValueLte(ctx context.Context, obj *ent.InvestmentWhereInput, data *string) error
}
type LotWhereInputResolver interface {
	Amount(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	AmountNeq(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	AmountIn(ctx context.Context, obj *ent.LotWhereInput, data []string) error
	AmountNotIn(ctx context.Context, obj *ent.LotWhereInput, data []string) error
	AmountGt(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	AmountGte(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	AmountLt(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	AmountLte(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	Price(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	PriceNeq(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	PriceIn(ctx context.Context, obj *ent.LotWhereInput, data []string) error
	PriceNotIn(ctx context.Context, obj *ent.LotWhereInput, data []string) error
	PriceGt(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	PriceGte(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	PriceLt(ctx context.Context, obj *ent.LotWhereInput, data *string) error
	PriceLte(ctx context.Context, obj *ent.LotWhereInput, data *string) error
}
type TransactionEntryWhereInputResolver interface {
	Amount(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
	AmountNeq(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
	AmountIn(ctx context.Context, obj *ent.TransactionEntryWhereInput, data []string) error
	AmountNotIn(ctx context.Context, obj *ent.TransactionEntryWhereInput, data []string) error
	AmountGt(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
	AmountGte(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
	AmountLt(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
	AmountLte(ctx context.Context, obj *ent.TransactionEntryWhereInput, data *string) error
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Account.balance":
		if e.complexity.Account.Balance == nil {
			break
		}

		return e.complexity.Account.Balance(childComplexity), true
	case "Account.balanceInHouseholdCurrency":
		if e.complexity.Account.BalanceInHouseholdCurrency == nil {
			break
		}

		return e.complexity.Account.BalanceInHouseholdCurrency(childComplexity), true
	case "Account.createTime":
		if e.complexity.Account.CreateTime == nil {
			break
		}

		return e.complexity.Account.CreateTime(childComplexity), true
	case "Account.currency":
		if e.complexity.Account.Currency == nil {
			break
		}

		return e.complexity.Account.Currency(childComplexity), true
	case "Account.fxRate":
		if e.complexity.Account.FxRate == nil {
			break
		}

		return e.complexity.Account.FxRate(childComplexity), true
	case "Account.household":
		if e.complexity.Account.Household == nil {
			break
		}

		return e.complexity.Account.Household(childComplexity), true
	case "Account.householdID":
		if e.complexity.Account.HouseholdID == nil {
			break
		}

		return e.complexity.Account.HouseholdID(childComplexity), true
	case "Account.id":
		if e.complexity.Account.ID == nil {
			break
		}

		return e.complexity.Account.ID(childComplexity), true
	case "Account.investments":
		if e.complexity.Account.Investments == nil {
			break
		}

		return e.complexity.Account.Investments(childComplexity), true
	case "Account.name":
		if e.complexity.Account.Name == nil {
			break
		}

		return e.complexity.Account.Name(childComplexity), true
	case "Account.transactionEntries":
		if e.complexity.Account.TransactionEntries == nil {
			break
		}

		return e.complexity.Account.TransactionEntries(childComplexity), true
	case "Account.type":
		if e.complexity.Account.Type == nil {
			break
		}

		return e.complexity.Account.Type(childComplexity), true
	case "Account.updateTime":
		if e.complexity.Account.UpdateTime == nil {
			break
		}

		return e.complexity.Account.UpdateTime(childComplexity), true
	case "Account.user":
		if e.complexity.Account.User == nil {
			break
		}

		return e.complexity.Account.User(childComplexity), true
	case "Account.value":
		if e.complexity.Account.Value == nil {
			break
		}

		return e.complexity.Account.Value(childComplexity), true
	case "Account.valueInHouseholdCurrency":
		if e.complexity.Account.ValueInHouseholdCurrency == nil {
			break
		}

		return e.complexity.Account.ValueInHouseholdCurrency(childComplexity), true

	case "Currency.accounts":
		if e.complexity.Currency.Accounts == nil {
			break
		}

		return e.complexity.Currency.Accounts(childComplexity), true
	case "Currency.code":
		if e.complexity.Currency.Code == nil {
			break
		}

		return e.complexity.Currency.Code(childComplexity), true
	case "Currency.households":
		if e.complexity.Currency.Households == nil {
			break
		}

		return e.complexity.Currency.Households(childComplexity), true
	case "Currency.id":
		if e.complexity.Currency.ID == nil {
			break
		}

		return e.complexity.Currency.ID(childComplexity), true
	case "Currency.investments":
		if e.complexity.Currency.Investments == nil {
			break
		}

		return e.complexity.Currency.Investments(childComplexity), true
	case "Currency.transactionEntries":
		if e.complexity.Currency.TransactionEntries == nil {
			break
		}

		return e.complexity.Currency.TransactionEntries(childComplexity), true

	case "Household.accounts":
		if e.complexity.Household.Accounts == nil {
			break
		}

		return e.complexity.Household.Accounts(childComplexity), true
	case "Household.createTime":
		if e.complexity.Household.CreateTime == nil {
			break
		}

		return e.complexity.Household.CreateTime(childComplexity), true
	case "Household.currency":
		if e.complexity.Household.Currency == nil {
			break
		}

		return e.complexity.Household.Currency(childComplexity), true
	case "Household.id":
		if e.complexity.Household.ID == nil {
			break
		}

		return e.complexity.Household.ID(childComplexity), true
	case "Household.investments":
		if e.complexity.Household.Investments == nil {
			break
		}

		return e.complexity.Household.Investments(childComplexity), true
	case "Household.locale":
		if e.complexity.Household.Locale == nil {
			break
		}

		return e.complexity.Household.Locale(childComplexity), true
	case "Household.lots":
		if e.complexity.Household.Lots == nil {
			break
		}

		return e.complexity.Household.Lots(childComplexity), true
	case "Household.name":
		if e.complexity.Household.Name == nil {
			break
		}

		return e.complexity.Household.Name(childComplexity), true
	case "Household.transactionCategories":
		if e.complexity.Household.TransactionCategories == nil {
			break
		}

		return e.complexity.Household.TransactionCategories(childComplexity), true
	case "Household.transactionEntries":
		if e.complexity.Household.TransactionEntries == nil {
			break
		}

		return e.complexity.Household.TransactionEntries(childComplexity), true
	case "Household.transactions":
		if e.complexity.Household.Transactions == nil {
			break
		}

		return e.complexity.Household.Transactions(childComplexity), true
	case "Household.updateTime":
		if e.complexity.Household.UpdateTime == nil {
			break
		}

		return e.complexity.Household.UpdateTime(childComplexity), true
	case "Household.userHouseholds":
		if e.complexity.Household.UserHouseholds == nil {
			break
		}

		return e.complexity.Household.UserHouseholds(childComplexity), true
	case "Household.users":
		if e.complexity.Household.Users == nil {
			break
		}

		return e.complexity.Household.Users(childComplexity), true

	case "Investment.account":
		if e.complexity.Investment.Account == nil {
			break
		}

		return e.complexity.Investment.Account(childComplexity), true
	case "Investment.amount":
		if e.complexity.Investment.Amount == nil {
			break
		}

		return e.complexity.Investment.Amount(childComplexity), true
	case "Investment.createTime":
		if e.complexity.Investment.CreateTime == nil {
			break
		}

		return e.complexity.Investment.CreateTime(childComplexity), true
	case "Investment.currency":
		if e.complexity.Investment.Currency == nil {
			break
		}

		return e.complexity.Investment.Currency(childComplexity), true
	case "Investment.household":
		if e.complexity.Investment.Household == nil {
			break
		}

		return e.complexity.Investment.Household(childComplexity), true
	case "Investment.householdID":
		if e.complexity.Investment.HouseholdID == nil {
			break
		}

		return e.complexity.Investment.HouseholdID(childComplexity), true
	case "Investment.id":
		if e.complexity.Investment.ID == nil {
			break
		}

		return e.complexity.Investment.ID(childComplexity), true
	case "Investment.lots":
		if e.complexity.Investment.Lots == nil {
			break
		}

		return e.complexity.Investment.Lots(childComplexity), true
	case "Investment.name":
		if e.complexity.Investment.Name == nil {
			break
		}

		return e.complexity.Investment.Name(childComplexity), true
	case "Investment.quote":
		if e.complexity.Investment.Quote == nil {
			break
		}

		return e.complexity.Investment.Quote(childComplexity), true
	case "Investment.symbol":
		if e.complexity.Investment.Symbol == nil {
			break
		}

		return e.complexity.Investment.Symbol(childComplexity), true
	case "Investment.type":
		if e.complexity.Investment.Type == nil {
			break
		}

		return e.complexity.Investment.Type(childComplexity), true
	case "Investment.updateTime":
		if e.complexity.Investment.UpdateTime == nil {
			break
		}

		return e.complexity.Investment.UpdateTime(childComplexity), true
	case "Investment.value":
		if e.complexity.Investment.Value == nil {
			break
		}

		return e.complexity.Investment.Value(childComplexity), true
	case "Investment.valueInHouseholdCurrency":
		if e.complexity.Investment.ValueInHouseholdCurrency == nil {
			break
		}

		return e.complexity.Investment.ValueInHouseholdCurrency(childComplexity), true

	case "Lot.amount":
		if e.complexity.Lot.Amount == nil {
			break
		}

		return e.complexity.Lot.Amount(childComplexity), true
	case "Lot.createTime":
		if e.complexity.Lot.CreateTime == nil {
			break
		}

		return e.complexity.Lot.CreateTime(childComplexity), true
	case "Lot.datetime":
		if e.complexity.Lot.Datetime == nil {
			break
		}

		return e.complexity.Lot.Datetime(childComplexity), true
	case "Lot.household":
		if e.complexity.Lot.Household == nil {
			break
		}

		return e.complexity.Lot.Household(childComplexity), true
	case "Lot.householdID":
		if e.complexity.Lot.HouseholdID == nil {
			break
		}

		return e.complexity.Lot.HouseholdID(childComplexity), true
	case "Lot.id":
		if e.complexity.Lot.ID == nil {
			break
		}

		return e.complexity.Lot.ID(childComplexity), true
	case "Lot.investment":
		if e.complexity.Lot.Investment == nil {
			break
		}

		return e.complexity.Lot.Investment(childComplexity), true
	case "Lot.price":
		if e.complexity.Lot.Price == nil {
			break
		}

		return e.complexity.Lot.Price(childComplexity), true
	case "Lot.updateTime":
		if e.complexity.Lot.UpdateTime == nil {
			break
		}

		return e.complexity.Lot.UpdateTime(childComplexity), true

	case "LotConnection.edges":
		if e.complexity.LotConnection.Edges == nil {
			break
		}

		return e.complexity.LotConnection.Edges(childComplexity), true
	case "LotConnection.pageInfo":
		if e.complexity.LotConnection.PageInfo == nil {
			break
		}

		return e.complexity.LotConnection.PageInfo(childComplexity), true
	case "LotConnection.totalCount":
		if e.complexity.LotConnection.TotalCount == nil {
			break
		}

		return e.complexity.LotConnection.TotalCount(childComplexity), true

	case "LotEdge.cursor":
		if e.complexity.LotEdge.Cursor == nil {
			break
		}

		return e.complexity.LotEdge.Cursor(childComplexity), true
	case "LotEdge.node":
		if e.complexity.LotEdge.Node == nil {
			break
		}

		return e.complexity.LotEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true
	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true
	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true
	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.accounts":
		if e.complexity.Query.Accounts == nil {
			break
		}

		return e.complexity.Query.Accounts(childComplexity), true
	case "Query.currencies":
		if e.complexity.Query.Currencies == nil {
			break
		}

		return e.complexity.Query.Currencies(childComplexity), true
	case "Query.fxRate":
		if e.complexity.Query.FxRate == nil {
			break
		}

		args, err := ec.field_Query_fxRate_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FxRate(childComplexity, args["from"].(string), args["to"].(string), args["datetime"].(string)), true
	case "Query.households":
		if e.complexity.Query.Households == nil {
			break
		}

		return e.complexity.Query.Households(childComplexity), true
	case "Query.investments":
		if e.complexity.Query.Investments == nil {
			break
		}

		return e.complexity.Query.Investments(childComplexity), true
	case "Query.lots":
		if e.complexity.Query.Lots == nil {
			break
		}

		args, err := ec.field_Query_lots_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Lots(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["where"].(*ent.LotWhereInput)), true
	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true
	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true
	case "Query.transactionCategories":
		if e.complexity.Query.TransactionCategories == nil {
			break
		}

		return e.complexity.Query.TransactionCategories(childComplexity), true
	case "Query.transactionEntries":
		if e.complexity.Query.TransactionEntries == nil {
			break
		}

		return e.complexity.Query.TransactionEntries(childComplexity), true
	case "Query.transactions":
		if e.complexity.Query.Transactions == nil {
			break
		}

		args, err := ec.field_Query_transactions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transactions(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true
	case "Query.userHouseholds":
		if e.complexity.Query.UserHouseholds == nil {
			break
		}

		return e.complexity.Query.UserHouseholds(childComplexity), true

	case "Transaction.category":
		if e.complexity.Transaction.Category == nil {
			break
		}

		return e.complexity.Transaction.Category(childComplexity), true
	case "Transaction.createTime":
		if e.complexity.Transaction.CreateTime == nil {
			break
		}

		return e.complexity.Transaction.CreateTime(childComplexity), true
	case "Transaction.datetime":
		if e.complexity.Transaction.Datetime == nil {
			break
		}

		return e.complexity.Transaction.Datetime(childComplexity), true
	case "Transaction.description":
		if e.complexity.Transaction.Description == nil {
			break
		}

		return e.complexity.Transaction.Description(childComplexity), true
	case "Transaction.household":
		if e.complexity.Transaction.Household == nil {
			break
		}

		return e.complexity.Transaction.Household(childComplexity), true
	case "Transaction.householdID":
		if e.complexity.Transaction.HouseholdID == nil {
			break
		}

		return e.complexity.Transaction.HouseholdID(childComplexity), true
	case "Transaction.id":
		if e.complexity.Transaction.ID == nil {
			break
		}

		return e.complexity.Transaction.ID(childComplexity), true
	case "Transaction.transactionEntries":
		if e.complexity.Transaction.TransactionEntries == nil {
			break
		}

		return e.complexity.Transaction.TransactionEntries(childComplexity), true
	case "Transaction.updateTime":
		if e.complexity.Transaction.UpdateTime == nil {
			break
		}

		return e.complexity.Transaction.UpdateTime(childComplexity), true
	case "Transaction.user":
		if e.complexity.Transaction.User == nil {
			break
		}

		return e.complexity.Transaction.User(childComplexity), true

	case "TransactionCategory.createTime":
		if e.complexity.TransactionCategory.CreateTime == nil {
			break
		}

		return e.complexity.TransactionCategory.CreateTime(childComplexity), true
	case "TransactionCategory.household":
		if e.complexity.TransactionCategory.Household == nil {
			break
		}

		return e.complexity.TransactionCategory.Household(childComplexity), true
	case "TransactionCategory.householdID":
		if e.complexity.TransactionCategory.HouseholdID == nil {
			break
		}

		return e.complexity.TransactionCategory.HouseholdID(childComplexity), true
	case "TransactionCategory.id":
		if e.complexity.TransactionCategory.ID == nil {
			break
		}

		return e.complexity.TransactionCategory.ID(childComplexity), true
	case "TransactionCategory.name":
		if e.complexity.TransactionCategory.Name == nil {
			break
		}

		return e.complexity.TransactionCategory.Name(childComplexity), true
	case "TransactionCategory.transactions":
		if e.complexity.TransactionCategory.Transactions == nil {
			break
		}

		return e.complexity.TransactionCategory.Transactions(childComplexity), true
	case "TransactionCategory.type":
		if e.complexity.TransactionCategory.Type == nil {
			break
		}

		return e.complexity.TransactionCategory.Type(childComplexity), true
	case "TransactionCategory.updateTime":
		if e.complexity.TransactionCategory.UpdateTime == nil {
			break
		}

		return e.complexity.TransactionCategory.UpdateTime(childComplexity), true

	case "TransactionConnection.edges":
		if e.complexity.TransactionConnection.Edges == nil {
			break
		}

		return e.complexity.TransactionConnection.Edges(childComplexity), true
	case "TransactionConnection.pageInfo":
		if e.complexity.TransactionConnection.PageInfo == nil {
			break
		}

		return e.complexity.TransactionConnection.PageInfo(childComplexity), true
	case "TransactionConnection.totalCount":
		if e.complexity.TransactionConnection.TotalCount == nil {
			break
		}

		return e.complexity.TransactionConnection.TotalCount(childComplexity), true

	case "TransactionEdge.cursor":
		if e.complexity.TransactionEdge.Cursor == nil {
			break
		}

		return e.complexity.TransactionEdge.Cursor(childComplexity), true
	case "TransactionEdge.node":
		if e.complexity.TransactionEdge.Node == nil {
			break
		}

		return e.complexity.TransactionEdge.Node(childComplexity), true

	case "TransactionEntry.account":
		if e.complexity.TransactionEntry.Account == nil {
			break
		}

		return e.complexity.TransactionEntry.Account(childComplexity), true
	case "TransactionEntry.amount":
		if e.complexity.TransactionEntry.Amount == nil {
			break
		}

		return e.complexity.TransactionEntry.Amount(childComplexity), true
	case "TransactionEntry.createTime":
		if e.complexity.TransactionEntry.CreateTime == nil {
			break
		}

		return e.complexity.TransactionEntry.CreateTime(childComplexity), true
	case "TransactionEntry.currency":
		if e.complexity.TransactionEntry.Currency == nil {
			break
		}

		return e.complexity.TransactionEntry.Currency(childComplexity), true
	case "TransactionEntry.household":
		if e.complexity.TransactionEntry.Household == nil {
			break
		}

		return e.complexity.TransactionEntry.Household(childComplexity), true
	case "TransactionEntry.householdID":
		if e.complexity.TransactionEntry.HouseholdID == nil {
			break
		}

		return e.complexity.TransactionEntry.HouseholdID(childComplexity), true
	case "TransactionEntry.id":
		if e.complexity.TransactionEntry.ID == nil {
			break
		}

		return e.complexity.TransactionEntry.ID(childComplexity), true
	case "TransactionEntry.transaction":
		if e.complexity.TransactionEntry.Transaction == nil {
			break
		}

		return e.complexity.TransactionEntry.Transaction(childComplexity), true
	case "TransactionEntry.updateTime":
		if e.complexity.TransactionEntry.UpdateTime == nil {
			break
		}

		return e.complexity.TransactionEntry.UpdateTime(childComplexity), true

	case "User.accounts":
		if e.complexity.User.Accounts == nil {
			break
		}

		return e.complexity.User.Accounts(childComplexity), true
	case "User.createTime":
		if e.complexity.User.CreateTime == nil {
			break
		}

		return e.complexity.User.CreateTime(childComplexity), true
	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true
	case "User.households":
		if e.complexity.User.Households == nil {
			break
		}

		return e.complexity.User.Households(childComplexity), true
	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true
	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true
	case "User.transactions":
		if e.complexity.User.Transactions == nil {
			break
		}

		return e.complexity.User.Transactions(childComplexity), true
	case "User.updateTime":
		if e.complexity.User.UpdateTime == nil {
			break
		}

		return e.complexity.User.UpdateTime(childComplexity), true
	case "User.userHouseholds":
		if e.complexity.User.UserHouseholds == nil {
			break
		}

		return e.complexity.User.UserHouseholds(childComplexity), true
	case "User.userKeys":
		if e.complexity.User.UserKeys == nil {
			break
		}

		return e.complexity.User.UserKeys(childComplexity), true

	case "UserHousehold.createTime":
		if e.complexity.UserHousehold.CreateTime == nil {
			break
		}

		return e.complexity.UserHousehold.CreateTime(childComplexity), true
	case "UserHousehold.household":
		if e.complexity.UserHousehold.Household == nil {
			break
		}

		return e.complexity.UserHousehold.Household(childComplexity), true
	case "UserHousehold.householdID":
		if e.complexity.UserHousehold.HouseholdID == nil {
			break
		}

		return e.complexity.UserHousehold.HouseholdID(childComplexity), true
	case "UserHousehold.id":
		if e.complexity.UserHousehold.ID == nil {
			break
		}

		return e.complexity.UserHousehold.ID(childComplexity), true
	case "UserHousehold.role":
		if e.complexity.UserHousehold.Role == nil {
			break
		}

		return e.complexity.UserHousehold.Role(childComplexity), true
	case "UserHousehold.updateTime":
		if e.complexity.UserHousehold.UpdateTime == nil {
			break
		}

		return e.complexity.UserHousehold.UpdateTime(childComplexity), true
	case "UserHousehold.user":
		if e.complexity.UserHousehold.User == nil {
			break
		}

		return e.complexity.UserHousehold.User(childComplexity), true
	case "UserHousehold.userID":
		if e.complexity.UserHousehold.UserID == nil {
			break
		}

		return e.complexity.UserHousehold.UserID(childComplexity), true

	case "UserKey.createTime":
		if e.complexity.UserKey.CreateTime == nil {
			break
		}

		return e.complexity.UserKey.CreateTime(childComplexity), true
	case "UserKey.id":
		if e.complexity.UserKey.ID == nil {
			break
		}

		return e.complexity.UserKey.ID(childComplexity), true
	case "UserKey.key":
		if e.complexity.UserKey.Key == nil {
			break
		}

		return e.complexity.UserKey.Key(childComplexity), true
	case "UserKey.provider":
		if e.complexity.UserKey.Provider == nil {
			break
		}

		return e.complexity.UserKey.Provider(childComplexity), true
	case "UserKey.updateTime":
		if e.complexity.UserKey.UpdateTime == nil {
			break
		}

		return e.complexity.UserKey.UpdateTime(childComplexity), true
	case "UserKey.user":
		if e.complexity.UserKey.User == nil {
			break
		}

		return e.complexity.UserKey.User(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAccountWhereInput,
		ec.unmarshalInputCurrencyWhereInput,
		ec.unmarshalInputHouseholdWhereInput,
		ec.unmarshalInputInvestmentWhereInput,
		ec.unmarshalInputLotWhereInput,
		ec.unmarshalInputTransactionCategoryWhereInput,
		ec.unmarshalInputTransactionEntryWhereInput,
		ec.unmarshalInputTransactionOrder,
		ec.unmarshalInputTransactionWhereInput,
		ec.unmarshalInputUserHouseholdWhereInput,
		ec.unmarshalInputUserKeyWhereInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "ent.graphql" "fijoy.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "ent.graphql", Input: sourceData("ent.graphql"), BuiltIn: false},
	{Name: "fijoy.graphql", Input: sourceData("fijoy.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fxRate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "from", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["from"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "to", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["to"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "datetime", ec.unmarshalNDateTime2string)
	if err != nil {
		return nil, err
	}
	args["datetime"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_lots_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["last"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOLotWhereInput2ᚖfijoyᚗappᚋentᚐLotWhereInput)
	if err != nil {
		return nil, err
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2int)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2ᚕintᚄ)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_transactions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor)
	if err != nil {
		return nil, err
	}
	args["after"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "last", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["last"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "orderBy", ec.unmarshalOTransactionOrder2ᚖfijoyᚗappᚋentᚐTransactionOrder)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	arg5, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOTransactionWhereInput2ᚖfijoyᚗappᚋentᚐTransactionWhereInput)
	if err != nil {
		return nil, err
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Account_id(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_name(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_type(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNAccountType2fijoyᚗappᚋentᚋaccountᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AccountType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_balance(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_balance,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Account().Balance(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_balance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_value(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_value,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Account().Value(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_fxRate(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_fxRate,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Account().FxRate(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_fxRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_household(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2ᚖfijoyᚗappᚋentᚐHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "lots":
				return ec.fieldContext_Household_lots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_currency(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_currency,
		func(ctx context.Context) (any, error) {
			return obj.Currency(ctx)
		},
		nil,
		ec.marshalNCurrency2ᚖfijoyᚗappᚋentᚐCurrency,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "code":
				return ec.fieldContext_Currency_code(ctx, field)
			case "accounts":
				return ec.fieldContext_Currency_accounts(ctx, field)
			case "investments":
				return ec.fieldContext_Currency_investments(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Currency_transactionEntries(ctx, field)
			case "households":
				return ec.fieldContext_Currency_households(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_user(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_user,
		func(ctx context.Context) (any, error) {
			return obj.User(ctx)
		},
		nil,
		ec.marshalNUser2ᚖfijoyᚗappᚋentᚐUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "households":
				return ec.fieldContext_User_households(ctx, field)
			case "accounts":
				return ec.fieldContext_User_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_User_transactions(ctx, field)
			case "userKeys":
				return ec.fieldContext_User_userKeys(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_User_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_transactionEntries(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_transactionEntries,
		func(ctx context.Context) (any, error) {
			return obj.TransactionEntries(ctx)
		},
		nil,
		ec.marshalOTransactionEntry2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Account_transactionEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionEntry_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionEntry_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionEntry_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionEntry_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_TransactionEntry_amount(ctx, field)
			case "household":
				return ec.fieldContext_TransactionEntry_household(ctx, field)
			case "account":
				return ec.fieldContext_TransactionEntry_account(ctx, field)
			case "currency":
				return ec.fieldContext_TransactionEntry_currency(ctx, field)
			case "transaction":
				return ec.fieldContext_TransactionEntry_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_investments(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_investments,
		func(ctx context.Context) (any, error) {
			return obj.Investments(ctx)
		},
		nil,
		ec.marshalOInvestment2ᚕᚖfijoyᚗappᚋentᚐInvestmentᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Account_investments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Investment_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Investment_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Investment_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Investment_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Investment_name(ctx, field)
			case "type":
				return ec.fieldContext_Investment_type(ctx, field)
			case "symbol":
				return ec.fieldContext_Investment_symbol(ctx, field)
			case "amount":
				return ec.fieldContext_Investment_amount(ctx, field)
			case "quote":
				return ec.fieldContext_Investment_quote(ctx, field)
			case "value":
				return ec.fieldContext_Investment_value(ctx, field)
			case "account":
				return ec.fieldContext_Investment_account(ctx, field)
			case "household":
				return ec.fieldContext_Investment_household(ctx, field)
			case "currency":
				return ec.fieldContext_Investment_currency(ctx, field)
			case "lots":
				return ec.fieldContext_Investment_lots(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Investment_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Investment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_balanceInHouseholdCurrency(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_balanceInHouseholdCurrency,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Account().BalanceInHouseholdCurrency(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_balanceInHouseholdCurrency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_valueInHouseholdCurrency(ctx context.Context, field graphql.CollectedField, obj *ent.Account) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Account_valueInHouseholdCurrency,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Account().ValueInHouseholdCurrency(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Account_valueInHouseholdCurrency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_id(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Currency_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_code(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_code,
		func(ctx context.Context) (any, error) {
			return obj.Code, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Currency_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_accounts(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_accounts,
		func(ctx context.Context) (any, error) {
			return obj.Accounts(ctx)
		},
		nil,
		ec.marshalOAccount2ᚕᚖfijoyᚗappᚋentᚐAccountᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Currency_accounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_investments(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_investments,
		func(ctx context.Context) (any, error) {
			return obj.Investments(ctx)
		},
		nil,
		ec.marshalOInvestment2ᚕᚖfijoyᚗappᚋentᚐInvestmentᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Currency_investments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Investment_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Investment_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Investment_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Investment_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Investment_name(ctx, field)
			case "type":
				return ec.fieldContext_Investment_type(ctx, field)
			case "symbol":
				return ec.fieldContext_Investment_symbol(ctx, field)
			case "amount":
				return ec.fieldContext_Investment_amount(ctx, field)
			case "quote":
				return ec.fieldContext_Investment_quote(ctx, field)
			case "value":
				return ec.fieldContext_Investment_value(ctx, field)
			case "account":
				return ec.fieldContext_Investment_account(ctx, field)
			case "household":
				return ec.fieldContext_Investment_household(ctx, field)
			case "currency":
				return ec.fieldContext_Investment_currency(ctx, field)
			case "lots":
				return ec.fieldContext_Investment_lots(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Investment_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Investment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_transactionEntries(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_transactionEntries,
		func(ctx context.Context) (any, error) {
			return obj.TransactionEntries(ctx)
		},
		nil,
		ec.marshalOTransactionEntry2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Currency_transactionEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionEntry_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionEntry_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionEntry_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionEntry_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_TransactionEntry_amount(ctx, field)
			case "household":
				return ec.fieldContext_TransactionEntry_household(ctx, field)
			case "account":
				return ec.fieldContext_TransactionEntry_account(ctx, field)
			case "currency":
				return ec.fieldContext_TransactionEntry_currency(ctx, field)
			case "transaction":
				return ec.fieldContext_TransactionEntry_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_households(ctx context.Context, field graphql.CollectedField, obj *ent.Currency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Currency_households,
		func(ctx context.Context) (any, error) {
			return obj.Households(ctx)
		},
		nil,
		ec.marshalOHousehold2ᚕᚖfijoyᚗappᚋentᚐHouseholdᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Currency_households(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "lots":
				return ec.fieldContext_Household_lots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_id(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_name(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_locale(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_locale,
		func(ctx context.Context) (any, error) {
			return obj.Locale, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_locale(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_currency(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_currency,
		func(ctx context.Context) (any, error) {
			return obj.Currency(ctx)
		},
		nil,
		ec.marshalNCurrency2ᚖfijoyᚗappᚋentᚐCurrency,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Household_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "code":
				return ec.fieldContext_Currency_code(ctx, field)
			case "accounts":
				return ec.fieldContext_Currency_accounts(ctx, field)
			case "investments":
				return ec.fieldContext_Currency_investments(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Currency_transactionEntries(ctx, field)
			case "households":
				return ec.fieldContext_Currency_households(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_users(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_users,
		func(ctx context.Context) (any, error) {
			return obj.Users(ctx)
		},
		nil,
		ec.marshalOUser2ᚕᚖfijoyᚗappᚋentᚐUserᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "households":
				return ec.fieldContext_User_households(ctx, field)
			case "accounts":
				return ec.fieldContext_User_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_User_transactions(ctx, field)
			case "userKeys":
				return ec.fieldContext_User_userKeys(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_User_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_accounts(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_accounts,
		func(ctx context.Context) (any, error) {
			return obj.Accounts(ctx)
		},
		nil,
		ec.marshalOAccount2ᚕᚖfijoyᚗappᚋentᚐAccountᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_accounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_transactions(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_transactions,
		func(ctx context.Context) (any, error) {
			return obj.Transactions(ctx)
		},
		nil,
		ec.marshalOTransaction2ᚕᚖfijoyᚗappᚋentᚐTransactionᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_transactions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_investments(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_investments,
		func(ctx context.Context) (any, error) {
			return obj.Investments(ctx)
		},
		nil,
		ec.marshalOInvestment2ᚕᚖfijoyᚗappᚋentᚐInvestmentᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_investments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Investment_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Investment_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Investment_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Investment_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Investment_name(ctx, field)
			case "type":
				return ec.fieldContext_Investment_type(ctx, field)
			case "symbol":
				return ec.fieldContext_Investment_symbol(ctx, field)
			case "amount":
				return ec.fieldContext_Investment_amount(ctx, field)
			case "quote":
				return ec.fieldContext_Investment_quote(ctx, field)
			case "value":
				return ec.fieldContext_Investment_value(ctx, field)
			case "account":
				return ec.fieldContext_Investment_account(ctx, field)
			case "household":
				return ec.fieldContext_Investment_household(ctx, field)
			case "currency":
				return ec.fieldContext_Investment_currency(ctx, field)
			case "lots":
				return ec.fieldContext_Investment_lots(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Investment_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Investment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_lots(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_lots,
		func(ctx context.Context) (any, error) {
			return obj.Lots(ctx)
		},
		nil,
		ec.marshalOLot2ᚕᚖfijoyᚗappᚋentᚐLotᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_lots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lot_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Lot_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Lot_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Lot_householdID(ctx, field)
			case "datetime":
				return ec.fieldContext_Lot_datetime(ctx, field)
			case "amount":
				return ec.fieldContext_Lot_amount(ctx, field)
			case "price":
				return ec.fieldContext_Lot_price(ctx, field)
			case "household":
				return ec.fieldContext_Lot_household(ctx, field)
			case "investment":
				return ec.fieldContext_Lot_investment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_transactionCategories(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_transactionCategories,
		func(ctx context.Context) (any, error) {
			return obj.TransactionCategories(ctx)
		},
		nil,
		ec.marshalOTransactionCategory2ᚕᚖfijoyᚗappᚋentᚐTransactionCategoryᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_transactionCategories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionCategory_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionCategory_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionCategory_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionCategory_householdID(ctx, field)
			case "name":
				return ec.fieldContext_TransactionCategory_name(ctx, field)
			case "type":
				return ec.fieldContext_TransactionCategory_type(ctx, field)
			case "household":
				return ec.fieldContext_TransactionCategory_household(ctx, field)
			case "transactions":
				return ec.fieldContext_TransactionCategory_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_transactionEntries(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_transactionEntries,
		func(ctx context.Context) (any, error) {
			return obj.TransactionEntries(ctx)
		},
		nil,
		ec.marshalOTransactionEntry2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_transactionEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionEntry_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionEntry_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionEntry_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionEntry_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_TransactionEntry_amount(ctx, field)
			case "household":
				return ec.fieldContext_TransactionEntry_household(ctx, field)
			case "account":
				return ec.fieldContext_TransactionEntry_account(ctx, field)
			case "currency":
				return ec.fieldContext_TransactionEntry_currency(ctx, field)
			case "transaction":
				return ec.fieldContext_TransactionEntry_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Household_userHouseholds(ctx context.Context, field graphql.CollectedField, obj *ent.Household) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Household_userHouseholds,
		func(ctx context.Context) (any, error) {
			return obj.UserHouseholds(ctx)
		},
		nil,
		ec.marshalOUserHousehold2ᚕᚖfijoyᚗappᚋentᚐUserHouseholdᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Household_userHouseholds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Household",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserHousehold_id(ctx, field)
			case "createTime":
				return ec.fieldContext_UserHousehold_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_UserHousehold_updateTime(ctx, field)
			case "userID":
				return ec.fieldContext_UserHousehold_userID(ctx, field)
			case "householdID":
				return ec.fieldContext_UserHousehold_householdID(ctx, field)
			case "role":
				return ec.fieldContext_UserHousehold_role(ctx, field)
			case "user":
				return ec.fieldContext_UserHousehold_user(ctx, field)
			case "household":
				return ec.fieldContext_UserHousehold_household(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserHousehold", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_id(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_name(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_type(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNInvestmentType2fijoyᚗappᚋentᚋinvestmentᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type InvestmentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_symbol(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_symbol,
		func(ctx context.Context) (any, error) {
			return obj.Symbol, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_symbol(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_amount(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_amount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Investment().Amount(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_quote(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_quote,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Investment().Quote(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_quote(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_value(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_value,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Investment().Value(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_account(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_account,
		func(ctx context.Context) (any, error) {
			return obj.Account(ctx)
		},
		nil,
		ec.marshalNAccount2ᚖfijoyᚗappᚋentᚐAccount,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_household(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2ᚖfijoyᚗappᚋentᚐHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "lots":
				return ec.fieldContext_Household_lots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_currency(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_currency,
		func(ctx context.Context) (any, error) {
			return obj.Currency(ctx)
		},
		nil,
		ec.marshalNCurrency2ᚖfijoyᚗappᚋentᚐCurrency,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "code":
				return ec.fieldContext_Currency_code(ctx, field)
			case "accounts":
				return ec.fieldContext_Currency_accounts(ctx, field)
			case "investments":
				return ec.fieldContext_Currency_investments(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Currency_transactionEntries(ctx, field)
			case "households":
				return ec.fieldContext_Currency_households(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_lots(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_lots,
		func(ctx context.Context) (any, error) {
			return obj.Lots(ctx)
		},
		nil,
		ec.marshalOLot2ᚕᚖfijoyᚗappᚋentᚐLotᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Investment_lots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lot_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Lot_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Lot_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Lot_householdID(ctx, field)
			case "datetime":
				return ec.fieldContext_Lot_datetime(ctx, field)
			case "amount":
				return ec.fieldContext_Lot_amount(ctx, field)
			case "price":
				return ec.fieldContext_Lot_price(ctx, field)
			case "household":
				return ec.fieldContext_Lot_household(ctx, field)
			case "investment":
				return ec.fieldContext_Lot_investment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Investment_valueInHouseholdCurrency(ctx context.Context, field graphql.CollectedField, obj *ent.Investment) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Investment_valueInHouseholdCurrency,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Investment().ValueInHouseholdCurrency(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Investment_valueInHouseholdCurrency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Investment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lot_id(ctx context.Context, field graphql.CollectedField, obj *ent.Lot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Lot_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Lot_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lot_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Lot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Lot_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Lot_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lot_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Lot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Lot_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Lot_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lot_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.Lot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Lot_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Lot_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lot_datetime(ctx context.Context, field graphql.CollectedField, obj *ent.Lot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Lot_datetime,
		func(ctx context.Context) (any, error) {
			return obj.Datetime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Lot_datetime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lot_amount(ctx context.Context, field graphql.CollectedField, obj *ent.Lot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Lot_amount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Lot().Amount(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Lot_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lot",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lot_price(ctx context.Context, field graphql.CollectedField, obj *ent.Lot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Lot_price,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Lot().Price(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Lot_price(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lot",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lot_household(ctx context.Context, field graphql.CollectedField, obj *ent.Lot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Lot_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2ᚖfijoyᚗappᚋentᚐHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Lot_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lot",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "lots":
				return ec.fieldContext_Household_lots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lot_investment(ctx context.Context, field graphql.CollectedField, obj *ent.Lot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Lot_investment,
		func(ctx context.Context) (any, error) {
			return obj.Investment(ctx)
		},
		nil,
		ec.marshalNInvestment2ᚖfijoyᚗappᚋentᚐInvestment,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Lot_investment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lot",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Investment_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Investment_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Investment_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Investment_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Investment_name(ctx, field)
			case "type":
				return ec.fieldContext_Investment_type(ctx, field)
			case "symbol":
				return ec.fieldContext_Investment_symbol(ctx, field)
			case "amount":
				return ec.fieldContext_Investment_amount(ctx, field)
			case "quote":
				return ec.fieldContext_Investment_quote(ctx, field)
			case "value":
				return ec.fieldContext_Investment_value(ctx, field)
			case "account":
				return ec.fieldContext_Investment_account(ctx, field)
			case "household":
				return ec.fieldContext_Investment_household(ctx, field)
			case "currency":
				return ec.fieldContext_Investment_currency(ctx, field)
			case "lots":
				return ec.fieldContext_Investment_lots(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Investment_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Investment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LotConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.LotConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LotConnection_edges,
		func(ctx context.Context) (any, error) {
			return obj.Edges, nil
		},
		nil,
		ec.marshalOLotEdge2ᚕᚖfijoyᚗappᚋentᚐLotEdge,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LotConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LotConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LotEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LotEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LotEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LotConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.LotConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LotConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LotConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LotConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LotConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.LotConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LotConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LotConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LotConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LotEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.LotEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LotEdge_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalOLot2ᚖfijoyᚗappᚋentᚐLot,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LotEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LotEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lot_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Lot_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Lot_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Lot_householdID(ctx, field)
			case "datetime":
				return ec.fieldContext_Lot_datetime(ctx, field)
			case "amount":
				return ec.fieldContext_Lot_amount(ctx, field)
			case "price":
				return ec.fieldContext_Lot_price(ctx, field)
			case "household":
				return ec.fieldContext_Lot_household(ctx, field)
			case "investment":
				return ec.fieldContext_Lot_investment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LotEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.LotEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LotEdge_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LotEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LotEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PageInfo_hasNextPage,
		func(ctx context.Context) (any, error) {
			return obj.HasNextPage, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PageInfo_hasPreviousPage,
		func(ctx context.Context) (any, error) {
			return obj.HasPreviousPage, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PageInfo_startCursor,
		func(ctx context.Context) (any, error) {
			return obj.StartCursor, nil
		},
		nil,
		ec.marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PageInfo_endCursor,
		func(ctx context.Context) (any, error) {
			return obj.EndCursor, nil
		},
		nil,
		ec.marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_node,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Node(ctx, fc.Args["id"].(int))
		},
		nil,
		ec.marshalONode2fijoyᚗappᚋentᚐNoder,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_nodes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Nodes(ctx, fc.Args["ids"].([]int))
		},
		nil,
		ec.marshalNNode2ᚕfijoyᚗappᚋentᚐNoder,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_accounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_accounts,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Accounts(ctx)
		},
		nil,
		ec.marshalNAccount2ᚕᚖfijoyᚗappᚋentᚐAccountᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_accounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_currencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_currencies,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Currencies(ctx)
		},
		nil,
		ec.marshalNCurrency2ᚕᚖfijoyᚗappᚋentᚐCurrencyᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_currencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "code":
				return ec.fieldContext_Currency_code(ctx, field)
			case "accounts":
				return ec.fieldContext_Currency_accounts(ctx, field)
			case "investments":
				return ec.fieldContext_Currency_investments(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Currency_transactionEntries(ctx, field)
			case "households":
				return ec.fieldContext_Currency_households(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_households(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_households,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Households(ctx)
		},
		nil,
		ec.marshalNHousehold2ᚕᚖfijoyᚗappᚋentᚐHouseholdᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_households(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "lots":
				return ec.fieldContext_Household_lots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_investments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_investments,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Investments(ctx)
		},
		nil,
		ec.marshalNInvestment2ᚕᚖfijoyᚗappᚋentᚐInvestmentᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_investments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Investment_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Investment_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Investment_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Investment_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Investment_name(ctx, field)
			case "type":
				return ec.fieldContext_Investment_type(ctx, field)
			case "symbol":
				return ec.fieldContext_Investment_symbol(ctx, field)
			case "amount":
				return ec.fieldContext_Investment_amount(ctx, field)
			case "quote":
				return ec.fieldContext_Investment_quote(ctx, field)
			case "value":
				return ec.fieldContext_Investment_value(ctx, field)
			case "account":
				return ec.fieldContext_Investment_account(ctx, field)
			case "household":
				return ec.fieldContext_Investment_household(ctx, field)
			case "currency":
				return ec.fieldContext_Investment_currency(ctx, field)
			case "lots":
				return ec.fieldContext_Investment_lots(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Investment_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Investment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_lots(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_lots,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Lots(ctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["where"].(*ent.LotWhereInput))
		},
		nil,
		ec.marshalNLotConnection2ᚖfijoyᚗappᚋentᚐLotConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_lots(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LotConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LotConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LotConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LotConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_lots_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_transactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_transactions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Transactions(ctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.TransactionOrder), fc.Args["where"].(*ent.TransactionWhereInput))
		},
		nil,
		ec.marshalNTransactionConnection2ᚖfijoyᚗappᚋentᚐTransactionConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TransactionConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TransactionConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TransactionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_transactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_transactionCategories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_transactionCategories,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().TransactionCategories(ctx)
		},
		nil,
		ec.marshalNTransactionCategory2ᚕᚖfijoyᚗappᚋentᚐTransactionCategoryᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_transactionCategories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionCategory_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionCategory_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionCategory_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionCategory_householdID(ctx, field)
			case "name":
				return ec.fieldContext_TransactionCategory_name(ctx, field)
			case "type":
				return ec.fieldContext_TransactionCategory_type(ctx, field)
			case "household":
				return ec.fieldContext_TransactionCategory_household(ctx, field)
			case "transactions":
				return ec.fieldContext_TransactionCategory_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_transactionEntries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_transactionEntries,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().TransactionEntries(ctx)
		},
		nil,
		ec.marshalNTransactionEntry2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_transactionEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionEntry_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionEntry_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionEntry_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionEntry_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_TransactionEntry_amount(ctx, field)
			case "household":
				return ec.fieldContext_TransactionEntry_household(ctx, field)
			case "account":
				return ec.fieldContext_TransactionEntry_account(ctx, field)
			case "currency":
				return ec.fieldContext_TransactionEntry_currency(ctx, field)
			case "transaction":
				return ec.fieldContext_TransactionEntry_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_userHouseholds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_userHouseholds,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().UserHouseholds(ctx)
		},
		nil,
		ec.marshalNUserHousehold2ᚕᚖfijoyᚗappᚋentᚐUserHouseholdᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_userHouseholds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserHousehold_id(ctx, field)
			case "createTime":
				return ec.fieldContext_UserHousehold_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_UserHousehold_updateTime(ctx, field)
			case "userID":
				return ec.fieldContext_UserHousehold_userID(ctx, field)
			case "householdID":
				return ec.fieldContext_UserHousehold_householdID(ctx, field)
			case "role":
				return ec.fieldContext_UserHousehold_role(ctx, field)
			case "user":
				return ec.fieldContext_UserHousehold_user(ctx, field)
			case "household":
				return ec.fieldContext_UserHousehold_household(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserHousehold", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_fxRate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fxRate,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FxRate(ctx, fc.Args["from"].(string), fc.Args["to"].(string), fc.Args["datetime"].(string))
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_fxRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fxRate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_id(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_description(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Transaction_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_datetime(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_datetime,
		func(ctx context.Context) (any, error) {
			return obj.Datetime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_datetime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_user(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_user,
		func(ctx context.Context) (any, error) {
			return obj.User(ctx)
		},
		nil,
		ec.marshalNUser2ᚖfijoyᚗappᚋentᚐUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "households":
				return ec.fieldContext_User_households(ctx, field)
			case "accounts":
				return ec.fieldContext_User_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_User_transactions(ctx, field)
			case "userKeys":
				return ec.fieldContext_User_userKeys(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_User_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_household(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2ᚖfijoyᚗappᚋentᚐHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "lots":
				return ec.fieldContext_Household_lots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_category(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_category,
		func(ctx context.Context) (any, error) {
			return obj.Category(ctx)
		},
		nil,
		ec.marshalNTransactionCategory2ᚖfijoyᚗappᚋentᚐTransactionCategory,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Transaction_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionCategory_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionCategory_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionCategory_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionCategory_householdID(ctx, field)
			case "name":
				return ec.fieldContext_TransactionCategory_name(ctx, field)
			case "type":
				return ec.fieldContext_TransactionCategory_type(ctx, field)
			case "household":
				return ec.fieldContext_TransactionCategory_household(ctx, field)
			case "transactions":
				return ec.fieldContext_TransactionCategory_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_transactionEntries(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Transaction_transactionEntries,
		func(ctx context.Context) (any, error) {
			return obj.TransactionEntries(ctx)
		},
		nil,
		ec.marshalOTransactionEntry2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Transaction_transactionEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionEntry_id(ctx, field)
			case "createTime":
				return ec.fieldContext_TransactionEntry_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_TransactionEntry_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_TransactionEntry_householdID(ctx, field)
			case "amount":
				return ec.fieldContext_TransactionEntry_amount(ctx, field)
			case "household":
				return ec.fieldContext_TransactionEntry_household(ctx, field)
			case "account":
				return ec.fieldContext_TransactionEntry_account(ctx, field)
			case "currency":
				return ec.fieldContext_TransactionEntry_currency(ctx, field)
			case "transaction":
				return ec.fieldContext_TransactionEntry_transaction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_id(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_name(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_type(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNTransactionCategoryType2fijoyᚗappᚋentᚋtransactioncategoryᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TransactionCategoryType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_household(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2ᚖfijoyᚗappᚋentᚐHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "lots":
				return ec.fieldContext_Household_lots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionCategory_transactions(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionCategory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionCategory_transactions,
		func(ctx context.Context) (any, error) {
			return obj.Transactions(ctx)
		},
		nil,
		ec.marshalOTransaction2ᚕᚖfijoyᚗappᚋentᚐTransactionᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionCategory_transactions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionCategory",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionConnection_edges,
		func(ctx context.Context) (any, error) {
			return obj.Edges, nil
		},
		nil,
		ec.marshalOTransactionEdge2ᚕᚖfijoyᚗappᚋentᚐTransactionEdge,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEdge_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalOTransaction2ᚖfijoyᚗappᚋentᚐTransaction,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEdge_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_id(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_amount(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_amount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionEntry().Amount(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_household(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2ᚖfijoyᚗappᚋentᚐHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "lots":
				return ec.fieldContext_Household_lots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_account(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_account,
		func(ctx context.Context) (any, error) {
			return obj.Account(ctx)
		},
		nil,
		ec.marshalNAccount2ᚖfijoyᚗappᚋentᚐAccount,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_currency(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_currency,
		func(ctx context.Context) (any, error) {
			return obj.Currency(ctx)
		},
		nil,
		ec.marshalNCurrency2ᚖfijoyᚗappᚋentᚐCurrency,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "code":
				return ec.fieldContext_Currency_code(ctx, field)
			case "accounts":
				return ec.fieldContext_Currency_accounts(ctx, field)
			case "investments":
				return ec.fieldContext_Currency_investments(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Currency_transactionEntries(ctx, field)
			case "households":
				return ec.fieldContext_Currency_households(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEntry_transaction(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionEntry_transaction,
		func(ctx context.Context) (any, error) {
			return obj.Transaction(ctx)
		},
		nil,
		ec.marshalNTransaction2ᚖfijoyᚗappᚋentᚐTransaction,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionEntry_transaction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_email,
		func(ctx context.Context) (any, error) {
			return obj.Email, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_households(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_households,
		func(ctx context.Context) (any, error) {
			return obj.Households(ctx)
		},
		nil,
		ec.marshalOHousehold2ᚕᚖfijoyᚗappᚋentᚐHouseholdᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_households(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "lots":
				return ec.fieldContext_Household_lots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_accounts(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_accounts,
		func(ctx context.Context) (any, error) {
			return obj.Accounts(ctx)
		},
		nil,
		ec.marshalOAccount2ᚕᚖfijoyᚗappᚋentᚐAccountᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_accounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Account_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Account_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Account_householdID(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			case "type":
				return ec.fieldContext_Account_type(ctx, field)
			case "balance":
				return ec.fieldContext_Account_balance(ctx, field)
			case "value":
				return ec.fieldContext_Account_value(ctx, field)
			case "fxRate":
				return ec.fieldContext_Account_fxRate(ctx, field)
			case "household":
				return ec.fieldContext_Account_household(ctx, field)
			case "currency":
				return ec.fieldContext_Account_currency(ctx, field)
			case "user":
				return ec.fieldContext_Account_user(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Account_transactionEntries(ctx, field)
			case "investments":
				return ec.fieldContext_Account_investments(ctx, field)
			case "balanceInHouseholdCurrency":
				return ec.fieldContext_Account_balanceInHouseholdCurrency(ctx, field)
			case "valueInHouseholdCurrency":
				return ec.fieldContext_Account_valueInHouseholdCurrency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_transactions(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_transactions,
		func(ctx context.Context) (any, error) {
			return obj.Transactions(ctx)
		},
		nil,
		ec.marshalOTransaction2ᚕᚖfijoyᚗappᚋentᚐTransactionᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_transactions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Transaction_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Transaction_updateTime(ctx, field)
			case "householdID":
				return ec.fieldContext_Transaction_householdID(ctx, field)
			case "description":
				return ec.fieldContext_Transaction_description(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "household":
				return ec.fieldContext_Transaction_household(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Transaction_transactionEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userKeys(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_userKeys,
		func(ctx context.Context) (any, error) {
			return obj.UserKeys(ctx)
		},
		nil,
		ec.marshalOUserKey2ᚕᚖfijoyᚗappᚋentᚐUserKeyᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_userKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserKey_id(ctx, field)
			case "createTime":
				return ec.fieldContext_UserKey_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_UserKey_updateTime(ctx, field)
			case "provider":
				return ec.fieldContext_UserKey_provider(ctx, field)
			case "key":
				return ec.fieldContext_UserKey_key(ctx, field)
			case "user":
				return ec.fieldContext_UserKey_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userHouseholds(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_userHouseholds,
		func(ctx context.Context) (any, error) {
			return obj.UserHouseholds(ctx)
		},
		nil,
		ec.marshalOUserHousehold2ᚕᚖfijoyᚗappᚋentᚐUserHouseholdᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_userHouseholds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserHousehold_id(ctx, field)
			case "createTime":
				return ec.fieldContext_UserHousehold_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_UserHousehold_updateTime(ctx, field)
			case "userID":
				return ec.fieldContext_UserHousehold_userID(ctx, field)
			case "householdID":
				return ec.fieldContext_UserHousehold_householdID(ctx, field)
			case "role":
				return ec.fieldContext_UserHousehold_role(ctx, field)
			case "user":
				return ec.fieldContext_UserHousehold_user(ctx, field)
			case "household":
				return ec.fieldContext_UserHousehold_household(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserHousehold", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_id(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_userID(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_userID,
		func(ctx context.Context) (any, error) {
			return obj.UserID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_householdID(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_householdID,
		func(ctx context.Context) (any, error) {
			return obj.HouseholdID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_householdID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_role(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_role,
		func(ctx context.Context) (any, error) {
			return obj.Role, nil
		},
		nil,
		ec.marshalNUserHouseholdRole2fijoyᚗappᚋentᚋuserhouseholdᚐRole,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserHouseholdRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_user(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_user,
		func(ctx context.Context) (any, error) {
			return obj.User(ctx)
		},
		nil,
		ec.marshalNUser2ᚖfijoyᚗappᚋentᚐUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "households":
				return ec.fieldContext_User_households(ctx, field)
			case "accounts":
				return ec.fieldContext_User_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_User_transactions(ctx, field)
			case "userKeys":
				return ec.fieldContext_User_userKeys(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_User_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserHousehold_household(ctx context.Context, field graphql.CollectedField, obj *ent.UserHousehold) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserHousehold_household,
		func(ctx context.Context) (any, error) {
			return obj.Household(ctx)
		},
		nil,
		ec.marshalNHousehold2ᚖfijoyᚗappᚋentᚐHousehold,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserHousehold_household(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserHousehold",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Household_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Household_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Household_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Household_name(ctx, field)
			case "locale":
				return ec.fieldContext_Household_locale(ctx, field)
			case "currency":
				return ec.fieldContext_Household_currency(ctx, field)
			case "users":
				return ec.fieldContext_Household_users(ctx, field)
			case "accounts":
				return ec.fieldContext_Household_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_Household_transactions(ctx, field)
			case "investments":
				return ec.fieldContext_Household_investments(ctx, field)
			case "lots":
				return ec.fieldContext_Household_lots(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Household_transactionCategories(ctx, field)
			case "transactionEntries":
				return ec.fieldContext_Household_transactionEntries(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_Household_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Household", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_id(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_updateTime,
		func(ctx context.Context) (any, error) {
			return obj.UpdateTime, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_provider(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_provider,
		func(ctx context.Context) (any, error) {
			return obj.Provider, nil
		},
		nil,
		ec.marshalNUserKeyProvider2fijoyᚗappᚋentᚋuserkeyᚐProvider,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserKeyProvider does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_key(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserKey_user(ctx context.Context, field graphql.CollectedField, obj *ent.UserKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserKey_user,
		func(ctx context.Context) (any, error) {
			return obj.User(ctx)
		},
		nil,
		ec.marshalNUser2ᚖfijoyᚗappᚋentᚐUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserKey_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "households":
				return ec.fieldContext_User_households(ctx, field)
			case "accounts":
				return ec.fieldContext_User_accounts(ctx, field)
			case "transactions":
				return ec.fieldContext_User_transactions(ctx, field)
			case "userKeys":
				return ec.fieldContext_User_userKeys(ctx, field)
			case "userHouseholds":
				return ec.fieldContext_User_userHouseholds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2ᚕstringᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAccountWhereInput(ctx context.Context, obj any) (ent.AccountWhereInput, error) {
	var it ent.AccountWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "balance", "balanceNEQ", "balanceIn", "balanceNotIn", "balanceGT", "balanceGTE", "balanceLT", "balanceLTE", "value", "valueNEQ", "valueIn", "valueNotIn", "valueGT", "valueGTE", "valueLT", "valueLTE", "fxRate", "fxRateNEQ", "fxRateIn", "fxRateNotIn", "fxRateGT", "fxRateGTE", "fxRateLT", "fxRateLTE", "hasHousehold", "hasHouseholdWith", "hasCurrency", "hasCurrencyWith", "hasUser", "hasUserWith", "hasTransactionEntries", "hasTransactionEntriesWith", "hasInvestments", "hasInvestmentsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOAccountWhereInput2ᚖfijoyᚗappᚋentᚐAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOAccountWhereInput2ᚕᚖfijoyᚗappᚋentᚐAccountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOAccountWhereInput2ᚕᚖfijoyᚗappᚋentᚐAccountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOAccountType2ᚖfijoyᚗappᚋentᚋaccountᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOAccountType2ᚖfijoyᚗappᚋentᚋaccountᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOAccountType2ᚕfijoyᚗappᚋentᚋaccountᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOAccountType2ᚕfijoyᚗappᚋentᚋaccountᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "balance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balance"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().Balance(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "balanceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().BalanceLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().Value(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().ValueLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRate(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "fxRateLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fxRateLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AccountWhereInput().FxRateLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasCurrency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrency"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrency = data
		case "hasCurrencyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyWith"))
			data, err := ec.unmarshalOCurrencyWhereInput2ᚕᚖfijoyᚗappᚋentᚐCurrencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrencyWith = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		case "hasTransactionEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntries"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntries = data
		case "hasTransactionEntriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntriesWith"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntriesWith = data
		case "hasInvestments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestments"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestments = data
		case "hasInvestmentsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentsWith"))
			data, err := ec.unmarshalOInvestmentWhereInput2ᚕᚖfijoyᚗappᚋentᚐInvestmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCurrencyWhereInput(ctx context.Context, obj any) (ent.CurrencyWhereInput, error) {
	var it ent.CurrencyWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "code", "codeNEQ", "codeIn", "codeNotIn", "codeGT", "codeGTE", "codeLT", "codeLTE", "codeContains", "codeHasPrefix", "codeHasSuffix", "codeEqualFold", "codeContainsFold", "hasAccounts", "hasAccountsWith", "hasInvestments", "hasInvestmentsWith", "hasTransactionEntries", "hasTransactionEntriesWith", "hasHouseholds", "hasHouseholdsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOCurrencyWhereInput2ᚖfijoyᚗappᚋentᚐCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOCurrencyWhereInput2ᚕᚖfijoyᚗappᚋentᚐCurrencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOCurrencyWhereInput2ᚕᚖfijoyᚗappᚋentᚐCurrencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Code = data
		case "codeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeNEQ = data
		case "codeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeIn = data
		case "codeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeNotIn = data
		case "codeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeGT = data
		case "codeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeGTE = data
		case "codeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeLT = data
		case "codeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeLTE = data
		case "codeContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeContains = data
		case "codeHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeHasPrefix = data
		case "codeHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeHasSuffix = data
		case "codeEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeEqualFold = data
		case "codeContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeContainsFold = data
		case "hasAccounts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccounts"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccounts = data
		case "hasAccountsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountsWith"))
			data, err := ec.unmarshalOAccountWhereInput2ᚕᚖfijoyᚗappᚋentᚐAccountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccountsWith = data
		case "hasInvestments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestments"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestments = data
		case "hasInvestmentsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentsWith"))
			data, err := ec.unmarshalOInvestmentWhereInput2ᚕᚖfijoyᚗappᚋentᚐInvestmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentsWith = data
		case "hasTransactionEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntries"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntries = data
		case "hasTransactionEntriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntriesWith"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntriesWith = data
		case "hasHouseholds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholds"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholds = data
		case "hasHouseholdsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdsWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHouseholdWhereInput(ctx context.Context, obj any) (ent.HouseholdWhereInput, error) {
	var it ent.HouseholdWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "locale", "localeNEQ", "localeIn", "localeNotIn", "localeGT", "localeGTE", "localeLT", "localeLTE", "localeContains", "localeHasPrefix", "localeHasSuffix", "localeEqualFold", "localeContainsFold", "hasCurrency", "hasCurrencyWith", "hasUsers", "hasUsersWith", "hasAccounts", "hasAccountsWith", "hasTransactions", "hasTransactionsWith", "hasInvestments", "hasInvestmentsWith", "hasLots", "hasLotsWith", "hasTransactionCategories", "hasTransactionCategoriesWith", "hasTransactionEntries", "hasTransactionEntriesWith", "hasUserHouseholds", "hasUserHouseholdsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚖfijoyᚗappᚋentᚐHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "locale":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locale"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locale = data
		case "localeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleNEQ = data
		case "localeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleIn = data
		case "localeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleNotIn = data
		case "localeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleGT = data
		case "localeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleGTE = data
		case "localeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleLT = data
		case "localeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleLTE = data
		case "localeContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleContains = data
		case "localeHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleHasPrefix = data
		case "localeHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleHasSuffix = data
		case "localeEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleEqualFold = data
		case "localeContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localeContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocaleContainsFold = data
		case "hasCurrency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrency"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrency = data
		case "hasCurrencyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyWith"))
			data, err := ec.unmarshalOCurrencyWhereInput2ᚕᚖfijoyᚗappᚋentᚐCurrencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrencyWith = data
		case "hasUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsers"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsers = data
		case "hasUsersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsersWith"))
			data, err := ec.unmarshalOUserWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsersWith = data
		case "hasAccounts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccounts"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccounts = data
		case "hasAccountsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountsWith"))
			data, err := ec.unmarshalOAccountWhereInput2ᚕᚖfijoyᚗappᚋentᚐAccountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccountsWith = data
		case "hasTransactions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactions"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactions = data
		case "hasTransactionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionsWith"))
			data, err := ec.unmarshalOTransactionWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionsWith = data
		case "hasInvestments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestments"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestments = data
		case "hasInvestmentsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentsWith"))
			data, err := ec.unmarshalOInvestmentWhereInput2ᚕᚖfijoyᚗappᚋentᚐInvestmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentsWith = data
		case "hasLots":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLots"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLots = data
		case "hasLotsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLotsWith"))
			data, err := ec.unmarshalOLotWhereInput2ᚕᚖfijoyᚗappᚋentᚐLotWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLotsWith = data
		case "hasTransactionCategories":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionCategories"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionCategories = data
		case "hasTransactionCategoriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionCategoriesWith"))
			data, err := ec.unmarshalOTransactionCategoryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionCategoryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionCategoriesWith = data
		case "hasTransactionEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntries"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntries = data
		case "hasTransactionEntriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntriesWith"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntriesWith = data
		case "hasUserHouseholds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserHouseholds"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserHouseholds = data
		case "hasUserHouseholdsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserHouseholdsWith"))
			data, err := ec.unmarshalOUserHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserHouseholdsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInvestmentWhereInput(ctx context.Context, obj any) (ent.InvestmentWhereInput, error) {
	var it ent.InvestmentWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "symbol", "symbolNEQ", "symbolIn", "symbolNotIn", "symbolGT", "symbolGTE", "symbolLT", "symbolLTE", "symbolContains", "symbolHasPrefix", "symbolHasSuffix", "symbolEqualFold", "symbolContainsFold", "amount", "amountNEQ", "amountIn", "amountNotIn", "amountGT", "amountGTE", "amountLT", "amountLTE", "quote", "quoteNEQ", "quoteIn", "quoteNotIn", "quoteGT", "quoteGTE", "quoteLT", "quoteLTE", "value", "valueNEQ", "valueIn", "valueNotIn", "valueGT", "valueGTE", "valueLT", "valueLTE", "hasAccount", "hasAccountWith", "hasHousehold", "hasHouseholdWith", "hasCurrency", "hasCurrencyWith", "hasLots", "hasLotsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOInvestmentWhereInput2ᚖfijoyᚗappᚋentᚐInvestmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOInvestmentWhereInput2ᚕᚖfijoyᚗappᚋentᚐInvestmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOInvestmentWhereInput2ᚕᚖfijoyᚗappᚋentᚐInvestmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOInvestmentType2ᚖfijoyᚗappᚋentᚋinvestmentᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOInvestmentType2ᚖfijoyᚗappᚋentᚋinvestmentᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOInvestmentType2ᚕfijoyᚗappᚋentᚋinvestmentᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOInvestmentType2ᚕfijoyᚗappᚋentᚋinvestmentᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "symbol":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbol"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Symbol = data
		case "symbolNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolNEQ = data
		case "symbolIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolIn = data
		case "symbolNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolNotIn = data
		case "symbolGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolGT = data
		case "symbolGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolGTE = data
		case "symbolLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolLT = data
		case "symbolLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolLTE = data
		case "symbolContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolContains = data
		case "symbolHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolHasPrefix = data
		case "symbolHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolHasSuffix = data
		case "symbolEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolEqualFold = data
		case "symbolContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SymbolContainsFold = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().AmountLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "quote":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quote"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().Quote(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "quoteLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quoteLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().QuoteLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().Value(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "valueLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.InvestmentWhereInput().ValueLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "hasAccount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccount"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccount = data
		case "hasAccountWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountWith"))
			data, err := ec.unmarshalOAccountWhereInput2ᚕᚖfijoyᚗappᚋentᚐAccountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccountWith = data
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasCurrency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrency"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrency = data
		case "hasCurrencyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyWith"))
			data, err := ec.unmarshalOCurrencyWhereInput2ᚕᚖfijoyᚗappᚋentᚐCurrencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrencyWith = data
		case "hasLots":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLots"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLots = data
		case "hasLotsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLotsWith"))
			data, err := ec.unmarshalOLotWhereInput2ᚕᚖfijoyᚗappᚋentᚐLotWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLotsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLotWhereInput(ctx context.Context, obj any) (ent.LotWhereInput, error) {
	var it ent.LotWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "datetime", "datetimeNEQ", "datetimeIn", "datetimeNotIn", "datetimeGT", "datetimeGTE", "datetimeLT", "datetimeLTE", "amount", "amountNEQ", "amountIn", "amountNotIn", "amountGT", "amountGTE", "amountLT", "amountLTE", "price", "priceNEQ", "priceIn", "priceNotIn", "priceGT", "priceGTE", "priceLT", "priceLTE", "hasHousehold", "hasHouseholdWith", "hasInvestment", "hasInvestmentWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOLotWhereInput2ᚖfijoyᚗappᚋentᚐLotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOLotWhereInput2ᚕᚖfijoyᚗappᚋentᚐLotWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOLotWhereInput2ᚕᚖfijoyᚗappᚋentᚐLotWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "datetime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Datetime = data
		case "datetimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeNEQ = data
		case "datetimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeIn = data
		case "datetimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeNotIn = data
		case "datetimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeGT = data
		case "datetimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeGTE = data
		case "datetimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeLT = data
		case "datetimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeLTE = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().AmountNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().AmountIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().AmountNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().AmountGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().AmountGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().AmountLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().AmountLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "price":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("price"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().Price(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().PriceNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().PriceIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().PriceNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().PriceGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().PriceGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().PriceLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LotWhereInput().PriceLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasInvestment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestment"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestment = data
		case "hasInvestmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInvestmentWith"))
			data, err := ec.unmarshalOInvestmentWhereInput2ᚕᚖfijoyᚗappᚋentᚐInvestmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasInvestmentWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionCategoryWhereInput(ctx context.Context, obj any) (ent.TransactionCategoryWhereInput, error) {
	var it ent.TransactionCategoryWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "hasHousehold", "hasHouseholdWith", "hasTransactions", "hasTransactionsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOTransactionCategoryWhereInput2ᚖfijoyᚗappᚋentᚐTransactionCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOTransactionCategoryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionCategoryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOTransactionCategoryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionCategoryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOTransactionCategoryType2ᚖfijoyᚗappᚋentᚋtransactioncategoryᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOTransactionCategoryType2ᚖfijoyᚗappᚋentᚋtransactioncategoryᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOTransactionCategoryType2ᚕfijoyᚗappᚋentᚋtransactioncategoryᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOTransactionCategoryType2ᚕfijoyᚗappᚋentᚋtransactioncategoryᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasTransactions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactions"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactions = data
		case "hasTransactionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionsWith"))
			data, err := ec.unmarshalOTransactionWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionEntryWhereInput(ctx context.Context, obj any) (ent.TransactionEntryWhereInput, error) {
	var it ent.TransactionEntryWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "amount", "amountNEQ", "amountIn", "amountNotIn", "amountGT", "amountGTE", "amountLT", "amountLTE", "hasHousehold", "hasHouseholdWith", "hasAccount", "hasAccountWith", "hasCurrency", "hasCurrencyWith", "hasTransaction", "hasTransactionWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2ᚖfijoyᚗappᚋentᚐTransactionEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().Amount(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "amountLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TransactionEntryWhereInput().AmountLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasAccount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccount"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccount = data
		case "hasAccountWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountWith"))
			data, err := ec.unmarshalOAccountWhereInput2ᚕᚖfijoyᚗappᚋentᚐAccountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccountWith = data
		case "hasCurrency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrency"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrency = data
		case "hasCurrencyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyWith"))
			data, err := ec.unmarshalOCurrencyWhereInput2ᚕᚖfijoyᚗappᚋentᚐCurrencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCurrencyWith = data
		case "hasTransaction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransaction"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransaction = data
		case "hasTransactionWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionWith"))
			data, err := ec.unmarshalOTransactionWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionOrder(ctx context.Context, obj any) (ent.TransactionOrder, error) {
	var it ent.TransactionOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNTransactionOrderField2ᚖfijoyᚗappᚋentᚐTransactionOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionWhereInput(ctx context.Context, obj any) (ent.TransactionWhereInput, error) {
	var it ent.TransactionWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "householdID", "householdIDNEQ", "householdIDIn", "householdIDNotIn", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionIsNil", "descriptionNotNil", "descriptionEqualFold", "descriptionContainsFold", "datetime", "datetimeNEQ", "datetimeIn", "datetimeNotIn", "datetimeGT", "datetimeGTE", "datetimeLT", "datetimeLTE", "hasUser", "hasUserWith", "hasHousehold", "hasHouseholdWith", "hasCategory", "hasCategoryWith", "hasTransactionEntries", "hasTransactionEntriesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOTransactionWhereInput2ᚖfijoyᚗappᚋentᚐTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOTransactionWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOTransactionWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "householdID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdID"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdID = data
		case "householdIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNEQ = data
		case "householdIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDIn = data
		case "householdIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("householdIDNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HouseholdIDNotIn = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "descriptionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNEQ = data
		case "descriptionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIn = data
		case "descriptionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotIn = data
		case "descriptionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGT = data
		case "descriptionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGTE = data
		case "descriptionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLT = data
		case "descriptionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLTE = data
		case "descriptionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContains = data
		case "descriptionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasPrefix = data
		case "descriptionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasSuffix = data
		case "descriptionIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIsNil = data
		case "descriptionNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotNil = data
		case "descriptionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionEqualFold = data
		case "descriptionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContainsFold = data
		case "datetime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Datetime = data
		case "datetimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeNEQ = data
		case "datetimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeIn = data
		case "datetimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeNotIn = data
		case "datetimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeGT = data
		case "datetimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeGTE = data
		case "datetimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeLT = data
		case "datetimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatetimeLTE = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		case "hasHousehold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHousehold"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHousehold = data
		case "hasHouseholdWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdWith = data
		case "hasCategory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCategory"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCategory = data
		case "hasCategoryWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCategoryWith"))
			data, err := ec.unmarshalOTransactionCategoryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionCategoryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCategoryWith = data
		case "hasTransactionEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntries"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntries = data
		case "hasTransactionEntriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionEntriesWith"))
			data, err := ec.unmarshalOTransactionEntryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionEntriesWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserHouseholdWhereInput(ctx context.Context, obj any) (ent.UserHouseholdWhereInput, error) {
	var it ent.UserHouseholdWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "role", "roleNEQ", "roleIn", "roleNotIn"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserHouseholdWhereInput2ᚖfijoyᚗappᚋentᚐUserHouseholdWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOUserHouseholdRole2ᚖfijoyᚗappᚋentᚋuserhouseholdᚐRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "roleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleNEQ"))
			data, err := ec.unmarshalOUserHouseholdRole2ᚖfijoyᚗappᚋentᚋuserhouseholdᚐRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleNEQ = data
		case "roleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleIn"))
			data, err := ec.unmarshalOUserHouseholdRole2ᚕfijoyᚗappᚋentᚋuserhouseholdᚐRoleᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleIn = data
		case "roleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleNotIn"))
			data, err := ec.unmarshalOUserHouseholdRole2ᚕfijoyᚗappᚋentᚋuserhouseholdᚐRoleᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleNotIn = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserKeyWhereInput(ctx context.Context, obj any) (ent.UserKeyWhereInput, error) {
	var it ent.UserKeyWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "provider", "providerNEQ", "providerIn", "providerNotIn", "key", "keyNEQ", "keyIn", "keyNotIn", "keyGT", "keyGTE", "keyLT", "keyLTE", "keyContains", "keyHasPrefix", "keyHasSuffix", "keyEqualFold", "keyContainsFold", "hasUser", "hasUserWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserKeyWhereInput2ᚖfijoyᚗappᚋentᚐUserKeyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserKeyWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserKeyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserKeyWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserKeyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "provider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalOUserKeyProvider2ᚖfijoyᚗappᚋentᚋuserkeyᚐProvider(ctx, v)
			if err != nil {
				return it, err
			}
			it.Provider = data
		case "providerNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerNEQ"))
			data, err := ec.unmarshalOUserKeyProvider2ᚖfijoyᚗappᚋentᚋuserkeyᚐProvider(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderNEQ = data
		case "providerIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerIn"))
			data, err := ec.unmarshalOUserKeyProvider2ᚕfijoyᚗappᚋentᚋuserkeyᚐProviderᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderIn = data
		case "providerNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerNotIn"))
			data, err := ec.unmarshalOUserKeyProvider2ᚕfijoyᚗappᚋentᚋuserkeyᚐProviderᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderNotIn = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "keyNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyNEQ = data
		case "keyIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyIn = data
		case "keyNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyNotIn = data
		case "keyGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyGT = data
		case "keyGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyGTE = data
		case "keyLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyLT = data
		case "keyLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyLTE = data
		case "keyContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyContains = data
		case "keyHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyHasPrefix = data
		case "keyHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyHasSuffix = data
		case "keyEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyEqualFold = data
		case "keyContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyContainsFold = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereInput(ctx context.Context, obj any) (ent.UserWhereInput, error) {
	var it ent.UserWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "email", "emailNEQ", "emailIn", "emailNotIn", "emailGT", "emailGTE", "emailLT", "emailLTE", "emailContains", "emailHasPrefix", "emailHasSuffix", "emailEqualFold", "emailContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasHouseholds", "hasHouseholdsWith", "hasAccounts", "hasAccountsWith", "hasTransactions", "hasTransactionsWith", "hasUserKeys", "hasUserKeysWith", "hasUserHouseholds", "hasUserHouseholdsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserWhereInput2ᚖfijoyᚗappᚋentᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "emailNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNEQ = data
		case "emailIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailIn = data
		case "emailNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNotIn = data
		case "emailGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailGT = data
		case "emailGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailGTE = data
		case "emailLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailLT = data
		case "emailLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailLTE = data
		case "emailContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailContains = data
		case "emailHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailHasPrefix = data
		case "emailHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailHasSuffix = data
		case "emailEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailEqualFold = data
		case "emailContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hasHouseholds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholds"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholds = data
		case "hasHouseholdsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHouseholdsWith"))
			data, err := ec.unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHouseholdsWith = data
		case "hasAccounts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccounts"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccounts = data
		case "hasAccountsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountsWith"))
			data, err := ec.unmarshalOAccountWhereInput2ᚕᚖfijoyᚗappᚋentᚐAccountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccountsWith = data
		case "hasTransactions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactions"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactions = data
		case "hasTransactionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionsWith"))
			data, err := ec.unmarshalOTransactionWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTransactionsWith = data
		case "hasUserKeys":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserKeys"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserKeys = data
		case "hasUserKeysWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserKeysWith"))
			data, err := ec.unmarshalOUserKeyWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserKeyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserKeysWith = data
		case "hasUserHouseholds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserHouseholds"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserHouseholds = data
		case "hasUserHouseholdsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserHouseholdsWith"))
			data, err := ec.unmarshalOUserHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserHouseholdWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserHouseholdsWith = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.UserKey:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserKey(ctx, sel, obj)
	case *ent.UserHousehold:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserHousehold(ctx, sel, obj)
	case *ent.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case *ent.TransactionEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._TransactionEntry(ctx, sel, obj)
	case *ent.TransactionCategory:
		if obj == nil {
			return graphql.Null
		}
		return ec._TransactionCategory(ctx, sel, obj)
	case *ent.Transaction:
		if obj == nil {
			return graphql.Null
		}
		return ec._Transaction(ctx, sel, obj)
	case *ent.Lot:
		if obj == nil {
			return graphql.Null
		}
		return ec._Lot(ctx, sel, obj)
	case *ent.Investment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Investment(ctx, sel, obj)
	case *ent.Household:
		if obj == nil {
			return graphql.Null
		}
		return ec._Household(ctx, sel, obj)
	case *ent.Currency:
		if obj == nil {
			return graphql.Null
		}
		return ec._Currency(ctx, sel, obj)
	case *ent.Account:
		if obj == nil {
			return graphql.Null
		}
		return ec._Account(ctx, sel, obj)
	default:
		if obj, ok := obj.(graphql.Marshaler); ok {
			return obj
		} else {
			panic(fmt.Errorf("unexpected type %T; non-generated variants of Node must implement graphql.Marshaler", obj))
		}
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var accountImplementors = []string{"Account", "Node"}

func (ec *executionContext) _Account(ctx context.Context, sel ast.SelectionSet, obj *ent.Account) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Account")
		case "id":
			out.Values[i] = ec._Account_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Account_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._Account_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._Account_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Account_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Account_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "balance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_balance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "value":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_value(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fxRate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_fxRate(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "currency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_currency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionEntries":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_transactionEntries(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investments":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_investments(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "balanceInHouseholdCurrency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_balanceInHouseholdCurrency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valueInHouseholdCurrency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_valueInHouseholdCurrency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var currencyImplementors = []string{"Currency", "Node"}

func (ec *executionContext) _Currency(ctx context.Context, sel ast.SelectionSet, obj *ent.Currency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, currencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Currency")
		case "id":
			out.Values[i] = ec._Currency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "code":
			out.Values[i] = ec._Currency_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "accounts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Currency_accounts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investments":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Currency_investments(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionEntries":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Currency_transactionEntries(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "households":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Currency_households(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var householdImplementors = []string{"Household", "Node"}

func (ec *executionContext) _Household(ctx context.Context, sel ast.SelectionSet, obj *ent.Household) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, householdImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Household")
		case "id":
			out.Values[i] = ec._Household_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Household_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._Household_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Household_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "locale":
			out.Values[i] = ec._Household_locale(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "currency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_currency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_users(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "accounts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_accounts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_transactions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investments":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_investments(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lots":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_lots(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionCategories":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_transactionCategories(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionEntries":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_transactionEntries(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userHouseholds":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Household_userHouseholds(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var investmentImplementors = []string{"Investment", "Node"}

func (ec *executionContext) _Investment(ctx context.Context, sel ast.SelectionSet, obj *ent.Investment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, investmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Investment")
		case "id":
			out.Values[i] = ec._Investment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Investment_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._Investment_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._Investment_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Investment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Investment_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "symbol":
			out.Values[i] = ec._Investment_symbol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "amount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_amount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "quote":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_quote(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "value":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_value(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "account":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_account(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "currency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_currency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lots":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_lots(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valueInHouseholdCurrency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Investment_valueInHouseholdCurrency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lotImplementors = []string{"Lot", "Node"}

func (ec *executionContext) _Lot(ctx context.Context, sel ast.SelectionSet, obj *ent.Lot) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lotImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Lot")
		case "id":
			out.Values[i] = ec._Lot_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Lot_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._Lot_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._Lot_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "datetime":
			out.Values[i] = ec._Lot_datetime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "amount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lot_amount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "price":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lot_price(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lot_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "investment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lot_investment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lotConnectionImplementors = []string{"LotConnection"}

func (ec *executionContext) _LotConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.LotConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lotConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LotConnection")
		case "edges":
			out.Values[i] = ec._LotConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._LotConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._LotConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lotEdgeImplementors = []string{"LotEdge"}

func (ec *executionContext) _LotEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.LotEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lotEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LotEdge")
		case "node":
			out.Values[i] = ec._LotEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._LotEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entgql.PageInfo[int]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "accounts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_accounts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "currencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currencies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "households":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_households(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "investments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_investments(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "lots":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_lots(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transactions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "transactionCategories":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transactionCategories(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "transactionEntries":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transactionEntries(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userHouseholds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userHouseholds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fxRate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fxRate(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionImplementors = []string{"Transaction", "Node"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *ent.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "id":
			out.Values[i] = ec._Transaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Transaction_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._Transaction_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._Transaction_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Transaction_description(ctx, field, obj)
		case "datetime":
			out.Values[i] = ec._Transaction_datetime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "category":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_category(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactionEntries":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_transactionEntries(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionCategoryImplementors = []string{"TransactionCategory", "Node"}

func (ec *executionContext) _TransactionCategory(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionCategory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionCategoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionCategory")
		case "id":
			out.Values[i] = ec._TransactionCategory_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._TransactionCategory_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._TransactionCategory_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._TransactionCategory_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._TransactionCategory_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._TransactionCategory_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionCategory_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionCategory_transactions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionConnectionImplementors = []string{"TransactionConnection"}

func (ec *executionContext) _TransactionConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionConnection")
		case "edges":
			out.Values[i] = ec._TransactionConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._TransactionConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TransactionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionEdgeImplementors = []string{"TransactionEdge"}

func (ec *executionContext) _TransactionEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionEdge")
		case "node":
			out.Values[i] = ec._TransactionEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._TransactionEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionEntryImplementors = []string{"TransactionEntry", "Node"}

func (ec *executionContext) _TransactionEntry(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionEntry")
		case "id":
			out.Values[i] = ec._TransactionEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._TransactionEntry_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._TransactionEntry_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._TransactionEntry_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "amount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionEntry_amount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionEntry_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "account":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionEntry_account(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "currency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionEntry_currency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transaction":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionEntry_transaction(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "Node"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *ent.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._User_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._User_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "households":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_households(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "accounts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_accounts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_transactions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userKeys":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_userKeys(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userHouseholds":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_userHouseholds(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userHouseholdImplementors = []string{"UserHousehold", "Node"}

func (ec *executionContext) _UserHousehold(ctx context.Context, sel ast.SelectionSet, obj *ent.UserHousehold) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userHouseholdImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserHousehold")
		case "id":
			out.Values[i] = ec._UserHousehold_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._UserHousehold_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._UserHousehold_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			out.Values[i] = ec._UserHousehold_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "householdID":
			out.Values[i] = ec._UserHousehold_householdID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "role":
			out.Values[i] = ec._UserHousehold_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserHousehold_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "household":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserHousehold_household(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userKeyImplementors = []string{"UserKey", "Node"}

func (ec *executionContext) _UserKey(ctx context.Context, sel ast.SelectionSet, obj *ent.UserKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserKey")
		case "id":
			out.Values[i] = ec._UserKey_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._UserKey_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._UserKey_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "provider":
			out.Values[i] = ec._UserKey_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "key":
			out.Values[i] = ec._UserKey_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserKey_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAccount2ᚕᚖfijoyᚗappᚋentᚐAccountᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Account) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccount2ᚖfijoyᚗappᚋentᚐAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAccount2ᚖfijoyᚗappᚋentᚐAccount(ctx context.Context, sel ast.SelectionSet, v *ent.Account) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Account(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAccountType2fijoyᚗappᚋentᚋaccountᚐType(ctx context.Context, v any) (account.Type, error) {
	var res account.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAccountType2fijoyᚗappᚋentᚋaccountᚐType(ctx context.Context, sel ast.SelectionSet, v account.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAccountWhereInput2ᚖfijoyᚗappᚋentᚐAccountWhereInput(ctx context.Context, v any) (*ent.AccountWhereInput, error) {
	res, err := ec.unmarshalInputAccountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCurrency2ᚕᚖfijoyᚗappᚋentᚐCurrencyᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Currency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCurrency2ᚖfijoyᚗappᚋentᚐCurrency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCurrency2ᚖfijoyᚗappᚋentᚐCurrency(ctx context.Context, sel ast.SelectionSet, v *ent.Currency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Currency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCurrencyWhereInput2ᚖfijoyᚗappᚋentᚐCurrencyWhereInput(ctx context.Context, v any) (*ent.CurrencyWhereInput, error) {
	res, err := ec.unmarshalInputCurrencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, v any) (entgql.Cursor[int], error) {
	var res entgql.Cursor[int]
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, sel ast.SelectionSet, v entgql.Cursor[int]) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDateTime2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNHousehold2ᚕᚖfijoyᚗappᚋentᚐHouseholdᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Household) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHousehold2ᚖfijoyᚗappᚋentᚐHousehold(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHousehold2ᚖfijoyᚗappᚋentᚐHousehold(ctx context.Context, sel ast.SelectionSet, v *ent.Household) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Household(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHouseholdWhereInput2ᚖfijoyᚗappᚋentᚐHouseholdWhereInput(ctx context.Context, v any) (*ent.HouseholdWhereInput, error) {
	res, err := ec.unmarshalInputHouseholdWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚕintᚄ(ctx context.Context, v any) ([]int, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNInvestment2ᚕᚖfijoyᚗappᚋentᚐInvestmentᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Investment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInvestment2ᚖfijoyᚗappᚋentᚐInvestment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInvestment2ᚖfijoyᚗappᚋentᚐInvestment(ctx context.Context, sel ast.SelectionSet, v *ent.Investment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Investment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInvestmentType2fijoyᚗappᚋentᚋinvestmentᚐType(ctx context.Context, v any) (investment.Type, error) {
	var res investment.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInvestmentType2fijoyᚗappᚋentᚋinvestmentᚐType(ctx context.Context, sel ast.SelectionSet, v investment.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInvestmentWhereInput2ᚖfijoyᚗappᚋentᚐInvestmentWhereInput(ctx context.Context, v any) (*ent.InvestmentWhereInput, error) {
	res, err := ec.unmarshalInputInvestmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLot2ᚖfijoyᚗappᚋentᚐLot(ctx context.Context, sel ast.SelectionSet, v *ent.Lot) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Lot(ctx, sel, v)
}

func (ec *executionContext) marshalNLotConnection2fijoyᚗappᚋentᚐLotConnection(ctx context.Context, sel ast.SelectionSet, v ent.LotConnection) graphql.Marshaler {
	return ec._LotConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNLotConnection2ᚖfijoyᚗappᚋentᚐLotConnection(ctx context.Context, sel ast.SelectionSet, v *ent.LotConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LotConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLotWhereInput2ᚖfijoyᚗappᚋentᚐLotWhereInput(ctx context.Context, v any) (*ent.LotWhereInput, error) {
	res, err := ec.unmarshalInputLotWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNode2ᚕfijoyᚗappᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2fijoyᚗappᚋentᚐNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx context.Context, v any) (entgql.OrderDirection, error) {
	var res entgql.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx context.Context, sel ast.SelectionSet, v entgql.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v entgql.PageInfo[int]) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTransaction2ᚖfijoyᚗappᚋentᚐTransaction(ctx context.Context, sel ast.SelectionSet, v *ent.Transaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionCategory2ᚕᚖfijoyᚗappᚋentᚐTransactionCategoryᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionCategory) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionCategory2ᚖfijoyᚗappᚋentᚐTransactionCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTransactionCategory2ᚖfijoyᚗappᚋentᚐTransactionCategory(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionCategory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionCategory(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTransactionCategoryType2fijoyᚗappᚋentᚋtransactioncategoryᚐType(ctx context.Context, v any) (transactioncategory.Type, error) {
	var res transactioncategory.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionCategoryType2fijoyᚗappᚋentᚋtransactioncategoryᚐType(ctx context.Context, sel ast.SelectionSet, v transactioncategory.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTransactionCategoryWhereInput2ᚖfijoyᚗappᚋentᚐTransactionCategoryWhereInput(ctx context.Context, v any) (*ent.TransactionCategoryWhereInput, error) {
	res, err := ec.unmarshalInputTransactionCategoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionConnection2fijoyᚗappᚋentᚐTransactionConnection(ctx context.Context, sel ast.SelectionSet, v ent.TransactionConnection) graphql.Marshaler {
	return ec._TransactionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactionConnection2ᚖfijoyᚗappᚋentᚐTransactionConnection(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionEntry2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionEntry2ᚖfijoyᚗappᚋentᚐTransactionEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTransactionEntry2ᚖfijoyᚗappᚋentᚐTransactionEntry(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTransactionEntryWhereInput2ᚖfijoyᚗappᚋentᚐTransactionEntryWhereInput(ctx context.Context, v any) (*ent.TransactionEntryWhereInput, error) {
	res, err := ec.unmarshalInputTransactionEntryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTransactionOrderField2ᚖfijoyᚗappᚋentᚐTransactionOrderField(ctx context.Context, v any) (*ent.TransactionOrderField, error) {
	var res = new(ent.TransactionOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionOrderField2ᚖfijoyᚗappᚋentᚐTransactionOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNTransactionWhereInput2ᚖfijoyᚗappᚋentᚐTransactionWhereInput(ctx context.Context, v any) (*ent.TransactionWhereInput, error) {
	res, err := ec.unmarshalInputTransactionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2ᚖfijoyᚗappᚋentᚐUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserHousehold2ᚕᚖfijoyᚗappᚋentᚐUserHouseholdᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.UserHousehold) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserHousehold2ᚖfijoyᚗappᚋentᚐUserHousehold(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserHousehold2ᚖfijoyᚗappᚋentᚐUserHousehold(ctx context.Context, sel ast.SelectionSet, v *ent.UserHousehold) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserHousehold(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserHouseholdRole2fijoyᚗappᚋentᚋuserhouseholdᚐRole(ctx context.Context, v any) (userhousehold.Role, error) {
	var res userhousehold.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserHouseholdRole2fijoyᚗappᚋentᚋuserhouseholdᚐRole(ctx context.Context, sel ast.SelectionSet, v userhousehold.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserHouseholdWhereInput2ᚖfijoyᚗappᚋentᚐUserHouseholdWhereInput(ctx context.Context, v any) (*ent.UserHouseholdWhereInput, error) {
	res, err := ec.unmarshalInputUserHouseholdWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserKey2ᚖfijoyᚗappᚋentᚐUserKey(ctx context.Context, sel ast.SelectionSet, v *ent.UserKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserKey(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserKeyProvider2fijoyᚗappᚋentᚋuserkeyᚐProvider(ctx context.Context, v any) (userkey.Provider, error) {
	var res userkey.Provider
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserKeyProvider2fijoyᚗappᚋentᚋuserkeyᚐProvider(ctx context.Context, sel ast.SelectionSet, v userkey.Provider) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserKeyWhereInput2ᚖfijoyᚗappᚋentᚐUserKeyWhereInput(ctx context.Context, v any) (*ent.UserKeyWhereInput, error) {
	res, err := ec.unmarshalInputUserKeyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserWhereInput2ᚖfijoyᚗappᚋentᚐUserWhereInput(ctx context.Context, v any) (*ent.UserWhereInput, error) {
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAccount2ᚕᚖfijoyᚗappᚋentᚐAccountᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Account) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccount2ᚖfijoyᚗappᚋentᚐAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAccountType2ᚕfijoyᚗappᚋentᚋaccountᚐTypeᚄ(ctx context.Context, v any) ([]account.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]account.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAccountType2fijoyᚗappᚋentᚋaccountᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAccountType2ᚕfijoyᚗappᚋentᚋaccountᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []account.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccountType2fijoyᚗappᚋentᚋaccountᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAccountType2ᚖfijoyᚗappᚋentᚋaccountᚐType(ctx context.Context, v any) (*account.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(account.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAccountType2ᚖfijoyᚗappᚋentᚋaccountᚐType(ctx context.Context, sel ast.SelectionSet, v *account.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOAccountWhereInput2ᚕᚖfijoyᚗappᚋentᚐAccountWhereInputᚄ(ctx context.Context, v any) ([]*ent.AccountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.AccountWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAccountWhereInput2ᚖfijoyᚗappᚋentᚐAccountWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAccountWhereInput2ᚖfijoyᚗappᚋentᚐAccountWhereInput(ctx context.Context, v any) (*ent.AccountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAccountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCurrencyWhereInput2ᚕᚖfijoyᚗappᚋentᚐCurrencyWhereInputᚄ(ctx context.Context, v any) ([]*ent.CurrencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.CurrencyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCurrencyWhereInput2ᚖfijoyᚗappᚋentᚐCurrencyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCurrencyWhereInput2ᚖfijoyᚗappᚋentᚐCurrencyWhereInput(ctx context.Context, v any) (*ent.CurrencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCurrencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, v any) (*entgql.Cursor[int], error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entgql.Cursor[int])
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, sel ast.SelectionSet, v *entgql.Cursor[int]) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOHousehold2ᚕᚖfijoyᚗappᚋentᚐHouseholdᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Household) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHousehold2ᚖfijoyᚗappᚋentᚐHousehold(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐHouseholdWhereInputᚄ(ctx context.Context, v any) ([]*ent.HouseholdWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.HouseholdWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHouseholdWhereInput2ᚖfijoyᚗappᚋentᚐHouseholdWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOHouseholdWhereInput2ᚖfijoyᚗappᚋentᚐHouseholdWhereInput(ctx context.Context, v any) (*ent.HouseholdWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHouseholdWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOID2ᚕintᚄ(ctx context.Context, v any) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalIntID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalIntID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOInvestment2ᚕᚖfijoyᚗappᚋentᚐInvestmentᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Investment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInvestment2ᚖfijoyᚗappᚋentᚐInvestment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInvestmentType2ᚕfijoyᚗappᚋentᚋinvestmentᚐTypeᚄ(ctx context.Context, v any) ([]investment.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]investment.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInvestmentType2fijoyᚗappᚋentᚋinvestmentᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInvestmentType2ᚕfijoyᚗappᚋentᚋinvestmentᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []investment.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInvestmentType2fijoyᚗappᚋentᚋinvestmentᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInvestmentType2ᚖfijoyᚗappᚋentᚋinvestmentᚐType(ctx context.Context, v any) (*investment.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(investment.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInvestmentType2ᚖfijoyᚗappᚋentᚋinvestmentᚐType(ctx context.Context, sel ast.SelectionSet, v *investment.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInvestmentWhereInput2ᚕᚖfijoyᚗappᚋentᚐInvestmentWhereInputᚄ(ctx context.Context, v any) ([]*ent.InvestmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.InvestmentWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInvestmentWhereInput2ᚖfijoyᚗappᚋentᚐInvestmentWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOInvestmentWhereInput2ᚖfijoyᚗappᚋentᚐInvestmentWhereInput(ctx context.Context, v any) (*ent.InvestmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputInvestmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLot2ᚕᚖfijoyᚗappᚋentᚐLotᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Lot) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLot2ᚖfijoyᚗappᚋentᚐLot(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLot2ᚖfijoyᚗappᚋentᚐLot(ctx context.Context, sel ast.SelectionSet, v *ent.Lot) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Lot(ctx, sel, v)
}

func (ec *executionContext) marshalOLotEdge2ᚕᚖfijoyᚗappᚋentᚐLotEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.LotEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLotEdge2ᚖfijoyᚗappᚋentᚐLotEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLotEdge2ᚖfijoyᚗappᚋentᚐLotEdge(ctx context.Context, sel ast.SelectionSet, v *ent.LotEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LotEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLotWhereInput2ᚕᚖfijoyᚗappᚋentᚐLotWhereInputᚄ(ctx context.Context, v any) ([]*ent.LotWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.LotWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLotWhereInput2ᚖfijoyᚗappᚋentᚐLotWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLotWhereInput2ᚖfijoyᚗappᚋentᚐLotWhereInput(ctx context.Context, v any) (*ent.LotWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLotWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2fijoyᚗappᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx context.Context, v any) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeᚐTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2ᚕtimeᚐTimeᚄ(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeᚐTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTransaction2ᚕᚖfijoyᚗappᚋentᚐTransactionᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2ᚖfijoyᚗappᚋentᚐTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransaction2ᚖfijoyᚗappᚋentᚐTransaction(ctx context.Context, sel ast.SelectionSet, v *ent.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionCategory2ᚕᚖfijoyᚗappᚋentᚐTransactionCategoryᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionCategory2ᚖfijoyᚗappᚋentᚐTransactionCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTransactionCategoryType2ᚕfijoyᚗappᚋentᚋtransactioncategoryᚐTypeᚄ(ctx context.Context, v any) ([]transactioncategory.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]transactioncategory.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionCategoryType2fijoyᚗappᚋentᚋtransactioncategoryᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTransactionCategoryType2ᚕfijoyᚗappᚋentᚋtransactioncategoryᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []transactioncategory.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionCategoryType2fijoyᚗappᚋentᚋtransactioncategoryᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTransactionCategoryType2ᚖfijoyᚗappᚋentᚋtransactioncategoryᚐType(ctx context.Context, v any) (*transactioncategory.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(transactioncategory.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTransactionCategoryType2ᚖfijoyᚗappᚋentᚋtransactioncategoryᚐType(ctx context.Context, sel ast.SelectionSet, v *transactioncategory.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTransactionCategoryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionCategoryWhereInputᚄ(ctx context.Context, v any) ([]*ent.TransactionCategoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.TransactionCategoryWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionCategoryWhereInput2ᚖfijoyᚗappᚋentᚐTransactionCategoryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTransactionCategoryWhereInput2ᚖfijoyᚗappᚋentᚐTransactionCategoryWhereInput(ctx context.Context, v any) (*ent.TransactionCategoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionCategoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTransactionEdge2ᚕᚖfijoyᚗappᚋentᚐTransactionEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTransactionEdge2ᚖfijoyᚗappᚋentᚐTransactionEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTransactionEdge2ᚖfijoyᚗappᚋentᚐTransactionEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionEntry2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionEntry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionEntry2ᚖfijoyᚗappᚋentᚐTransactionEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTransactionEntryWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionEntryWhereInputᚄ(ctx context.Context, v any) ([]*ent.TransactionEntryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.TransactionEntryWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionEntryWhereInput2ᚖfijoyᚗappᚋentᚐTransactionEntryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTransactionEntryWhereInput2ᚖfijoyᚗappᚋentᚐTransactionEntryWhereInput(ctx context.Context, v any) (*ent.TransactionEntryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionEntryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTransactionOrder2ᚖfijoyᚗappᚋentᚐTransactionOrder(ctx context.Context, v any) (*ent.TransactionOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTransactionWhereInput2ᚕᚖfijoyᚗappᚋentᚐTransactionWhereInputᚄ(ctx context.Context, v any) ([]*ent.TransactionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.TransactionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionWhereInput2ᚖfijoyᚗappᚋentᚐTransactionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTransactionWhereInput2ᚖfijoyᚗappᚋentᚐTransactionWhereInput(ctx context.Context, v any) (*ent.TransactionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUser2ᚕᚖfijoyᚗappᚋentᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖfijoyᚗappᚋentᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUserHousehold2ᚕᚖfijoyᚗappᚋentᚐUserHouseholdᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.UserHousehold) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserHousehold2ᚖfijoyᚗappᚋentᚐUserHousehold(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserHouseholdRole2ᚕfijoyᚗappᚋentᚋuserhouseholdᚐRoleᚄ(ctx context.Context, v any) ([]userhousehold.Role, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]userhousehold.Role, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserHouseholdRole2fijoyᚗappᚋentᚋuserhouseholdᚐRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUserHouseholdRole2ᚕfijoyᚗappᚋentᚋuserhouseholdᚐRoleᚄ(ctx context.Context, sel ast.SelectionSet, v []userhousehold.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserHouseholdRole2fijoyᚗappᚋentᚋuserhouseholdᚐRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserHouseholdRole2ᚖfijoyᚗappᚋentᚋuserhouseholdᚐRole(ctx context.Context, v any) (*userhousehold.Role, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(userhousehold.Role)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserHouseholdRole2ᚖfijoyᚗappᚋentᚋuserhouseholdᚐRole(ctx context.Context, sel ast.SelectionSet, v *userhousehold.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserHouseholdWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserHouseholdWhereInputᚄ(ctx context.Context, v any) ([]*ent.UserHouseholdWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.UserHouseholdWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserHouseholdWhereInput2ᚖfijoyᚗappᚋentᚐUserHouseholdWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserHouseholdWhereInput2ᚖfijoyᚗappᚋentᚐUserHouseholdWhereInput(ctx context.Context, v any) (*ent.UserHouseholdWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserHouseholdWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserKey2ᚕᚖfijoyᚗappᚋentᚐUserKeyᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.UserKey) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserKey2ᚖfijoyᚗappᚋentᚐUserKey(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserKeyProvider2ᚕfijoyᚗappᚋentᚋuserkeyᚐProviderᚄ(ctx context.Context, v any) ([]userkey.Provider, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]userkey.Provider, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserKeyProvider2fijoyᚗappᚋentᚋuserkeyᚐProvider(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUserKeyProvider2ᚕfijoyᚗappᚋentᚋuserkeyᚐProviderᚄ(ctx context.Context, sel ast.SelectionSet, v []userkey.Provider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserKeyProvider2fijoyᚗappᚋentᚋuserkeyᚐProvider(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserKeyProvider2ᚖfijoyᚗappᚋentᚋuserkeyᚐProvider(ctx context.Context, v any) (*userkey.Provider, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(userkey.Provider)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserKeyProvider2ᚖfijoyᚗappᚋentᚋuserkeyᚐProvider(ctx context.Context, sel ast.SelectionSet, v *userkey.Provider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserKeyWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserKeyWhereInputᚄ(ctx context.Context, v any) ([]*ent.UserKeyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.UserKeyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserKeyWhereInput2ᚖfijoyᚗappᚋentᚐUserKeyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserKeyWhereInput2ᚖfijoyᚗappᚋentᚐUserKeyWhereInput(ctx context.Context, v any) (*ent.UserKeyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserKeyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserWhereInput2ᚕᚖfijoyᚗappᚋentᚐUserWhereInputᚄ(ctx context.Context, v any) ([]*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*ent.UserWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserWhereInput2ᚖfijoyᚗappᚋentᚐUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserWhereInput2ᚖfijoyᚗappᚋentᚐUserWhereInput(ctx context.Context, v any) (*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
