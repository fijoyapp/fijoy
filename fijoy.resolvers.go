package fijoy

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"time"

	"entgo.io/ent/dialect/sql"
	"fijoy.app/ent"
	"fijoy.app/ent/account"
	"fijoy.app/ent/transactionentry"
	"github.com/shopspring/decimal"
)

// Balance is the resolver for the balance field.
func (r *accountResolver) Balance(ctx context.Context, obj *ent.Account) (string, error) {
	// TODO: should just write a trigger for this
	sum, err := r.entClient.TransactionEntry.
		Query().
		Where(
			transactionentry.HasAccountWith(
				account.IDEQ(obj.ID),
			),
		).
		Modify(func(s *sql.Selector) {
			s.Select("COALESCE(SUM(amount), 0)")
		}).Float64(ctx)
	if err != nil {
		return "", err
	}

	return decimal.NewFromFloat(sum).String(), nil
}

// BalanceInHouseholdCurrency is the resolver for the balanceInHouseholdCurrency field.
func (r *accountResolver) BalanceInHouseholdCurrency(ctx context.Context, obj *ent.Account) (string, error) {
	// TODO: should load the balance from the balance field instead of recalculating
	sum, err := r.entClient.TransactionEntry.
		Query().
		Where(
			transactionentry.HasAccountWith(
				account.IDEQ(obj.ID),
			),
		).
		Modify(func(s *sql.Selector) {
			s.Select("COALESCE(SUM(amount), 0)")
		}).Float64(ctx)
	if err != nil {
		return "", err
	}

	accountCurrency, err := obj.QueryCurrency().Only(ctx)
	if err != nil {
		return "", err
	}
	householdCurrency, err := obj.QueryHousehold().QueryCurrency().Only(ctx)
	if err != nil {
		return "", err
	}

	fxRate, err := r.fxrateClient.GetRate(
		ctx,
		accountCurrency.Code,
		householdCurrency.Code,
		time.Now(),
	)
	if err != nil {
		return "", err
	}

	return decimal.NewFromFloat(sum).Mul(fxRate).String(), nil
}

// FxRate is the resolver for the fxRate field.
func (r *queryResolver) FxRate(ctx context.Context, from string, to string, datetime string) (string, error) {
	datetimeParsed, err := time.Parse(time.RFC3339, datetime)
	if err != nil {
		return "", err
	}

	rate, err := r.fxrateClient.GetRate(ctx, from, to, datetimeParsed)
	if err != nil {
		return "", err
	}

	return rate.String(), nil
}
